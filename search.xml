<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kubernetes入门到精通</title>
      <link href="/2021/09/15/Kubernetes%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
      <url>/2021/09/15/Kubernetes%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Kubernetes</p><ol><li>Kubernetes介绍</li></ol><p>1.1 应用部署方式演变</p><p>在部署应用程序的方式上，主要经历了三个时代：</p><ul><li>传统部署：互联网早期，会直接将应用程序部署在物理机上<br>优点：简单，不需要其它技术的参与<br>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</li><li>虚拟化部署：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境<br>优点：程序环境不会相互产生影响，提供了一定程度的安全性<br>缺点：增加了操作系统，浪费了部分资源</li><li>容器化部署：与虚拟化类似，但是共享了操作系统<br>优点：<br>可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等<br>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦<br>容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署<br><a href="https://img-blog.csdnimg.cn/76a8ec4ab5ed4206985a2b1af64418cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/76a8ec4ab5ed4206985a2b1af64418cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></li></ul><p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p><ul><li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li><li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li></ul><p>这些容器管理的问题统称为容器编排问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p><ul><li>Swarm：Docker自己的容器编排工具</li><li>Mesos：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li><li>Kubernetes：Google开源的的容器编排工具<br><a href="https://img-blog.csdnimg.cn/cf12df58a26049f3bfe25ca2921c5f4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/cf12df58a26049f3bfe25ca2921c5f4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></li></ul><p>1.2 kubernetes简介</p><p><a href="https://img-blog.csdnimg.cn/758845b111e0468daefb40e2187d95d3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/758845b111e0468daefb40e2187d95d3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器—-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。</p><p>kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p><ul><li>自我修复：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</li><li>弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整</li><li>服务发现：服务可以通过自动发现的形式找到它所依赖的服务</li><li>负载均衡：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li><li>版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li><li>存储编排：可以根据容器自身的需求自动创建存储卷</li></ul><p>1.3 kubernetes组件</p><p>一个kubernetes集群主要是由控制节点(master)、工作节点(node)构成，每个节点上都会安装不同的组件。</p><p>master：集群的控制平面，负责集群的决策 ( 管理 )</p><p>ApiServer : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</p><p>Scheduler : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</p><p>ControllerManager : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</p><p>Etcd ：负责存储集群中各种资源对象的信息</p><p>node：集群的数据平面，负责为容器提供运行环境 ( 干活 )</p><p>Kubelet : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</p><p>KubeProxy : 负责提供集群内部的服务发现和负载均衡</p><p>Docker : 负责节点上容器的各种操作</p><p><a href="https://img-blog.csdnimg.cn/3a4e06025c6f4eba982c738d51e77704.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/3a4e06025c6f4eba982c738d51e77704.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：</p><ol><li>首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中</li><li>一个nginx服务的安装请求会首先被发送到master节点的apiServer组件</li><li>apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上<br>在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer</li><li>apiServer调用controller-manager去调度Node节点安装nginx服务</li><li>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod<br>pod是kubernetes的最小操作单元，容器必须跑在pod中至此，</li><li>一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理</li></ol><p>这样，外界用户就可以访问集群中的nginx服务了</p><p>1.4 kubernetes概念</p><p>Master：集群控制节点，每个集群需要至少一个master节点负责集群的管控</p><p>Node：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行</p><p>Pod：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</p><p>Controller：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等</p><p>Service：pod对外服务的统一入口，下面可以维护者同一类的多个pod</p><p>Label：标签，用于对pod进行分类，同一类pod会拥有相同的标签</p><p>NameSpace：命名空间，用来隔离pod的运行环境</p><ol start="2"><li>kubernetes集群环境搭建</li></ol><p>2.1 前置知识点</p><p>目前生产部署Kubernetes 集群主要有两种方式：</p><p>kubeadm</p><p>Kubeadm 是一个K8s 部署工具，提供kubeadm init 和kubeadm join，用于快速部署Kubernetes 集群。</p><p>官方地址：<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></p><p>二进制包</p><p>从github 下载发行版的二进制包，手动部署每个组件，组成Kubernetes 集群。</p><p>Kubeadm 降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes 集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。</p><p><a href="https://img-blog.csdnimg.cn/c9362adea9694089ac2948dd5d59aad7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/c9362adea9694089ac2948dd5d59aad7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>2.2 kubeadm 部署方式介绍</p><p>kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：</p><ul><li>创建一个Master 节点kubeadm init</li><li>将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;</li></ul><p>2.3 安装要求</p><p>在开始之前，部署Kubernetes 集群机器需要满足以下几个条件：</p><ul><li>一台或多台机器，操作系统CentOS7.x-86_x64</li><li>硬件配置：2GB 或更多RAM，2 个CPU 或更多CPU，硬盘30GB 或更多</li><li>集群中所有机器之间网络互通</li><li>可以访问外网，需要拉取镜像</li><li>禁止swap 分区</li></ul><p>2.4 最终目标</p><ul><li>在所有节点上安装Docker 和kubeadm</li><li>部署Kubernetes Master</li><li>部署容器网络插件</li><li>部署Kubernetes Node，将节点加入Kubernetes 集群中</li><li>部署Dashboard Web 页面，可视化查看Kubernetes 资源</li></ul><p>2.5 准备环境</p><p><a href="https://img-blog.csdnimg.cn/ddf07e2083f24b03857959a06173f7d4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/ddf07e2083f24b03857959a06173f7d4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>  角色              IP地址           组件<br>  k8s-master01    192.168.5.3    docker，kubectl，kubeadm，kubelet<br>  k8s-node01      192.168.5.4    docker，kubectl，kubeadm，kubelet<br>  k8s-node02      192.168.5.5    docker，kubectl，kubeadm，kubelet</p><p>2.6 系统初始化</p><p>2.6.1 设置系统主机名以及 Host 文件的相互解析</p><pre><code>hostnamectl set-hostname k8s-master01 &amp;&amp; bashhostnamectl set-hostname k8s-node01 &amp;&amp; bashhostnamectl set-hostname k8s-node02 &amp;&amp; bashcat &lt;&lt;EOF&gt;&gt; /etc/hosts192.168.5.3     k8s-master01192.168.5.4     k8s-node01192.168.5.5     k8s-node02EOFscp /etc/hosts root@192.168.5.4:/etc/hosts scp /etc/hosts root@192.168.5.5:/etc/hosts </code></pre><p>2.6.2 安装依赖文件（所有节点都要操作）</p><pre><code>yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget vim net-tools git</code></pre><p>2.6.3 设置防火墙为 Iptables 并设置空规则（所有节点都要操作）</p><pre><code>systemctl stop firewalld &amp;&amp; systemctl disable firewalldyum -y install iptables-services &amp;&amp; systemctl start iptables &amp;&amp; systemctl enable iptables &amp;&amp; iptables -F &amp;&amp; service iptables save</code></pre><p>2.6.4 关闭 SELINUX（所有节点都要操作）</p><pre><code>swapoff -a &amp;&amp; sed -i &apos;/ swap / s/^\(.*\)$/#\1/g&apos; /etc/fstabsetenforce 0 &amp;&amp; sed -i &apos;s/^SELINUX=.*/SELINUX=disabled/&apos; /etc/selinux/config</code></pre><p>2.6.5 调整内核参数，对于 K8S（所有节点都要操作）</p><pre><code>modprobe br_netfiltercat &lt;&lt;EOF&gt; kubernetes.conf net.bridge.bridge-nf-call-iptables=1net.bridge.bridge-nf-call-ip6tables=1net.ipv4.ip_forward=1net.ipv4.tcp_tw_recycle=0vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它vm.overcommit_memory=1 # 不检查物理内存是否够用vm.panic_on_oom=0 # 开启 OOMfs.inotify.max_user_instances=8192fs.inotify.max_user_watches=1048576fs.file-max=52706963fs.nr_open=52706963net.ipv6.conf.all.disable_ipv6=1net.netfilter.nf_conntrack_max=2310720EOFcp kubernetes.conf /etc/sysctl.d/kubernetes.confsysctl -p /etc/sysctl.d/kubernetes.conf</code></pre><p>2.6.6 调整系统时区（所有节点都要操作）</p><pre><code># 设置系统时区为 中国/上海timedatectl set-timezone Asia/Shanghai# 将当前的 UTC 时间写入硬件时钟timedatectl set-local-rtc 0# 重启依赖于系统时间的服务systemctl restart rsyslogsystemctl restart crond</code></pre><p>2.6.7 设置 rsyslogd 和 systemd journald（所有节点都要操作）</p><pre><code># 持久化保存日志的目录mkdir /var/log/journal mkdir /etc/systemd/journald.conf.dcat &gt; /etc/systemd/journald.conf.d/99-prophet.conf &lt;&lt;EOF[Journal]# 持久化保存到磁盘Storage=persistent# 压缩历史日志Compress=yesSyncIntervalSec=5mRateLimitInterval=30sRateLimitBurst=1000# 最大占用空间 10GSystemMaxUse=10G# 单日志文件最大 200MSystemMaxFileSize=200M# 日志保存时间 2 周MaxRetentionSec=2week# 不将日志转发到 syslogForwardToSyslog=noEOFsystemctl restart systemd-journald</code></pre><p>2.6.8 kube-proxy开启ipvs的前置条件（所有节点都要操作）</p><pre><code>cat &lt;&lt;EOF&gt; /etc/sysconfig/modules/ipvs.modules #!/bin/bashmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOFchmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4</code></pre><p>2.6.9 安装 Docker 软件（所有节点都要操作）</p><pre><code>yum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum install -y docker-ce## 创建 /etc/docker 目录mkdir /etc/dockercat &gt; /etc/docker/daemon.json &lt;&lt;EOF{&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],&quot;log-driver&quot;: &quot;json-file&quot;,&quot;log-opts&quot;: {&quot;max-size&quot;: &quot;100m&quot;}}EOFmkdir -p /etc/systemd/system/docker.service.d# 重启docker服务systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl enable docker</code></pre><p>上传文件到/etc/yum.repos.d/目录下，也可以 代替 yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a> 命令</p><p>docker-ce.repo</p><pre><code>[docker-ce-stable]name=Docker CE Stable - $basearchbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/$basearch/stableenabled=1gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg[docker-ce-stable-debuginfo]name=Docker CE Stable - Debuginfo $basearchbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/debug-$basearch/stableenabled=0gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg[docker-ce-stable-source]name=Docker CE Stable - Sourcesbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/source/stableenabled=0gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg[docker-ce-test]name=Docker CE Test - $basearchbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/$basearch/testenabled=0gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg[docker-ce-test-debuginfo]name=Docker CE Test - Debuginfo $basearchbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/debug-$basearch/testenabled=0gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg[docker-ce-test-source]name=Docker CE Test - Sourcesbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/source/testenabled=0gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg[docker-ce-nightly]name=Docker CE Nightly - $basearchbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/$basearch/nightlyenabled=0gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg[docker-ce-nightly-debuginfo]name=Docker CE Nightly - Debuginfo $basearchbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/debug-$basearch/nightlyenabled=0gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg[docker-ce-nightly-source]name=Docker CE Nightly - Sourcesbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/$releasever/source/nightlyenabled=0gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</code></pre><p>2.6.10 安装 Kubeadm （所有节点都要操作）</p><pre><code>cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpghttp://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOFyum install -y kubelet kubeadm kubectl &amp;&amp; systemctl enable kubelet</code></pre><p>2.7 部署Kubernetes Master</p><p>2.7.1 初始化主节点（主节点操作）</p><pre><code>kubeadm init --apiserver-advertise-address=192.168.5.3 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.21.1 --service-cidr=10.96.0.0/12 --pod-network-cidr=10.244.0.0/16mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config</code></pre><p>2.7.2 加入主节点以及其余工作节点</p><pre><code>kubeadm join 192.168.5.3:6443 --token h0uelc.l46qp29nxscke7f7 \        --discovery-token-ca-cert-hash sha256:abc807778e24bff73362ceeb783cc7f6feec96f20b4fd707c3f8e8312294e28f </code></pre><p>2.7.3 部署网络</p><pre><code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre><p>下边是文件</p><pre><code>---apiVersion: policy/v1beta1kind: PodSecurityPolicymetadata:  name: psp.flannel.unprivileged  annotations:    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/defaultspec:  privileged: false  volumes:  - configMap  - secret  - emptyDir  - hostPath  allowedHostPaths:  - pathPrefix: &quot;/etc/cni/net.d&quot;  - pathPrefix: &quot;/etc/kube-flannel&quot;  - pathPrefix: &quot;/run/flannel&quot;  readOnlyRootFilesystem: false  # Users and groups  runAsUser:    rule: RunAsAny  supplementalGroups:    rule: RunAsAny  fsGroup:    rule: RunAsAny  # Privilege Escalation  allowPrivilegeEscalation: false  defaultAllowPrivilegeEscalation: false  # Capabilities  allowedCapabilities: [&apos;NET_ADMIN&apos;, &apos;NET_RAW&apos;]  defaultAddCapabilities: []  requiredDropCapabilities: []  # Host namespaces  hostPID: false  hostIPC: false  hostNetwork: true  hostPorts:  - min: 0    max: 65535  # SELinux  seLinux:    # SELinux is unused in CaaSP    rule: &apos;RunAsAny&apos;---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata:  name: flannelrules:- apiGroups: [&apos;extensions&apos;]  resources: [&apos;podsecuritypolicies&apos;]  verbs: [&apos;use&apos;]  resourceNames: [&apos;psp.flannel.unprivileged&apos;]- apiGroups:  - &quot;&quot;  resources:  - pods  verbs:  - get- apiGroups:  - &quot;&quot;  resources:  - nodes  verbs:  - list  - watch- apiGroups:  - &quot;&quot;  resources:  - nodes/status  verbs:  - patch---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata:  name: flannelroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: flannelsubjects:- kind: ServiceAccount  name: flannel  namespace: kube-system---apiVersion: v1kind: ServiceAccountmetadata:  name: flannel  namespace: kube-system---kind: ConfigMapapiVersion: v1metadata:  name: kube-flannel-cfg  namespace: kube-system  labels:    tier: node    app: flanneldata:  cni-conf.json: |    {      &quot;name&quot;: &quot;cbr0&quot;,      &quot;cniVersion&quot;: &quot;0.3.1&quot;,      &quot;plugins&quot;: [        {          &quot;type&quot;: &quot;flannel&quot;,          &quot;delegate&quot;: {            &quot;hairpinMode&quot;: true,            &quot;isDefaultGateway&quot;: true          }        },        {          &quot;type&quot;: &quot;portmap&quot;,          &quot;capabilities&quot;: {            &quot;portMappings&quot;: true          }        }      ]    }  net-conf.json: |    {      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,      &quot;Backend&quot;: {        &quot;Type&quot;: &quot;vxlan&quot;      }    }---apiVersion: apps/v1kind: DaemonSetmetadata:  name: kube-flannel-ds  namespace: kube-system  labels:    tier: node    app: flannelspec:  selector:    matchLabels:      app: flannel  template:    metadata:      labels:        tier: node        app: flannel    spec:      affinity:        nodeAffinity:          requiredDuringSchedulingIgnoredDuringExecution:            nodeSelectorTerms:            - matchExpressions:              - key: kubernetes.io/os                operator: In                values:                - linux      hostNetwork: true      priorityClassName: system-node-critical      tolerations:      - operator: Exists        effect: NoSchedule      serviceAccountName: flannel      initContainers:      - name: install-cni        image: quay.io/coreos/flannel:v0.14.0        command:        - cp        args:        - -f        - /etc/kube-flannel/cni-conf.json        - /etc/cni/net.d/10-flannel.conflist        volumeMounts:        - name: cni          mountPath: /etc/cni/net.d        - name: flannel-cfg          mountPath: /etc/kube-flannel/      containers:      - name: kube-flannel        image: quay.io/coreos/flannel:v0.14.0        command:        - /opt/bin/flanneld        args:        - --ip-masq        - --kube-subnet-mgr        resources:          requests:            cpu: &quot;100m&quot;            memory: &quot;50Mi&quot;          limits:            cpu: &quot;100m&quot;            memory: &quot;50Mi&quot;        securityContext:          privileged: false          capabilities:            add: [&quot;NET_ADMIN&quot;, &quot;NET_RAW&quot;]        env:        - name: POD_NAME          valueFrom:            fieldRef:              fieldPath: metadata.name        - name: POD_NAMESPACE          valueFrom:            fieldRef:              fieldPath: metadata.namespace        volumeMounts:        - name: run          mountPath: /run/flannel        - name: flannel-cfg          mountPath: /etc/kube-flannel/      volumes:      - name: run        hostPath:          path: /run/flannel      - name: cni        hostPath:          path: /etc/cni/net.d      - name: flannel-cfg        configMap:          name: kube-flannel-cfg</code></pre><p>2.8 测试kubernetes 集群</p><p>2.8.1 部署nginx 测试</p><pre><code>kubectl create deployment nginx --image=nginxkubectl expose deployment nginx --port=80 --type=NodePortkubectl get pod,svc</code></pre><ol start="3"><li>资源管理</li></ol><p>3.1 资源管理介绍</p><p>在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes。</p><p>kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。</p><p>kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在Pod中，而kubernetes一般也不会直接管理Pod，而是通过Pod控制器来管理Pod的。</p><p>Pod可以提供服务之后，就要考虑如何访问Pod中服务，kubernetes提供了Service资源实现这个功能。</p><p>当然，如果Pod中程序的数据需要持久化，kubernetes还提供了各种存储系统。</p><p><a href="https://img-blog.csdnimg.cn/d9ee7d0ebcf240acac442909afd81aae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/d9ee7d0ebcf240acac442909afd81aae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>学习kubernetes的核心，就是学习如何对集群上的Pod、Pod控制器、Service、存储等各种资源进行操作</p><p>3.2 YAML语言介绍</p><p>YAML是一个类似 XML、JSON 的标记性语言。它强调以数据为中心，并不是以标识语言为重点。因而YAML本身的定义比较简单，号称”一种人性化的数据格式语言”。</p><pre><code>&lt;heima&gt;    &lt;age&gt;15&lt;/age&gt;    &lt;address&gt;Beijing&lt;/address&gt;&lt;/heima&gt;heima:  age: 15  address: Beijing</code></pre><p>YAML的语法比较简单，主要有下面几个：</p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用tab，只允许空格( 低版本限制 )</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>‘#’表示注释</li></ul><p>YAML支持以下几种数据类型：</p><ul><li><p>纯量：单个的、不可再分的值</p></li><li><p>对象：键值对的集合，又称为映射（mapping）/ 哈希（hash） / 字典（dictionary）</p></li><li><p>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</p><h1 id="纯量-就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期"><a href="#纯量-就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期" class="headerlink" title="纯量, 就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期"></a>纯量, 就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期</h1><h1 id="1-布尔类型"><a href="#1-布尔类型" class="headerlink" title="1 布尔类型"></a>1 布尔类型</h1><p>  c1: true (或者True)</p><h1 id="2-整型"><a href="#2-整型" class="headerlink" title="2 整型"></a>2 整型</h1><p>  c2: 234</p><h1 id="3-浮点型"><a href="#3-浮点型" class="headerlink" title="3 浮点型"></a>3 浮点型</h1><p>  c3: 3.14</p><h1 id="4-null类型"><a href="#4-null类型" class="headerlink" title="4 null类型"></a>4 null类型</h1><p>  c4: ~  # 使用~表示null</p><h1 id="5-日期类型"><a href="#5-日期类型" class="headerlink" title="5 日期类型"></a>5 日期类型</h1><p>  c5: 2018-02-17    # 日期必须使用ISO 8601格式，即yyyy-MM-dd</p><h1 id="6-时间类型"><a href="#6-时间类型" class="headerlink" title="6 时间类型"></a>6 时间类型</h1><p>  c6: 2018-02-17T15:02:31+08:00  # 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</p><h1 id="7-字符串类型"><a href="#7-字符串类型" class="headerlink" title="7 字符串类型"></a>7 字符串类型</h1><p>  c7: heima     # 简单写法，直接写值 , 如果字符串中间有特殊字符，必须使用双引号或者单引号包裹<br>  c8: line1</p><pre><code>line2     # 字符串过多的情况可以拆成多行，每一行会被转化成一个空格</code></pre><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h1 id="形式一-推荐"><a href="#形式一-推荐" class="headerlink" title="形式一(推荐):"></a>形式一(推荐):</h1><p>  heima:</p><pre><code>age: 15address: Beijing</code></pre><h1 id="形式二-了解"><a href="#形式二-了解" class="headerlink" title="形式二(了解):"></a>形式二(了解):</h1><p>  heima: {age: 15,address: Beijing}</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h1 id="形式一-推荐-1"><a href="#形式一-推荐-1" class="headerlink" title="形式一(推荐):"></a>形式一(推荐):</h1><p>  address:</p><pre><code>- 顺义- 昌平  </code></pre><h1 id="形式二-了解-1"><a href="#形式二-了解-1" class="headerlink" title="形式二(了解):"></a>形式二(了解):</h1><p>  address: [顺义,昌平]</p></li></ul><p>小提示：</p><p>1 书写yaml切记: 后面要加一个空格</p><p>2 如果需要将多段yaml配置放在一个文件中，中间要使用—分隔</p><p>3 下面是一个yaml转json的网站，可以通过它验证yaml是否书写正确</p><p><a href="https://www.json2yaml.com/convert-yaml-to-json" target="_blank" rel="noopener">https://www.json2yaml.com/convert-yaml-to-json</a></p><p>3.3 资源管理方式</p><ul><li><p>命令式对象管理：直接使用命令去操作kubernetes资源<br>kubectl run nginx-pod –image=nginx:1.17.1 –port=80</p></li><li><p>命令式对象配置：通过命令配置和配置文件去操作kubernetes资源<br>kubectl create/patch -f nginx-pod.yaml</p></li><li><p>声明式对象配置：通过apply命令和配置文件去操作kubernetes资源<br>kubectl apply -f nginx-pod.yaml</p><p>类型         操作对象    适用环境    优点         缺点<br>命令式对象管理    对象      测试      简单         只能操作活动对象，无法审计、跟踪<br>命令式对象配置    文件      开发      可以审计、跟踪    项目大时，配置文件多，操作麻烦<br>声明式对象配置    目录      开发      支持目录操作     意外情况下难以调试       </p></li></ul><p>3.3.1 命令式对象管理</p><p>kubectl命令</p><p>kubectl是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。kubectl命令的语法如下：</p><pre><code>kubectl [command] [type] [name] [flags]</code></pre><p>comand：指定要对资源执行的操作，例如create、get、delete</p><p>type：指定资源类型，比如deployment、pod、service</p><p>name：指定资源的名称，名称大小写敏感</p><p>flags：指定额外的可选参数</p><pre><code># 查看所有podkubectl get pod # 查看某个podkubectl get pod pod_name# 查看某个pod,以yaml格式展示结果kubectl get pod pod_name -o yaml</code></pre><p>资源类型</p><p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看:</p><pre><code>kubectl api-resources</code></pre><p>经常使用的资源有下面这些：</p><p>  资源分类          资源名称                        缩写        资源作用<br>  集群级别资源        nodes                       no        集群组成部分<br>  namespaces    ns                          隔离Pod<br>  pod资源         pods                        po        装载容器<br>  pod资源控制器      replicationcontrollers      rc        控制pod资源<br>                replicasets                 rs        控制pod资源<br>                deployments                 deploy    控制pod资源<br>                daemonsets                  ds        控制pod资源<br>                jobs                                  控制pod资源<br>                cronjobs                    cj        控制pod资源<br>                horizontalpodautoscalers    hpa       控制pod资源<br>                statefulsets                sts       控制pod资源<br>  服务发现资源        services                    svc       统一pod对外接口<br>                ingress                     ing       统一pod对外接口<br>  存储资源          volumeattachments                     存储<br>                persistentvolumes           pv        存储<br>                persistentvolumeclaims      pvc       存储<br>  配置资源          configmaps                  cm        配置<br>                secrets                               配置       </p><p>操作</p><p>kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令</p><pre><code>kubectl --help</code></pre><p>经常使用的操作有下面这些：</p><p>  命令分类     命令              翻译                  命令作用<br>  基本命令     create          创建                  创建一个资源<br>           edit            编辑                  编辑一个资源<br>           get             获取                  获取一个资源<br>           patch           更新                  更新一个资源<br>           delete          删除                  删除一个资源<br>           explain         解释                  展示资源文档<br>  运行和调试    run             运行                  在集群中运行一个指定的镜像<br>           expose          暴露                  暴露资源为Service<br>           describe        描述                  显示资源内部信息<br>           logs            日志输出容器在 pod 中的日志    输出容器在 pod 中的日志<br>           attach          缠绕进入运行中的容器          进入运行中的容器<br>           exec            执行容器中的一个命令          执行容器中的一个命令<br>           cp              复制                  在Pod内外复制文件<br>           rollout         首次展示                管理资源的发布<br>           scale           规模                  扩(缩)容Pod的数量<br>           autoscale       自动调整                自动调整Pod的数量<br>  高级命令     apply           rc                  通过文件对资源进行配置<br>           label           标签                  更新资源上的标签<br>  其他命令     cluster-info    集群信息                显示集群信息<br>           version         版本                  显示当前Server和Client的版本</p><p>下面以一个namespace / pod的创建和删除简单演示下命令的使用：</p><pre><code># 创建一个namespace[root@master ~]# kubectl create namespace devnamespace/dev created# 获取namespace[root@master ~]# kubectl get nsNAME              STATUS   AGEdefault           Active   21hdev               Active   21skube-node-lease   Active   21hkube-public       Active   21hkube-system       Active   21h# 在此namespace下创建并运行一个nginx的Pod[root@master ~]# kubectl run pod --image=nginx:latest -n devkubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.deployment.apps/pod created# 查看新创建的pod[root@master ~]# kubectl get pod -n devNAME  READY   STATUS    RESTARTS   AGEpod   1/1     Running   0          21s# 删除指定的pod[root@master ~]# kubectl delete pod pod-864f9875b9-pcw7xpod &quot;pod&quot; deleted# 删除指定的namespace[root@master ~]# kubectl delete ns devnamespace &quot;dev&quot; deleted</code></pre><p>3.3.2 命令式对象配置</p><p>命令式对象配置就是使用命令配合配置文件一起来操作kubernetes资源。</p><p>1） 创建一个nginxpod.yaml，内容如下：</p><pre><code>apiVersion: v1kind: Namespacemetadata:  name: dev---apiVersion: v1kind: Podmetadata:  name: nginxpod  namespace: devspec:  containers:  - name: nginx-containers    image: nginx:latest</code></pre><p>2）执行create命令，创建资源：</p><pre><code>[root@master ~]# kubectl create -f nginxpod.yamlnamespace/dev createdpod/nginxpod created</code></pre><p>此时发现创建了两个资源对象，分别是namespace和pod</p><p>3）执行get命令，查看资源：</p><pre><code>[root@master ~]#  kubectl get -f nginxpod.yamlNAME            STATUS   AGEnamespace/dev   Active   18sNAME            READY   STATUS    RESTARTS   AGEpod/nginxpod    1/1     Running   0          17s</code></pre><p>这样就显示了两个资源对象的信息</p><p>4）执行delete命令，删除资源：</p><pre><code>[root@master ~]# kubectl delete -f nginxpod.yamlnamespace &quot;dev&quot; deletedpod &quot;nginxpod&quot; deleted</code></pre><p>此时发现两个资源对象被删除了</p><pre><code>总结:    命令式对象配置的方式操作资源，可以简单的认为：命令  +  yaml配置文件（里面是命令需要的各种参数）</code></pre><p>3.3.3 声明式对象配置</p><p>声明式对象配置跟命令式对象配置很相似，但是它只有一个命令apply。</p><pre><code># 首先执行一次kubectl apply -f yaml文件，发现创建了资源[root@master ~]#  kubectl apply -f nginxpod.yamlnamespace/dev createdpod/nginxpod created# 再次执行一次kubectl apply -f yaml文件，发现说资源没有变动[root@master ~]#  kubectl apply -f nginxpod.yamlnamespace/dev unchangedpod/nginxpod unchanged总结:    其实声明式对象配置就是使用apply描述一个资源最终的状态（在yaml中定义状态）    使用apply操作资源：        如果资源不存在，就创建，相当于 kubectl create        如果资源已存在，就更新，相当于 kubectl patch</code></pre><p>扩展：kubectl可以在node节点上运行吗 ?</p><p>kubectl的运行是需要进行配置的，它的配置文件是$HOME/.kube，如果想要在node节点运行此命令，需要将master上的.kube文件复制到node节点上，即在master节点上执行下面操作：</p><pre><code>scp  -r  HOME/.kube   node1: HOME/</code></pre><p>使用推荐: 三种方式应该怎么用 ?</p><p>创建/更新资源 使用声明式对象配置 kubectl apply -f XXX.yaml</p><p>删除资源 使用命令式对象配置 kubectl delete -f XXX.yaml</p><p>查询资源 使用命令式对象管理 kubectl get(describe) 资源名称</p><ol start="4"><li>实战入门</li></ol><p>本章节将介绍如何在kubernetes集群中部署一个nginx服务，并且能够对其进行访问。</p><p>4.1 Namespace</p><p>Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现多套环境的资源隔离或者多租户的资源隔离。</p><p>默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的”组”，以方便不同的组的资源进行隔离使用和管理。</p><p>可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。<br><a href="https://img-blog.csdnimg.cn/8e5bce5aa38046d9bb26cda52a40bd29.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/8e5bce5aa38046d9bb26cda52a40bd29.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>kubernetes在集群启动之后，会默认创建几个namespace</p><pre><code>[root@master ~]# kubectl  get namespaceNAME              STATUS   AGEdefault           Active   45h     #  所有未指定Namespace的对象都会被分配在default命名空间kube-node-lease   Active   45h     #  集群节点之间的心跳维护，v1.13开始引入kube-public       Active   45h     #  此命名空间下的资源可以被所有人访问（包括未认证用户）kube-system       Active   45h     #  所有由Kubernetes系统创建的资源都处于这个命名空间</code></pre><p>下面来看namespace资源的具体操作：</p><p>查看</p><pre><code># 1 查看所有的ns  命令：kubectl get ns[root@master ~]# kubectl get nsNAME              STATUS   AGEdefault           Active   45hkube-node-lease   Active   45hkube-public       Active   45h     kube-system       Active   45h     # 2 查看指定的ns   命令：kubectl get ns ns名称[root@master ~]# kubectl get ns defaultNAME      STATUS   AGEdefault   Active   45h# 3 指定输出格式  命令：kubectl get ns ns名称  -o 格式参数# kubernetes支持的格式有很多，比较常见的是wide、json、yaml[root@master ~]# kubectl get ns default -o yamlapiVersion: v1kind: Namespacemetadata:  creationTimestamp: &quot;2021-05-08T04:44:16Z&quot;  name: default  resourceVersion: &quot;151&quot;  selfLink: /api/v1/namespaces/default  uid: 7405f73a-e486-43d4-9db6-145f1409f090spec:  finalizers:  - kubernetesstatus:  phase: Active# 4 查看ns详情  命令：kubectl describe ns ns名称[root@master ~]# kubectl describe ns defaultName:         defaultLabels:       &lt;none&gt;Annotations:  &lt;none&gt;Status:       Active  # Active 命名空间正在使用中  Terminating 正在删除命名空间# ResourceQuota 针对namespace做的资源限制# LimitRange针对namespace中的每个组件做的资源限制No resource quota.No LimitRange resource.</code></pre><p>创建</p><pre><code># 创建namespace[root@master ~]# kubectl create ns devnamespace/dev created</code></pre><p>删除</p><pre><code># 删除namespace[root@master ~]# kubectl delete ns devnamespace &quot;dev&quot; deleted</code></pre><p>配置方式</p><p>首先准备一个yaml文件：ns-dev.yaml</p><pre><code>apiVersion: v1kind: Namespacemetadata:  name: dev</code></pre><p>然后就可以执行对应的创建和删除命令了：</p><p>创建：kubectl create -f ns-dev.yaml</p><p>删除：kubectl delete -f ns-dev.yaml</p><p>4.2 Pod</p><p>Pod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。</p><p>Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。<br><a href="https://img-blog.csdnimg.cn/4c6a7f8447a94b94b492c3537fe9b6b4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/4c6a7f8447a94b94b492c3537fe9b6b4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>kubernetes在集群启动之后，集群中的各个组件也都是以Pod方式运行的。可以通过下面命令查看：</p><pre><code>[root@master ~]# kubectl get pod -n kube-systemNAMESPACE     NAME                             READY   STATUS    RESTARTS   AGEkube-system   coredns-6955765f44-68g6v         1/1     Running   0          2d1hkube-system   coredns-6955765f44-cs5r8         1/1     Running   0          2d1hkube-system   etcd-master                      1/1     Running   0          2d1hkube-system   kube-apiserver-master            1/1     Running   0          2d1hkube-system   kube-controller-manager-master   1/1     Running   0          2d1hkube-system   kube-flannel-ds-amd64-47r25      1/1     Running   0          2d1hkube-system   kube-flannel-ds-amd64-ls5lh      1/1     Running   0          2d1hkube-system   kube-proxy-685tk                 1/1     Running   0          2d1hkube-system   kube-proxy-87spt                 1/1     Running   0          2d1hkube-system   kube-scheduler-master            1/1     Running   0          2d1h</code></pre><p>创建并运行</p><p>kubernetes没有提供单独运行Pod的命令，都是通过Pod控制器来实现的</p><pre><code># 命令格式： kubectl run (pod控制器名称) [参数] # --image  指定Pod的镜像# --port   指定端口# --namespace  指定namespace[root@master ~]# kubectl run nginx --image=nginx:latest --port=80 --namespace dev deployment.apps/nginx created</code></pre><p>查看pod信息</p><pre><code># 查看Pod基本信息[root@master ~]# kubectl get pods -n devNAME    READY   STATUS    RESTARTS   AGEnginx   1/1     Running   0          43s# 查看Pod的详细信息[root@master ~]# kubectl describe pod nginx -n devName:         nginxNamespace:    devPriority:     0Node:         node1/192.168.5.4Start Time:   Wed, 08 May 2021 09:29:24 +0800Labels:       pod-template-hash=5ff7956ff6              run=nginxAnnotations:  &lt;none&gt;Status:       RunningIP:           10.244.1.23IPs:  IP:           10.244.1.23Controlled By:  ReplicaSet/nginxContainers:  nginx:    Container ID:   docker://4c62b8c0648d2512380f4ffa5da2c99d16e05634979973449c98e9b829f6253c    Image:          nginx:latest    Image ID:       docker-pullable://nginx@sha256:485b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7    Port:           80/TCP    Host Port:      0/TCP    State:          Running      Started:      Wed, 08 May 2021 09:30:01 +0800    Ready:          True    Restart Count:  0    Environment:    &lt;none&gt;    Mounts:      /var/run/secrets/kubernetes.io/serviceaccount from default-token-hwvvw (ro)Conditions:  Type              Status  Initialized       True  Ready             True  ContainersReady   True  PodScheduled      TrueVolumes:  default-token-hwvvw:    Type:        Secret (a volume populated by a Secret)    SecretName:  default-token-hwvvw    Optional:    falseQoS Class:       BestEffortNode-Selectors:  &lt;none&gt;Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s                 node.kubernetes.io/unreachable:NoExecute for 300sEvents:  Type    Reason     Age        From               Message  ----    ------     ----       ----               -------  Normal  Scheduled  &lt;unknown&gt;  default-scheduler  Successfully assigned dev/nginx-5ff7956ff6-fg2db to node1  Normal  Pulling    4m11s      kubelet, node1     Pulling image &quot;nginx:latest&quot;  Normal  Pulled     3m36s      kubelet, node1     Successfully pulled image &quot;nginx:latest&quot;  Normal  Created    3m36s      kubelet, node1     Created container nginx  Normal  Started    3m36s      kubelet, node1     Started container nginx</code></pre><p>访问Pod</p><pre><code># 获取podIP[root@master ~]# kubectl get pods -n dev -o wideNAME    READY   STATUS    RESTARTS   AGE    IP             NODE    ... nginx   1/1     Running   0          190s   10.244.1.23   node1   ...#访问POD[root@master ~]# curl http://10.244.1.23:80&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>删除指定Pod</p><pre><code># 删除指定Pod[root@master ~]# kubectl delete pod nginx -n devpod &quot;nginx&quot; deleted# 此时，显示删除Pod成功，但是再查询，发现又新产生了一个 [root@master ~]# kubectl get pods -n devNAME    READY   STATUS    RESTARTS   AGEnginx   1/1     Running   0          21s# 这是因为当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发现Pod死亡，会立即重建# 此时要想删除Pod，必须删除Pod控制器# 先来查询一下当前namespace下的Pod控制器[root@master ~]# kubectl get deploy -n  devNAME    READY   UP-TO-DATE   AVAILABLE   AGEnginx   1/1     1            1           9m7s# 接下来，删除此PodPod控制器[root@master ~]# kubectl delete deploy nginx -n devdeployment.apps &quot;nginx&quot; deleted# 稍等片刻，再查询Pod，发现Pod被删除了[root@master ~]# kubectl get pods -n devNo resources found in dev namespace.</code></pre><p>配置操作</p><p>创建一个pod-nginx.yaml，内容如下：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: nginx  namespace: devspec:  containers:  - image: nginx:latest    name: pod    ports:    - name: nginx-port      containerPort: 80      protocol: TCP</code></pre><p>然后就可以执行对应的创建和删除命令了：</p><p>创建：kubectl create -f pod-nginx.yaml</p><p>删除：kubectl delete -f pod-nginx.yaml</p><p>4.3 Label</p><p>Label是kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。</p><p>Label的特点：</p><ul><li>一个Label会以key/value键值对的形式附加到各种对象上，如Node、Pod、Service等等</li><li>一个资源对象可以定义任意数量的Label ，同一个Label也可以被添加到任意数量的资源对象上去</li><li>Label通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除</li></ul><p>可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。</p><p>一些常用的Label 示例如下：</p><ul><li>版本标签：”version”:”release”, “version”:”stable”……</li><li>环境标签：”environment”:”dev”，”environment”:”test”，”environment”:”pro”</li><li>架构标签：”tier”:”frontend”，”tier”:”backend”</li></ul><p>标签定义完毕之后，还要考虑到标签的选择，这就要使用到Label Selector，即：</p><p>Label用于给某个资源对象定义标识</p><p>Label Selector用于查询和筛选拥有某些标签的资源对象</p><p>当前有两种Label Selector：</p><ul><li>基于等式的Label Selector<br>name = slave: 选择所有包含Label中key=”name”且value=”slave”的对象<br>env != production: 选择所有包括Label中的key=”env”且value不等于”production”的对象</li><li>基于集合的Label Selector<br>name in (master, slave): 选择所有包含Label中的key=”name”且value=”master”或”slave”的对象<br>name not in (frontend): 选择所有包含Label中的key=”name”且value不等于”frontend”的对象</li></ul><p>标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号”,”进行分隔即可。例如：</p><p>name=slave，env!=production</p><p>name not in (frontend)，env!=production</p><p>命令方式</p><pre><code># 为pod资源打标签[root@master ~]# kubectl label pod nginx-pod version=1.0 -n devpod/nginx-pod labeled# 为pod资源更新标签[root@master ~]# kubectl label pod nginx-pod version=2.0 -n dev --overwritepod/nginx-pod labeled# 查看标签[root@master ~]# kubectl get pod nginx-pod  -n dev --show-labelsNAME        READY   STATUS    RESTARTS   AGE   LABELSnginx-pod   1/1     Running   0          10m   version=2.0# 筛选标签[root@master ~]# kubectl get pod -n dev -l version=2.0  --show-labelsNAME        READY   STATUS    RESTARTS   AGE   LABELSnginx-pod   1/1     Running   0          17m   version=2.0[root@master ~]# kubectl get pod -n dev -l version!=2.0 --show-labelsNo resources found in dev namespace.#删除标签[root@master ~]# kubectl label pod nginx-pod version- -n devpod/nginx-pod labeled</code></pre><p>配置方式</p><pre><code>apiVersion: v1kind: Podmetadata:  name: nginx  namespace: dev  labels:    version: &quot;3.0&quot;     env: &quot;test&quot;spec:  containers:  - image: nginx:latest    name: pod    ports:    - name: nginx-port      containerPort: 80      protocol: TCP</code></pre><p>然后就可以执行对应的更新命令了：kubectl apply -f pod-nginx.yaml</p><p>4.4 Deployment</p><p>在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建pod。</p><p>在kubernetes中Pod控制器的种类有很多，本章节只介绍一种：Deployment。</p><p><a href="https://img-blog.csdnimg.cn/40e9297a34134aec9e451e3efe192e11.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/40e9297a34134aec9e451e3efe192e11.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>命令操作</p><pre><code># 命令格式: kubectl create deployment 名称  [参数] # --image  指定pod的镜像# --port   指定端口# --replicas  指定创建pod数量# --namespace  指定namespace[root@master ~]# kubectl create deploy nginx --image=nginx:latest --port=80 --replicas=3 -n devdeployment.apps/nginx created# 查看创建的Pod[root@master ~]# kubectl get pods -n devNAME                     READY   STATUS    RESTARTS   AGEnginx-5ff7956ff6-6k8cb   1/1     Running   0          19snginx-5ff7956ff6-jxfjt   1/1     Running   0          19snginx-5ff7956ff6-v6jqw   1/1     Running   0          19s# 查看deployment的信息[root@master ~]# kubectl get deploy -n devNAME    READY   UP-TO-DATE   AVAILABLE   AGEnginx   3/3     3            3           2m42s# UP-TO-DATE：成功升级的副本数量# AVAILABLE：可用副本的数量[root@master ~]# kubectl get deploy -n dev -o wideNAME    READY UP-TO-DATE  AVAILABLE   AGE     CONTAINERS   IMAGES              SELECTORnginx   3/3     3         3           2m51s   nginx        nginx:latest        run=nginx# 查看deployment的详细信息[root@master ~]# kubectl describe deploy nginx -n devName:                   nginxNamespace:              devCreationTimestamp:      Wed, 08 May 2021 11:14:14 +0800Labels:                 run=nginxAnnotations:            deployment.kubernetes.io/revision: 1Selector:               run=nginxReplicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailableStrategyType:           RollingUpdateMinReadySeconds:        0RollingUpdateStrategy:  25% max unavailable, 25% max surgePod Template:  Labels:  run=nginx  Containers:   nginx:    Image:        nginx:latest    Port:         80/TCP    Host Port:    0/TCP    Environment:  &lt;none&gt;    Mounts:       &lt;none&gt;  Volumes:        &lt;none&gt;Conditions:  Type           Status  Reason  ----           ------  ------  Available      True    MinimumReplicasAvailable  Progressing    True    NewReplicaSetAvailableOldReplicaSets:  &lt;none&gt;NewReplicaSet:   nginx-5ff7956ff6 (3/3 replicas created)Events:  Type    Reason             Age    From                   Message  ----    ------             ----   ----                   -------  Normal  ScalingReplicaSet  5m43s  deployment-controller  Scaled up replicaset nginx-5ff7956ff6 to 3# 删除 [root@master ~]# kubectl delete deploy nginx -n devdeployment.apps &quot;nginx&quot; deleted</code></pre><p>配置操作</p><p>创建一个deploy-nginx.yaml，内容如下：</p><pre><code>apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx  namespace: devspec:  replicas: 3  selector:    matchLabels:      run: nginx  template:    metadata:      labels:        run: nginx    spec:      containers:      - image: nginx:latest        name: nginx        ports:        - containerPort: 80          protocol: TCP</code></pre><p>然后就可以执行对应的创建和删除命令了：</p><p>创建：kubectl create -f deploy-nginx.yaml</p><p>删除：kubectl delete -f deploy-nginx.yaml</p><p>4.5 Service</p><p>通过上节课的学习，已经能够利用Deployment来创建一组Pod来提供具有高可用性的服务。</p><p>虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：</p><ul><li>Pod IP 会随着Pod的重建产生变化</li><li>Pod IP 仅仅是集群内可见的虚拟IP，外部无法访问</li></ul><p>这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。</p><p>Service可以看作是一组同类Pod对外的访问接口。借助Service，应用可以方便地实现服务发现和负载均衡。</p><p><a href="https://img-blog.csdnimg.cn/9534254c0f2941a2a51d7dbc7d47ab48.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/9534254c0f2941a2a51d7dbc7d47ab48.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>操作一：创建集群内部可访问的Service</p><pre><code># 暴露Service[root@master ~]# kubectl expose deploy nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n devservice/svc-nginx1 exposed# 查看service[root@master ~]# kubectl get svc svc-nginx1 -n dev -o wideNAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE     SELECTORsvc-nginx1   ClusterIP   10.109.179.231   &lt;none&gt;        80/TCP    3m51s   run=nginx# 这里产生了一个CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的# 可以通过这个IP访问当前service对应的POD[root@master ~]# curl 10.109.179.231:80&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;.......&lt;/body&gt;&lt;/html&gt;</code></pre><p>操作二：创建集群外部也可访问的Service</p><pre><code># 上面创建的Service的type类型为ClusterIP，这个ip地址只用集群内部可访问# 如果需要创建外部也可以访问的Service，需要修改type为NodePort[root@master ~]# kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n devservice/svc-nginx2 exposed# 此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928/TC）[root@master ~]# kubectl get svc  svc-nginx2  -n dev -o wideNAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE    SELECTORsvc-nginx2    NodePort    10.100.94.0      &lt;none&gt;        80:31928/TCP   9s     run=nginx# 接下来就可以通过集群外的主机访问 节点IP:31928访问服务了# 例如在的电脑主机上通过浏览器访问下面的地址http://192.168.5.4:31928/</code></pre><p>删除Service</p><pre><code>[root@master ~]# kubectl delete svc svc-nginx-1 -n dev service &quot;svc-nginx-1&quot; deleted</code></pre><p>配置方式</p><p>创建一个svc-nginx.yaml，内容如下：</p><pre><code>apiVersion: v1kind: Servicemetadata:  name: svc-nginx  namespace: devspec:  clusterIP: 10.109.179.231 #固定svc的内网ip  ports:  - port: 80    protocol: TCP    targetPort: 80  selector:    run: nginx  type: ClusterIP</code></pre><p>然后就可以执行对应的创建和删除命令了：</p><p>创建：kubectl create -f svc-nginx.yaml</p><p>删除：kubectl delete -f svc-nginx.yaml</p><p>小结</p><p>至此，已经掌握了Namespace、Pod、Deployment、Service资源的基本操作，有了这些操作，就可以在kubernetes集群中实现一个服务的简单部署和访问了，但是如果想要更好的使用kubernetes，就需要深入学习这几种资源的细节和原理。</p><ol start="5"><li>Pod详解</li></ol><p>5.1 Pod介绍</p><p>5.1.1 Pod结构<br><a href="https://img-blog.csdnimg.cn/f27841d6f55d4d53bf55572fef3a1a0d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/f27841d6f55d4d53bf55572fef3a1a0d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>每个Pod中都可以包含一个或者多个容器，这些容器可以分为两类：</p><ul><li>用户程序所在的容器，数量可多可少</li><li>Pause容器，这是每个Pod都会有的一个根容器，它的作用有两个：<ul><li>可以以它为依据，评估整个Pod的健康状态</li><li>可以在根容器上设置Ip地址，其它容器都此Ip（Pod IP），以实现Pod内部的网路通信<pre><code>这里是Pod内部的通讯，Pod的之间的通讯采用虚拟二层网络技术来实现，我们当前环境用的是Flannel</code></pre></li></ul></li></ul><p>5.1.2 Pod定义</p><p>下面是Pod的资源清单：</p><pre><code>apiVersion: v1     #必选，版本号，例如v1kind: Pod       　 #必选，资源类型，例如 Podmetadata:       　 #必选，元数据  name: string     #必选，Pod名称  namespace: string  #Pod所属的命名空间,默认为&quot;default&quot;  labels:       　　  #自定义标签列表    - name: string      　          spec:  #必选，Pod中容器的详细定义  containers:  #必选，Pod中容器列表  - name: string   #必选，容器名称    image: string  #必选，容器的镜像名称    imagePullPolicy: [ Always|Never|IfNotPresent ]  #获取镜像的策略     command: [string]   #容器的启动命令列表，如不指定，使用打包时使用的启动命令    args: [string]      #容器的启动命令参数列表    workingDir: string  #容器的工作目录    volumeMounts:       #挂载到容器内部的存储卷配置    - name: string      #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名      mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符      readOnly: boolean #是否为只读模式    ports: #需要暴露的端口库号列表    - name: string        #端口的名称      containerPort: int  #容器需要监听的端口号      hostPort: int       #容器所在主机需要监听的端口号，默认与Container相同      protocol: string    #端口协议，支持TCP和UDP，默认TCP    env:   #容器运行前需设置的环境变量列表    - name: string  #环境变量名称      value: string #环境变量的值    resources: #资源限制和请求的设置      limits:  #资源限制的设置        cpu: string     #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数        memory: string  #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数      requests: #资源请求的设置        cpu: string    #Cpu请求，容器启动的初始可用数量        memory: string #内存请求,容器启动的初始可用数量    lifecycle: #生命周期钩子        postStart: #容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启        preStop: #容器终止前执行此钩子,无论结果如何,容器都会终止    livenessProbe:  #对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器      exec:       　 #对Pod容器内检查方式设置为exec方式        command: [string]  #exec方式需要制定的命令或脚本      httpGet:       #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port        path: string        port: number        host: string        scheme: string        HttpHeaders:        - name: string          value: string      tcpSocket:     #对Pod内个容器健康检查方式设置为tcpSocket方式         port: number       initialDelaySeconds: 0       #容器启动完成后首次探测的时间，单位为秒       timeoutSeconds: 0    　　    #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒       periodSeconds: 0     　　    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次       successThreshold: 0       failureThreshold: 0       securityContext:         privileged: false  restartPolicy: [Always | Never | OnFailure]  #Pod的重启策略  nodeName: &lt;string&gt; #设置NodeName表示将该Pod调度到指定到名称的node节点上  nodeSelector: obeject #设置NodeSelector表示将该Pod调度到包含这个label的node上  imagePullSecrets: #Pull镜像时使用的secret名称，以key：secretkey格式指定  - name: string  hostNetwork: false   #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络  volumes:   #在该pod上定义共享存储卷列表  - name: string    #共享存储卷名称 （volumes类型有很多种）    emptyDir: {}       #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值    hostPath: string   #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录      path: string      　　        #Pod所在宿主机的目录，将被用于同期中mount的目录    secret:       　　　#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部      scretname: string        items:           - key: string        path: string    configMap:         #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部      name: string      items:      - key: string        path: string#小提示：#   在这里，可通过一个命令来查看每种资源的可配置项#   kubectl explain 资源类型         查看某种资源可以配置的一级属性#   kubectl explain 资源类型.属性     查看属性的子属性[root@k8s-master01 ~]# kubectl explain podKIND:     PodVERSION:  v1FIELDS:   apiVersion   &lt;string&gt;   kind &lt;string&gt;   metadata     &lt;Object&gt;   spec &lt;Object&gt;   status       &lt;Object&gt;[root@k8s-master01 ~]# kubectl explain pod.metadataKIND:     PodVERSION:  v1RESOURCE: metadata &lt;Object&gt;FIELDS:   annotations  &lt;map[string]string&gt;   clusterName  &lt;string&gt;   creationTimestamp    &lt;string&gt;   deletionGracePeriodSeconds   &lt;integer&gt;   deletionTimestamp    &lt;string&gt;   finalizers   &lt;[]string&gt;   generateName &lt;string&gt;   generation   &lt;integer&gt;   labels       &lt;map[string]string&gt;   managedFields        &lt;[]Object&gt;   name &lt;string&gt;   namespace    &lt;string&gt;   ownerReferences      &lt;[]Object&gt;   resourceVersion      &lt;string&gt;   selfLink     &lt;string&gt;   uid  &lt;string&gt;</code></pre><p>在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：</p><ul><li>apiVersion <string> 版本，由kubernetes内部定义，版本号必须可以用 kubectl api-versions 查询到</string></li><li>kind <string> 类型，由kubernetes内部定义，版本号必须可以用 kubectl api-resources 查询到</string></li><li>metadata <object> 元数据，主要是资源标识和说明，常用的有name、namespace、labels等</object></li><li>spec <object> 描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述</object></li><li>status <object> 状态信息，里面的内容不需要定义，由kubernetes自动生成</object></li></ul><p>在上面的属性中，spec是接下来研究的重点，继续看下它的常见子属性:</p><ul><li>containers &lt;[]Object&gt; 容器列表，用于定义容器的详细信息</li><li>nodeName <string> 根据nodeName的值将pod调度到指定的Node节点上</string></li><li>nodeSelector &lt;map[]&gt; 根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上</li><li>hostNetwork <boolean> 是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</boolean></li><li>volumes &lt;[]Object&gt; 存储卷，用于定义Pod上面挂在的存储信息</li><li>restartPolicy <string> 重启策略，表示Pod在遇到故障的时候的处理策略</string></li></ul><p>5.2 Pod配置</p><p>本小节主要来研究pod.spec.containers属性，这也是pod配置中最为关键的一项配置。</p><pre><code>[root@k8s-master01 ~]# kubectl explain pod.spec.containersKIND:     PodVERSION:  v1RESOURCE: containers &lt;[]Object&gt;   # 数组，代表可以有多个容器FIELDS:   name  &lt;string&gt;     # 容器名称   image &lt;string&gt;     # 容器需要的镜像地址   imagePullPolicy  &lt;string&gt; # 镜像拉取策略    command  &lt;[]string&gt; # 容器的启动命令列表，如不指定，使用打包时使用的启动命令   args     &lt;[]string&gt; # 容器的启动命令需要的参数列表   env      &lt;[]Object&gt; # 容器环境变量的配置   ports    &lt;[]Object&gt;     # 容器需要暴露的端口号列表   resources &lt;Object&gt;      # 资源限制和资源请求的设置</code></pre><p>5.2.1 基本配置</p><p>创建pod-base.yaml文件，内容如下：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-base  namespace: dev  labels:    user: heimaspec:  containers:  - name: nginx    image: nginx:1.17.1  - name: busybox    image: busybox:1.30</code></pre><p><a href="https://img-blog.csdnimg.cn/b659b1065bbb4894bd24754aad2090f2.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/b659b1065bbb4894bd24754aad2090f2.png#pic_center" class="lazyload"></a></p><p>上面定义了一个比较简单Pod的配置，里面有两个容器：</p><ul><li>nginx：用1.17.1版本的nginx镜像创建，（nginx是一个轻量级web容器）</li><li>busybox：用1.30版本的busybox镜像创建，（busybox是一个小巧的linux命令集合）</li></ul><pre><code># 创建Pod[root@k8s-master01 pod]# kubectl apply -f pod-base.yamlpod/pod-base created# 查看Pod状况# READY 1/2 : 表示当前Pod中有2个容器，其中1个准备就绪，1个未就绪# RESTARTS  : 重启次数，因为有1个容器故障了，Pod一直在重启试图恢复它[root@k8s-master01 pod]# kubectl get pod -n devNAME       READY   STATUS    RESTARTS   AGEpod-base   1/2     Running   4          95s# 可以通过describe查看内部的详情# 此时已经运行起来了一个基本的Pod，虽然它暂时有问题[root@k8s-master01 pod]# kubectl describe pod pod-base -n dev</code></pre><p>5.2.2 镜像拉取</p><p>创建pod-imagepullpolicy.yaml文件，内容如下：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-imagepullpolicy  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    imagePullPolicy: Never # 用于设置镜像拉取策略  - name: busybox    image: busybox:1.30</code></pre><p><a href="https://img-blog.csdnimg.cn/04f63bda40ba433db814a89bf601b760.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/04f63bda40ba433db814a89bf601b760.png#pic_center" class="lazyload"></a></p><p>imagePullPolicy，用于设置镜像拉取策略，kubernetes支持配置三种拉取策略：</p><ul><li>Always：总是从远程仓库拉取镜像（一直远程下载）</li><li>IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就本地 本地没远程下载）</li><li>Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错 （一直使用本地）</li></ul><p>默认值说明：</p><p>如果镜像tag为具体版本号， 默认策略是：IfNotPresent</p><p>如果镜像tag为：latest（最终版本） ，默认策略是always</p><pre><code># 创建Pod[root@k8s-master01 pod]# kubectl create -f pod-imagepullpolicy.yamlpod/pod-imagepullpolicy created# 查看Pod详情# 此时明显可以看到nginx镜像有一步Pulling image &quot;nginx:1.17.1&quot;的过程[root@k8s-master01 pod]# kubectl describe pod pod-imagepullpolicy -n dev......Events:  Type     Reason     Age               From               Message  ----     ------     ----              ----               -------  Normal   Scheduled  &lt;unknown&gt;         default-scheduler  Successfully assigned dev/pod-imagePullPolicy to node1  Normal   Pulling    32s               kubelet, node1     Pulling image &quot;nginx:1.17.1&quot;  Normal   Pulled     26s               kubelet, node1     Successfully pulled image &quot;nginx:1.17.1&quot;  Normal   Created    26s               kubelet, node1     Created container nginx  Normal   Started    25s               kubelet, node1     Started container nginx  Normal   Pulled     7s (x3 over 25s)  kubelet, node1     Container image &quot;busybox:1.30&quot; already present on machine  Normal   Created    7s (x3 over 25s)  kubelet, node1     Created container busybox  Normal   Started    7s (x3 over 25s)  kubelet, node1     Started container busybox</code></pre><p>5.2.3 启动命令</p><p>在前面的案例中，一直有一个问题没有解决，就是的busybox容器一直没有成功运行，那么到底是什么原因导致这个容器的故障呢？</p><p>原来busybox并不是一个程序，而是类似于一个工具类的集合，kubernetes集群启动管理后，它会自动关闭。解决方法就是让其一直在运行，这就用到了command配置。</p><p>创建pod-command.yaml文件，内容如下：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-command  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1  - name: busybox    image: busybox:1.30    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done;&quot;]</code></pre><p><a href="https://img-blog.csdnimg.cn/471c24f4e3eb4bb2bc6b697ca31f4fd6.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/471c24f4e3eb4bb2bc6b697ca31f4fd6.png#pic_center" class="lazyload"></a></p><p>command，用于在pod中的容器初始化完毕之后运行一个命令。</p><p>稍微解释下上面命令的意思：</p><p>“/bin/sh”,”-c”, 使用sh执行命令</p><p>touch /tmp/hello.txt; 创建一个/tmp/hello.txt 文件</p><p>while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done; 每隔3秒向文件中写入当前时间</p><pre><code># 创建Pod[root@k8s-master01 pod]# kubectl create  -f pod-command.yamlpod/pod-command created# 查看Pod状态# 此时发现两个pod都正常运行了[root@k8s-master01 pod]# kubectl get pods pod-command -n devNAME          READY   STATUS   RESTARTS   AGEpod-command   2/2     Runing   0          2s# 进入pod中的busybox容器，查看文件内容# 补充一个命令: kubectl exec  pod名称 -n 命名空间 -it -c 容器名称 /bin/sh  在容器内部执行命令# 使用这个命令就可以进入某个容器的内部，然后进行相关操作了# 比如，可以查看txt文件的内容[root@k8s-master01 pod]# kubectl exec pod-command -n dev -it -c busybox /bin/sh/ # tail -f /tmp/hello.txt14:44:1914:44:2214:44:25特别说明：    通过上面发现command已经可以完成启动命令和传递参数的功能，为什么这里还要提供一个args选项，用于传递参数呢?这其实跟docker有点关系，kubernetes中的command、args两项其实是实现覆盖Dockerfile中ENTRYPOINT的功能。 1 如果command和args均没有写，那么用Dockerfile的配置。 2 如果command写了，但args没有写，那么Dockerfile默认的配置会被忽略，执行输入的command 3 如果command没写，但args写了，那么Dockerfile中配置的ENTRYPOINT的命令会被执行，使用当前args的参数 4 如果command和args都写了，那么Dockerfile的配置被忽略，执行command并追加上args参数</code></pre><p>5.2.4 环境变量</p><p>创建pod-env.yaml文件，内容如下：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-env  namespace: devspec:  containers:  - name: busybox    image: busybox:1.30    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;while true;do /bin/echo $(date +%T);sleep 60; done;&quot;]    env: # 设置环境变量列表    - name: &quot;username&quot;      value: &quot;admin&quot;    - name: &quot;password&quot;      value: &quot;123456&quot;</code></pre><p>env，环境变量，用于在pod中的容器设置环境变量。</p><pre><code># 创建Pod[root@k8s-master01 ~]# kubectl create -f pod-env.yamlpod/pod-env created# 进入容器，输出环境变量[root@k8s-master01 ~]# kubectl exec pod-env -n dev -c busybox -it /bin/sh/ # echo $usernameadmin/ # echo $password123456</code></pre><p>这种方式不是很推荐，推荐将这些配置单独存储在配置文件中，这种方式将在后面介绍。</p><p>5.2.5 端口设置</p><p>本小节来介绍容器的端口设置，也就是containers的ports选项。</p><p>首先看下ports支持的子选项：</p><pre><code>[root@k8s-master01 ~]# kubectl explain pod.spec.containers.portsKIND:     PodVERSION:  v1RESOURCE: ports &lt;[]Object&gt;FIELDS:   name         &lt;string&gt;  # 端口名称，如果指定，必须保证name在pod中是唯一的           containerPort&lt;integer&gt; # 容器要监听的端口(0&lt;x&lt;65536)   hostPort     &lt;integer&gt; # 容器要在主机上公开的端口，如果设置，主机上只能运行容器的一个副本(一般省略)    hostIP       &lt;string&gt;  # 要将外部端口绑定到的主机IP(一般省略)   protocol     &lt;string&gt;  # 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”。</code></pre><p>接下来，编写一个测试案例，创建pod-ports.yaml</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-ports  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    ports: # 设置容器暴露的端口列表    - name: nginx-port      containerPort: 80      protocol: TCP# 创建Pod[root@k8s-master01 ~]# kubectl create -f pod-ports.yamlpod/pod-ports created# 查看pod# 在下面可以明显看到配置信息[root@k8s-master01 ~]# kubectl get pod pod-ports -n dev -o yaml......spec:  containers:  - image: nginx:1.17.1    imagePullPolicy: IfNotPresent    name: nginx    ports:    - containerPort: 80      name: nginx-port      protocol: TCP......</code></pre><p>访问容器中的程序需要使用的是Podip:containerPort</p><p>5.2.6 资源配额</p><p>容器中的程序要运行，肯定是要占用一定资源的，比如cpu和内存等，如果不对某个容器的资源做限制，那么它就可能吃掉大量资源，导致其它容器无法运行。针对这种情况，kubernetes提供了对内存和cpu的资源进行配额的机制，这种机制主要通过resources选项实现，他有两个子选项：</p><ul><li>limits：用于限制运行时容器的最大占用资源，当容器占用资源超过limits时会被终止，并进行重启</li><li>requests ：用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动</li></ul><p>可以通过上面两个选项设置资源的上下限。</p><p>接下来，编写一个测试案例，创建pod-resources.yaml</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-resources  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    resources: # 资源配额      limits:  # 限制资源（上限）        cpu: &quot;2&quot; # CPU限制，单位是core数        memory: &quot;10Gi&quot; # 内存限制      requests: # 请求资源（下限）        cpu: &quot;1&quot;  # CPU限制，单位是core数        memory: &quot;10Mi&quot;  # 内存限制</code></pre><p>在这对cpu和memory的单位做一个说明：</p><ul><li><p>cpu：core数，可以为整数或小数</p></li><li><p>memory： 内存大小，可以使用Gi、Mi、G、M等形式</p><h1 id="运行Pod"><a href="#运行Pod" class="headerlink" title="运行Pod"></a>运行Pod</h1><p>  [root@k8s-master01 ~]# kubectl create  -f pod-resources.yaml<br>  pod/pod-resources created</p><h1 id="查看发现pod运行正常"><a href="#查看发现pod运行正常" class="headerlink" title="查看发现pod运行正常"></a>查看发现pod运行正常</h1><p>  [root@k8s-master01 ~]# kubectl get pod pod-resources -n dev<br>  NAME            READY   STATUS    RESTARTS   AGE<br>  pod-resources   1/1     Running   0          39s   </p><h1 id="接下来，停止Pod"><a href="#接下来，停止Pod" class="headerlink" title="接下来，停止Pod"></a>接下来，停止Pod</h1><p>  [root@k8s-master01 ~]# kubectl delete  -f pod-resources.yaml<br>  pod “pod-resources” deleted</p><h1 id="编辑pod，修改resources-requests-memory的值为10Gi"><a href="#编辑pod，修改resources-requests-memory的值为10Gi" class="headerlink" title="编辑pod，修改resources.requests.memory的值为10Gi"></a>编辑pod，修改resources.requests.memory的值为10Gi</h1><p>  [root@k8s-master01 ~]# vim pod-resources.yaml</p><h1 id="再次启动pod"><a href="#再次启动pod" class="headerlink" title="再次启动pod"></a>再次启动pod</h1><p>  [root@k8s-master01 ~]# kubectl create  -f pod-resources.yaml<br>  pod/pod-resources created</p><h1 id="查看Pod状态，发现Pod启动失败"><a href="#查看Pod状态，发现Pod启动失败" class="headerlink" title="查看Pod状态，发现Pod启动失败"></a>查看Pod状态，发现Pod启动失败</h1><p>  [root@k8s-master01 ~]# kubectl get pod pod-resources -n dev -o wide<br>  NAME            READY   STATUS    RESTARTS   AGE<br>  pod-resources   0/1     Pending   0          20s    </p><h1 id="查看pod详情会发现，如下提示"><a href="#查看pod详情会发现，如下提示" class="headerlink" title="查看pod详情会发现，如下提示"></a>查看pod详情会发现，如下提示</h1><p>  [root@k8s-master01 ~]# kubectl describe pod pod-resources -n dev<br>  ……<br>  Warning  FailedScheduling  35s   default-scheduler  0/3 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/master: }, that the pod didn’t tolerate, 2 Insufficient memory.(内存不足)</p></li></ul><p>5.3 Pod生命周期</p><p>我们一般将pod对象从创建至终的这段时间范围称为pod的生命周期，它主要包含下面的过程：</p><ul><li>pod创建过程</li><li>运行初始化容器（init container）过程</li><li>运行主容器（main container）<ul><li>容器启动后钩子（post start）、容器终止前钩子（pre stop）</li><li>容器的存活性探测（liveness probe）、就绪性探测（readiness probe）</li></ul></li><li>pod终止过程</li></ul><p><a href="https://img-blog.csdnimg.cn/9c0469d454244f49b65d9c66f9acacfe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/9c0469d454244f49b65d9c66f9acacfe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>在整个生命周期中，Pod会出现5种状态（相位），分别如下：</p><ul><li>挂起（Pending）：apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</li><li>运行中（Running）：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成</li><li>成功（Succeeded）：pod中的所有容器都已经成功终止并且不会被重启</li><li>失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</li><li>未知（Unknown）：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致</li></ul><p>5.3.1 创建和终止</p><p>pod的创建过程</p><ol><li>用户通过kubectl或其他api客户端提交需要创建的pod信息给apiServer</li><li>apiServer开始生成pod对象的信息，并将信息存入etcd，然后返回确认信息至客户端</li><li>apiServer开始反映etcd中的pod对象的变化，其它组件使用watch机制来跟踪检查apiServer上的变动</li><li>scheduler发现有新的pod对象要创建，开始为Pod分配主机并将结果信息更新至apiServer</li><li>node节点上的kubelet发现有pod调度过来，尝试调用docker启动容器，并将结果回送至apiServer</li><li>apiServer将接收到的pod状态信息存入etcd中</li></ol><p><a href="https://img-blog.csdnimg.cn/853af7cdd8ae45f6b3655494b6708dd6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/853af7cdd8ae45f6b3655494b6708dd6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>pod的终止过程</p><ol><li>用户向apiServer发送删除pod对象的命令</li><li>apiServcer中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead</li><li>将pod标记为terminating状态</li><li>kubelet在监控到pod对象转为terminating状态的同时启动pod关闭过程</li><li>端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除</li><li>如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式启动执行</li><li>pod对象中的容器进程收到停止信号</li><li>宽限期结束后，若pod中还存在仍在运行的进程，那么pod对象会收到立即终止的信号</li><li>kubelet请求apiServer将此pod资源的宽限期设置为0从而完成删除操作，此时pod对于用户已不可见</li></ol><p>5.3.2 初始化容器</p><p>初始化容器是在pod的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：</p><ol><li>初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成</li><li>初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行</li></ol><p>初始化容器有很多的应用场景，下面列出的是最常见的几个：</p><ul><li>提供主容器镜像中不具备的工具程序或自定义代码</li><li>初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足</li></ul><p>接下来做一个案例，模拟下面这个需求：</p><p>假设要以主容器来运行nginx，但是要求在运行nginx之前先要能够连接上mysql和redis所在服务器</p><p>为了简化测试，事先规定好mysql(192.168.5.4)和redis(192.168.5.5)服务器的地址</p><p>创建pod-initcontainer.yaml，内容如下：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-initcontainer  namespace: devspec:  containers:  - name: main-container    image: nginx:1.17.1    ports:     - name: nginx-port      containerPort: 80  initContainers:  - name: test-mysql    image: busybox:1.30    command: [&apos;sh&apos;, &apos;-c&apos;, &apos;until ping 192.168.5.14 -c 1 ; do echo waiting for mysql...; sleep 2; done;&apos;]  - name: test-redis    image: busybox:1.30    command: [&apos;sh&apos;, &apos;-c&apos;, &apos;until ping 192.168.5.15 -c 1 ; do echo waiting for reids...; sleep 2; done;&apos;]# 创建pod[root@k8s-master01 ~]# kubectl create -f pod-initcontainer.yamlpod/pod-initcontainer created# 查看pod状态# 发现pod卡在启动第一个初始化容器过程中，后面的容器不会运行root@k8s-master01 ~]# kubectl describe pod  pod-initcontainer -n dev........Events:  Type    Reason     Age   From               Message  ----    ------     ----  ----               -------  Normal  Scheduled  49s   default-scheduler  Successfully assigned dev/pod-initcontainer to node1  Normal  Pulled     48s   kubelet, node1     Container image &quot;busybox:1.30&quot; already present on machine  Normal  Created    48s   kubelet, node1     Created container test-mysql  Normal  Started    48s   kubelet, node1     Started container test-mysql# 动态查看pod[root@k8s-master01 ~]# kubectl get pods pod-initcontainer -n dev -wNAME                             READY   STATUS     RESTARTS   AGEpod-initcontainer                0/1     Init:0/2   0          15spod-initcontainer                0/1     Init:1/2   0          52spod-initcontainer                0/1     Init:1/2   0          53spod-initcontainer                0/1     PodInitializing   0          89spod-initcontainer                1/1     Running           0          90s# 接下来新开一个shell，为当前服务器新增两个ip，观察pod的变化[root@k8s-master01 ~]# ifconfig ens33:1 192.168.5.14 netmask 255.255.255.0 up[root@k8s-master01 ~]# ifconfig ens33:2 192.168.5.15 netmask 255.255.255.0 up</code></pre><p>5.3.3 钩子函数</p><p>钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。</p><p>kubernetes在主容器的启动之后和停止之前提供了两个钩子函数：</p><ul><li>post start：容器创建之后执行，如果失败了会重启容器</li><li>pre stop ：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</li></ul><p>钩子处理器支持使用下面三种方式定义动作：</p><ul><li>Exec命令：在容器内执行一次命令<pre><code>……  lifecycle:    postStart:       exec:        command:        - cat        - /tmp/healthy……</code></pre></li><li>TCPSocket：在当前容器尝试访问指定的socket<pre><code>……        lifecycle:    postStart:      tcpSocket:        port: 8080……</code></pre></li><li>HTTPGet：在当前容器中向某url发起http请求<pre><code>……  lifecycle:    postStart:      httpGet:        path: / #URI地址        port: 80 #端口号        host: 192.168.5.3 #主机地址        scheme: HTTP #支持的协议，http或者https……</code></pre></li></ul><p>接下来，以exec方式为例，演示下钩子函数的使用，创建pod-hook-exec.yaml文件，内容如下：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-hook-exec  namespace: devspec:  containers:  - name: main-container    image: nginx:1.17.1    ports:    - name: nginx-port      containerPort: 80    lifecycle:      postStart:         exec: # 在容器启动的时候执行一个命令，修改掉nginx的默认首页内容          command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo postStart... &gt; /usr/share/nginx/html/index.html&quot;]      preStop:        exec: # 在容器停止之前停止nginx服务          command: [&quot;/usr/sbin/nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]# 创建pod[root@k8s-master01 ~]# kubectl create -f pod-hook-exec.yamlpod/pod-hook-exec created# 查看pod[root@k8s-master01 ~]# kubectl get pods  pod-hook-exec -n dev -o wideNAME           READY   STATUS     RESTARTS   AGE    IP            NODE    pod-hook-exec  1/1     Running    0          29s    10.244.2.48   node2   # 访问pod[root@k8s-master01 ~]# curl 10.244.2.48postStart...</code></pre><p>5.3.4 容器探测</p><p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例” 摘除 “，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：</p><ul><li>liveness probes：存活性探针，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器</li><li>readiness probes：就绪性探针，用于检测应用实例当前是否可以接收请求，如果不能，k8s不会转发流量</li></ul><p>livenessProbe 决定是否重启容器，readinessProbe 决定是否将请求转发给容器。</p><p>上面两种探针目前均支持三种探测方式：</p><ul><li>Exec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常<pre><code>……  livenessProbe:    exec:      command:      - cat      - /tmp/healthy……</code></pre></li><li>TCPSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常<pre><code>……        livenessProbe:    tcpSocket:      port: 8080……</code></pre></li><li>HTTPGet：调用容器内Web应用的URL，如果返回的状态码在200和399之间，则认为程序正常，否则不正常<pre><code>……  livenessProbe:    httpGet:      path: / #URI地址      port: 80 #端口号      host: 127.0.0.1 #主机地址      scheme: HTTP #支持的协议，http或者https……</code></pre></li></ul><p>下面以liveness probes为例，做几个演示：</p><p>方式一：Exec</p><p>创建pod-liveness-exec.yaml</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-liveness-exec  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    ports:     - name: nginx-port      containerPort: 80    livenessProbe:      exec:        command: [&quot;/bin/cat&quot;,&quot;/tmp/hello.txt&quot;] # 执行一个查看文件的命令</code></pre><p>创建pod，观察效果</p><pre><code># 创建Pod[root@k8s-master01 ~]# kubectl create -f pod-liveness-exec.yamlpod/pod-liveness-exec created# 查看Pod详情[root@k8s-master01 ~]# kubectl describe pods pod-liveness-exec -n dev......  Normal   Created    20s (x2 over 50s)  kubelet, node1     Created container nginx  Normal   Started    20s (x2 over 50s)  kubelet, node1     Started container nginx  Normal   Killing    20s                kubelet, node1     Container nginx failed liveness probe, will be restarted  Warning  Unhealthy  0s (x5 over 40s)   kubelet, node1     Liveness probe failed: cat: can&apos;t open &apos;/tmp/hello11.txt&apos;: No such file or directory# 观察上面的信息就会发现nginx容器启动之后就进行了健康检查# 检查失败之后，容器被kill掉，然后尝试进行重启（这是重启策略的作用，后面讲解）# 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长[root@k8s-master01 ~]# kubectl get pods pod-liveness-exec -n devNAME                READY   STATUS             RESTARTS   AGEpod-liveness-exec   0/1     CrashLoopBackOff   2          3m19s# 当然接下来，可以修改成一个存在的文件，比如/tmp/hello.txt，再试，结果就正常了......</code></pre><p>方式二：TCPSocket</p><p>创建pod-liveness-tcpsocket.yaml</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-liveness-tcpsocket  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    ports:     - name: nginx-port      containerPort: 80    livenessProbe:      tcpSocket:        port: 8080 # 尝试访问8080端口</code></pre><p>创建pod，观察效果</p><pre><code># 创建Pod[root@k8s-master01 ~]# kubectl create -f pod-liveness-tcpsocket.yamlpod/pod-liveness-tcpsocket created# 查看Pod详情[root@k8s-master01 ~]# kubectl describe pods pod-liveness-tcpsocket -n dev......  Normal   Scheduled  31s                            default-scheduler  Successfully assigned dev/pod-liveness-tcpsocket to node2  Normal   Pulled     &lt;invalid&gt;                      kubelet, node2     Container image &quot;nginx:1.17.1&quot; already present on machine  Normal   Created    &lt;invalid&gt;                      kubelet, node2     Created container nginx  Normal   Started    &lt;invalid&gt;                      kubelet, node2     Started container nginx  Warning  Unhealthy  &lt;invalid&gt; (x2 over &lt;invalid&gt;)  kubelet, node2     Liveness probe failed: dial tcp 10.244.2.44:8080: connect: connection refused# 观察上面的信息，发现尝试访问8080端口,但是失败了# 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长[root@k8s-master01 ~]# kubectl get pods pod-liveness-tcpsocket  -n devNAME                     READY   STATUS             RESTARTS   AGEpod-liveness-tcpsocket   0/1     CrashLoopBackOff   2          3m19s# 当然接下来，可以修改成一个可以访问的端口，比如80，再试，结果就正常了......</code></pre><p>方式三：HTTPGet</p><p>创建pod-liveness-httpget.yaml</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-liveness-httpget  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    ports:    - name: nginx-port      containerPort: 80    livenessProbe:      httpGet:  # 其实就是访问http://127.0.0.1:80/hello          scheme: HTTP #支持的协议，http或者https        port: 80 #端口号        path: /hello #URI地址</code></pre><p>创建pod，观察效果</p><pre><code># 创建Pod[root@k8s-master01 ~]# kubectl create -f pod-liveness-httpget.yamlpod/pod-liveness-httpget created# 查看Pod详情[root@k8s-master01 ~]# kubectl describe pod pod-liveness-httpget -n dev.......  Normal   Pulled     6s (x3 over 64s)  kubelet, node1     Container image &quot;nginx:1.17.1&quot; already present on machine  Normal   Created    6s (x3 over 64s)  kubelet, node1     Created container nginx  Normal   Started    6s (x3 over 63s)  kubelet, node1     Started container nginx  Warning  Unhealthy  6s (x6 over 56s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: 404  Normal   Killing    6s (x2 over 36s)  kubelet, node1     Container nginx failed liveness probe, will be restarted# 观察上面信息，尝试访问路径，但是未找到,出现404错误# 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长[root@k8s-master01 ~]# kubectl get pod pod-liveness-httpget -n devNAME                   READY   STATUS    RESTARTS   AGEpod-liveness-httpget   1/1     Running   5          3m17s# 当然接下来，可以修改成一个可以访问的路径path，比如/，再试，结果就正常了......</code></pre><p>至此，已经使用liveness Probe演示了三种探测方式，但是查看livenessProbe的子属性，会发现除了这三种方式，还有一些其他的配置，在这里一并解释下：</p><pre><code>[root@k8s-master01 ~]# kubectl explain pod.spec.containers.livenessProbeFIELDS:   exec &lt;Object&gt;     tcpSocket    &lt;Object&gt;   httpGet      &lt;Object&gt;   initialDelaySeconds  &lt;integer&gt;  # 容器启动后等待多少秒执行第一次探测   timeoutSeconds       &lt;integer&gt;  # 探测超时时间。默认1秒，最小1秒   periodSeconds        &lt;integer&gt;  # 执行探测的频率。默认是10秒，最小1秒   failureThreshold     &lt;integer&gt;  # 连续探测失败多少次才被认定为失败。默认是3。最小值是1   successThreshold     &lt;integer&gt;  # 连续探测成功多少次才被认定为成功。默认是1</code></pre><p>下面稍微配置两个，演示下效果即可：</p><pre><code>[root@k8s-master01 ~]# more pod-liveness-httpget.yamlapiVersion: v1kind: Podmetadata:  name: pod-liveness-httpget  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    ports:    - name: nginx-port      containerPort: 80    livenessProbe:      httpGet:        scheme: HTTP        port: 80         path: /      initialDelaySeconds: 30 # 容器启动后30s开始探测      timeoutSeconds: 5 # 探测超时时间为5s</code></pre><p>5.3.5 重启策略</p><p>在上一节中，一旦容器探测出现了问题，kubernetes就会对容器所在的Pod进行重启，其实这是由pod的重启策略决定的，pod的重启策略有 3 种，分别如下：</p><ul><li>Always ：容器失效时，自动重启该容器，这也是默认值。</li><li>OnFailure ： 容器终止运行且退出码不为0时重启</li><li>Never ： 不论状态为何，都不重启该容器</li></ul><p>重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长。</p><p>创建pod-restartpolicy.yaml：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-restartpolicy  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    ports:    - name: nginx-port      containerPort: 80    livenessProbe:      httpGet:        scheme: HTTP        port: 80        path: /hello  restartPolicy: Never # 设置重启策略为Never</code></pre><p>运行Pod测试</p><pre><code># 创建Pod[root@k8s-master01 ~]# kubectl create -f pod-restartpolicy.yamlpod/pod-restartpolicy created# 查看Pod详情，发现nginx容器失败[root@k8s-master01 ~]# kubectl  describe pods pod-restartpolicy  -n dev......  Warning  Unhealthy  15s (x3 over 35s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: 404  Normal   Killing    15s                kubelet, node1     Container nginx failed liveness probe# 多等一会，再观察pod的重启次数，发现一直是0，并未重启   [root@k8s-master01 ~]# kubectl  get pods pod-restartpolicy -n devNAME                   READY   STATUS    RESTARTS   AGEpod-restartpolicy      0/1     Running   0          5min42s</code></pre><p>5.4 Pod调度</p><p>在默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，这并不满足的需求，因为很多情况下，我们想控制某些Pod到达某些节点上，那么应该怎么做呢？这就要求了解kubernetes对Pod的调度规则，kubernetes提供了四大类调度方式：</p><ul><li>自动调度：运行在哪个节点上完全由Scheduler经过一系列的算法计算得出</li><li>定向调度：NodeName、NodeSelector</li><li>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity</li><li>污点（容忍）调度：Taints、Toleration</li></ul><p>5.4.1 定向调度</p><p>定向调度，指的是利用在pod上声明nodeName或者nodeSelector，以此将Pod调度到期望的node节点上。注意，这里的调度是强制的，这就意味着即使要调度的目标Node不存在，也会向上面进行调度，只不过pod运行失败而已。</p><p>NodeName</p><p>NodeName用于强制约束将Pod调度到指定的Name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。</p><p>接下来，实验一下：创建一个pod-nodename.yaml文件</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-nodename  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1  nodeName: node1 # 指定调度到node1节点上#创建Pod[root@k8s-master01 ~]# kubectl create -f pod-nodename.yamlpod/pod-nodename created#查看Pod调度到NODE属性，确实是调度到了node1节点上[root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wideNAME           READY   STATUS    RESTARTS   AGE   IP            NODE      ......pod-nodename   1/1     Running   0          56s   10.244.1.87   node1     ......   # 接下来，删除pod，修改nodeName的值为node3（并没有node3节点）[root@k8s-master01 ~]# kubectl delete -f pod-nodename.yamlpod &quot;pod-nodename&quot; deleted[root@k8s-master01 ~]# vim pod-nodename.yaml[root@k8s-master01 ~]# kubectl create -f pod-nodename.yamlpod/pod-nodename created#再次查看，发现已经向Node3节点调度，但是由于不存在node3节点，所以pod无法正常运行[root@k8s-master01 ~]# kubectl get pods pod-nodename -n dev -o wideNAME           READY   STATUS    RESTARTS   AGE   IP       NODE    ......pod-nodename   0/1     Pending   0          6s    &lt;none&gt;   node3   ......           </code></pre><p>NodeSelector</p><p>NodeSelector用于将pod调度到添加了指定标签的node节点上。它是通过kubernetes的label-selector机制实现的，也就是说，在pod创建之前，会由scheduler使用MatchNodeSelector调度策略进行label匹配，找出目标node，然后将pod调度到目标节点，该匹配规则是强制约束。</p><p>接下来，实验一下：</p><p>1 首先分别为node节点添加标签</p><pre><code>[root@k8s-master01 ~]# kubectl label nodes node1 nodeenv=pronode/node2 labeled[root@k8s-master01 ~]# kubectl label nodes node2 nodeenv=testnode/node2 labeled</code></pre><p>2 创建一个pod-nodeselector.yaml文件，并使用它创建Pod</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-nodeselector  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1  nodeSelector:     nodeenv: pro # 指定调度到具有nodeenv=pro标签的节点上#创建Pod[root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yamlpod/pod-nodeselector created#查看Pod调度到NODE属性，确实是调度到了node1节点上[root@k8s-master01 ~]# kubectl get pods pod-nodeselector -n dev -o wideNAME               READY   STATUS    RESTARTS   AGE     IP          NODE    ......pod-nodeselector   1/1     Running   0          47s   10.244.1.87   node1   ......# 接下来，删除pod，修改nodeSelector的值为nodeenv: xxxx（不存在打有此标签的节点）[root@k8s-master01 ~]# kubectl delete -f pod-nodeselector.yamlpod &quot;pod-nodeselector&quot; deleted[root@k8s-master01 ~]# vim pod-nodeselector.yaml[root@k8s-master01 ~]# kubectl create -f pod-nodeselector.yamlpod/pod-nodeselector created#再次查看，发现pod无法正常运行,Node的值为none[root@k8s-master01 ~]# kubectl get pods -n dev -o wideNAME               READY   STATUS    RESTARTS   AGE     IP       NODE    pod-nodeselector   0/1     Pending   0          2m20s   &lt;none&gt;   &lt;none&gt;# 查看详情,发现node selector匹配失败的提示[root@k8s-master01 ~]# kubectl describe pods pod-nodeselector -n dev.......Events:  Type     Reason            Age        From               Message  ----     ------            ----       ----               -------  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&apos;t match node selector.</code></pre><p>5.4.2 亲和性调度</p><p>上一节，介绍了两种定向调度的方式，使用起来非常方便，但是也有一定的问题，那就是如果没有满足条件的Node，那么Pod将不会被运行，即使在集群中还有可用Node列表也不行，这就限制了它的使用场景。</p><p>基于上面的问题，kubernetes还提供了一种亲和性调度（Affinity）。它在NodeSelector的基础之上的进行了扩展，可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有，也可以调度到不满足条件的节点上，使调度更加灵活。</p><p>Affinity主要分为三类：</p><ul><li>nodeAffinity(node亲和性）: 以node为目标，解决pod可以调度到哪些node的问题</li><li>podAffinity(pod亲和性) : 以pod为目标，解决pod可以和哪些已存在的pod部署在同一个拓扑域中的问题</li><li>podAntiAffinity(pod反亲和性) : 以pod为目标，解决pod不能和哪些已存在pod部署在同一个拓扑域中的问题</li></ul><p>关于亲和性(反亲和性)使用场景的说明：</p><p>亲和性：如果两个应用频繁交互，那就有必要利用亲和性让两个应用的尽可能的靠近，这样可以减少因网络通信而带来的性能损耗。</p><p>反亲和性：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个node上，这样可以提高服务的高可用性。</p><p>NodeAffinity</p><p>首先来看一下NodeAffinity的可配置项：</p><pre><code>pod.spec.affinity.nodeAffinity  requiredDuringSchedulingIgnoredDuringExecution  Node节点必须满足指定的所有规则才可以，相当于硬限制    nodeSelectorTerms  节点选择列表      matchFields   按节点字段列出的节点选择器要求列表      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)        key    键        values 值        operator 关系符 支持Exists, DoesNotExist, In, NotIn, Gt, Lt  preferredDuringSchedulingIgnoredDuringExecution 优先调度到满足指定的规则的Node，相当于软限制 (倾向)    preference   一个节点选择器项，与相应的权重相关联      matchFields   按节点字段列出的节点选择器要求列表      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)        key    键        values 值        operator 关系符 支持In, NotIn, Exists, DoesNotExist, Gt, Lt    weight 倾向权重，在范围1-100。关系符的使用说明:- matchExpressions:  - key: nodeenv              # 匹配存在标签的key为nodeenv的节点    operator: Exists  - key: nodeenv              # 匹配标签的key为nodeenv,且value是&quot;xxx&quot;或&quot;yyy&quot;的节点    operator: In    values: [&quot;xxx&quot;,&quot;yyy&quot;]  - key: nodeenv              # 匹配标签的key为nodeenv,且value大于&quot;xxx&quot;的节点    operator: Gt    values: &quot;xxx&quot;</code></pre><p>接下来首先演示一下requiredDuringSchedulingIgnoredDuringExecution ,</p><p>创建pod-nodeaffinity-required.yaml</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-nodeaffinity-required  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1  affinity:  #亲和性设置    nodeAffinity: #设置node亲和性      requiredDuringSchedulingIgnoredDuringExecution: # 硬限制        nodeSelectorTerms:        - matchExpressions: # 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签          - key: nodeenv            operator: In            values: [&quot;xxx&quot;,&quot;yyy&quot;]# 创建pod[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yamlpod/pod-nodeaffinity-required created# 查看pod状态 （运行失败）[root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wideNAME                        READY   STATUS    RESTARTS   AGE   IP       NODE    ...... pod-nodeaffinity-required   0/1     Pending   0          16s   &lt;none&gt;   &lt;none&gt;  ......# 查看Pod的详情# 发现调度失败，提示node选择失败[root@k8s-master01 ~]# kubectl describe pod pod-nodeaffinity-required -n dev......  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&apos;t match node selector.  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&apos;t match node selector.#接下来，停止pod[root@k8s-master01 ~]# kubectl delete -f pod-nodeaffinity-required.yamlpod &quot;pod-nodeaffinity-required&quot; deleted# 修改文件，将values: [&quot;xxx&quot;,&quot;yyy&quot;]------&gt; [&quot;pro&quot;,&quot;yyy&quot;][root@k8s-master01 ~]# vim pod-nodeaffinity-required.yaml# 再次启动[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-required.yamlpod/pod-nodeaffinity-required created# 此时查看，发现调度成功，已经将pod调度到了node1上[root@k8s-master01 ~]# kubectl get pods pod-nodeaffinity-required -n dev -o wideNAME                        READY   STATUS    RESTARTS   AGE   IP            NODE  ...... pod-nodeaffinity-required   1/1     Running   0          11s   10.244.1.89   node1 ......</code></pre><p>接下来再演示一下requiredDuringSchedulingIgnoredDuringExecution ,</p><p>创建pod-nodeaffinity-preferred.yaml</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-nodeaffinity-preferred  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1  affinity:  #亲和性设置    nodeAffinity: #设置node亲和性      preferredDuringSchedulingIgnoredDuringExecution: # 软限制      - weight: 1        preference:          matchExpressions: # 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签(当前环境没有)          - key: nodeenv            operator: In            values: [&quot;xxx&quot;,&quot;yyy&quot;]# 创建pod[root@k8s-master01 ~]# kubectl create -f pod-nodeaffinity-preferred.yamlpod/pod-nodeaffinity-preferred created# 查看pod状态 （运行成功）[root@k8s-master01 ~]# kubectl get pod pod-nodeaffinity-preferred -n devNAME                         READY   STATUS    RESTARTS   AGEpod-nodeaffinity-preferred   1/1     Running   0          40sNodeAffinity规则设置的注意事项：    1 如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都得到满足，Pod才能运行在指定的Node上    2 如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可    3 如果一个nodeSelectorTerms中有多个matchExpressions ，则一个节点必须满足所有的才能匹配成功    4 如果一个pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的节点亲和性需求，则系统将忽略此变化</code></pre><p>PodAffinity</p><p>PodAffinity主要实现以运行的Pod为参照，实现让新创建的Pod跟参照pod在一个区域的功能。</p><p>首先来看一下PodAffinity的可配置项：</p><pre><code>pod.spec.affinity.podAffinity  requiredDuringSchedulingIgnoredDuringExecution  硬限制    namespaces       指定参照pod的namespace    topologyKey      指定调度作用域    labelSelector    标签选择器      matchExpressions  按节点标签列出的节点选择器要求列表(推荐)        key    键        values 值        operator 关系符 支持In, NotIn, Exists, DoesNotExist.      matchLabels    指多个matchExpressions映射的内容  preferredDuringSchedulingIgnoredDuringExecution 软限制    podAffinityTerm  选项      namespaces            topologyKey      labelSelector        matchExpressions            key    键          values 值          operator        matchLabels     weight 倾向权重，在范围1-100topologyKey用于指定调度时作用域,例如:    如果指定为kubernetes.io/hostname，那就是以Node节点为区分范围    如果指定为beta.kubernetes.io/os,则以Node节点的操作系统类型来区分</code></pre><p>接下来，演示下requiredDuringSchedulingIgnoredDuringExecution,</p><p>1）首先创建一个参照Pod，pod-podaffinity-target.yaml：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-podaffinity-target  namespace: dev  labels:    podenv: pro #设置标签spec:  containers:  - name: nginx    image: nginx:1.17.1  nodeName: node1 # 将目标pod名确指定到node1上# 启动目标pod[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-target.yamlpod/pod-podaffinity-target created# 查看pod状况[root@k8s-master01 ~]# kubectl get pods  pod-podaffinity-target -n devNAME                     READY   STATUS    RESTARTS   AGEpod-podaffinity-target   1/1     Running   0          4s</code></pre><p>2）创建pod-podaffinity-required.yaml，内容如下：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-podaffinity-required  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1  affinity:  #亲和性设置    podAffinity: #设置pod亲和性      requiredDuringSchedulingIgnoredDuringExecution: # 硬限制      - labelSelector:          matchExpressions: # 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签          - key: podenv            operator: In            values: [&quot;xxx&quot;,&quot;yyy&quot;]        topologyKey: kubernetes.io/hostname</code></pre><p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv=xxx或者nodeenv=yyy的pod在同一Node上，显然现在没有这样pod，接下来，运行测试一下。</p><pre><code># 启动pod[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yamlpod/pod-podaffinity-required created# 查看pod状态，发现未运行[root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n devNAME                       READY   STATUS    RESTARTS   AGEpod-podaffinity-required   0/1     Pending   0          9s# 查看详细信息[root@k8s-master01 ~]# kubectl describe pods pod-podaffinity-required  -n dev......Events:  Type     Reason            Age        From               Message  ----     ------            ----       ----               -------  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 2 node(s) didn&apos;t match pod affinity rules, 1 node(s) had taints that the pod didn&apos;t tolerate.# 接下来修改  values: [&quot;xxx&quot;,&quot;yyy&quot;]-----&gt;values:[&quot;pro&quot;,&quot;yyy&quot;]# 意思是：新Pod必须要与拥有标签nodeenv=xxx或者nodeenv=yyy的pod在同一Node上[root@k8s-master01 ~]# vim pod-podaffinity-required.yaml# 然后重新创建pod，查看效果[root@k8s-master01 ~]# kubectl delete -f  pod-podaffinity-required.yamlpod &quot;pod-podaffinity-required&quot; deleted[root@k8s-master01 ~]# kubectl create -f pod-podaffinity-required.yamlpod/pod-podaffinity-required created# 发现此时Pod运行正常[root@k8s-master01 ~]# kubectl get pods pod-podaffinity-required -n devNAME                       READY   STATUS    RESTARTS   AGE   LABELSpod-podaffinity-required   1/1     Running   0          6s    &lt;none&gt;</code></pre><p>关于PodAffinity的 preferredDuringSchedulingIgnoredDuringExecution，这里不再演示。</p><p>PodAntiAffinity</p><p>PodAntiAffinity主要实现以运行的Pod为参照，让新创建的Pod跟参照pod不在一个区域中的功能。</p><p>它的配置方式和选项跟PodAffinty是一样的，这里不再做详细解释，直接做一个测试案例。</p><p>1）继续使用上个案例中目标pod</p><pre><code>[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labelsNAME                     READY   STATUS    RESTARTS   AGE     IP            NODE    LABELSpod-podaffinity-required 1/1     Running   0          3m29s   10.244.1.38   node1   &lt;none&gt;     pod-podaffinity-target   1/1     Running   0          9m25s   10.244.1.37   node1   podenv=pro</code></pre><p>2）创建pod-podantiaffinity-required.yaml，内容如下：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-podantiaffinity-required  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1  affinity:  #亲和性设置    podAntiAffinity: #设置pod亲和性      requiredDuringSchedulingIgnoredDuringExecution: # 硬限制      - labelSelector:          matchExpressions: # 匹配podenv的值在[&quot;pro&quot;]中的标签          - key: podenv            operator: In            values: [&quot;pro&quot;]        topologyKey: kubernetes.io/hostname</code></pre><p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv=pro的pod不在同一Node上，运行测试一下。</p><pre><code># 创建pod[root@k8s-master01 ~]# kubectl create -f pod-podantiaffinity-required.yamlpod/pod-podantiaffinity-required created# 查看pod# 发现调度到了node2上[root@k8s-master01 ~]# kubectl get pods pod-podantiaffinity-required -n dev -o wideNAME                           READY   STATUS    RESTARTS   AGE   IP            NODE   .. pod-podantiaffinity-required   1/1     Running   0          30s   10.244.1.96   node2  ..</code></pre><p>5.4.3 污点和容忍</p><p>污点（Taints）</p><p>前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加污点属性，来决定是否允许Pod调度过来。</p><p>Node被设置上污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去。</p><p>污点的格式为：key=value:effect, key和value是污点的标签，effect描述污点的作用，支持如下三个选项：</p><ul><li>PreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可调度</li><li>NoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但不会影响当前Node上已存在的Pod</li><li>NoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已存在的Pod驱离</li></ul><p><a href="https://img-blog.csdnimg.cn/e05dcc3d51314b58890c1aac975ed0a0.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/e05dcc3d51314b58890c1aac975ed0a0.png#pic_center" class="lazyload"></a></p><p>使用kubectl设置和去除污点的命令示例如下：</p><pre><code># 设置污点kubectl taint nodes node1 key=value:effect# 去除污点kubectl taint nodes node1 key:effect-# 去除所有污点kubectl taint nodes node1 key-</code></pre><p>接下来，演示下污点的效果：</p><ol><li><p>准备节点node1（为了演示效果更加明显，暂时停止node2节点）</p></li><li><p>为node1节点设置一个污点: tag=heima:PreferNoSchedule；然后创建pod1( pod1 可以 )</p></li><li><p>修改为node1节点设置一个污点: tag=heima:NoSchedule；然后创建pod2( pod1 正常 pod2 失败 )</p></li><li><p>修改为node1节点设置一个污点: tag=heima:NoExecute；然后创建pod3 ( 3个pod都失败 )</p><h1 id="为node1设置污点-PreferNoSchedule"><a href="#为node1设置污点-PreferNoSchedule" class="headerlink" title="为node1设置污点(PreferNoSchedule)"></a>为node1设置污点(PreferNoSchedule)</h1><p> [root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:PreferNoSchedule</p><h1 id="创建pod1"><a href="#创建pod1" class="headerlink" title="创建pod1"></a>创建pod1</h1><p> [root@k8s-master01 ~]# kubectl run taint1 –image=nginx:1.17.1 -n dev<br> [root@k8s-master01 ~]# kubectl get pods -n dev -o wide<br> NAME                      READY   STATUS    RESTARTS   AGE     IP           NODE<br> taint1-7665f7fd85-574h4   1/1     Running   0          2m24s   10.244.1.59   node1    </p><h1 id="为node1设置污点-取消PreferNoSchedule，设置NoSchedule"><a href="#为node1设置污点-取消PreferNoSchedule，设置NoSchedule" class="headerlink" title="为node1设置污点(取消PreferNoSchedule，设置NoSchedule)"></a>为node1设置污点(取消PreferNoSchedule，设置NoSchedule)</h1><p> [root@k8s-master01 ~]# kubectl taint nodes node1 tag:PreferNoSchedule-<br> [root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:NoSchedule</p><h1 id="创建pod2"><a href="#创建pod2" class="headerlink" title="创建pod2"></a>创建pod2</h1><p> [root@k8s-master01 ~]# kubectl run taint2 –image=nginx:1.17.1 -n dev<br> [root@k8s-master01 ~]# kubectl get pods taint2 -n dev -o wide<br> NAME                      READY   STATUS    RESTARTS   AGE     IP            NODE<br> taint1-7665f7fd85-574h4   1/1     Running   0          2m24s   10.244.1.59   node1<br> taint2-544694789-6zmlf    0/1     Pending   0          21s     <none>        <none>   </none></none></p><h1 id="为node1设置污点-取消NoSchedule，设置NoExecute"><a href="#为node1设置污点-取消NoSchedule，设置NoExecute" class="headerlink" title="为node1设置污点(取消NoSchedule，设置NoExecute)"></a>为node1设置污点(取消NoSchedule，设置NoExecute)</h1><p> [root@k8s-master01 ~]# kubectl taint nodes node1 tag:NoSchedule-<br> [root@k8s-master01 ~]# kubectl taint nodes node1 tag=heima:NoExecute</p><h1 id="创建pod3"><a href="#创建pod3" class="headerlink" title="创建pod3"></a>创建pod3</h1><p> [root@k8s-master01 ~]# kubectl run taint3 –image=nginx:1.17.1 -n dev<br> [root@k8s-master01 ~]# kubectl get pods -n dev -o wide<br> NAME                      READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED<br> taint1-7665f7fd85-htkmp   0/1     Pending   0          35s   <none>   <none>   <none><br> taint2-544694789-bn7wb    0/1     Pending   0          35s   <none>   <none>   <none><br> taint3-6d78dbd749-tktkq   0/1     Pending   0          6s    <none>   <none>   <none>     </none></none></none></none></none></none></none></none></none></p><p> 小提示：</p><pre><code>使用kubeadm搭建的集群，默认就会给master节点添加一个污点标记,所以pod就不会调度到master节点上.</code></pre></li></ol><p>容忍（Toleration）</p><p>上面介绍了污点的作用，我们可以在node上添加污点用于拒绝pod调度上来，但是如果就是想将一个pod调度到一个有污点的node上去，这时候应该怎么做呢？这就要使用到容忍。<br><a href="https://img-blog.csdnimg.cn/5e4e6e66c6f343308bbc8f290e8b158d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/5e4e6e66c6f343308bbc8f290e8b158d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>污点就是拒绝，容忍就是忽略，Node通过污点拒绝pod调度上去，Pod通过容忍忽略拒绝</p><p>下面先通过一个案例看下效果：</p><ol><li>上一小节，已经在node1节点上打上了NoExecute的污点，此时pod是调度不上去的</li><li>本小节，可以通过给pod添加容忍，然后将其调度上去</li></ol><p>创建pod-toleration.yaml,内容如下</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-toleration  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1  tolerations:      # 添加容忍  - key: &quot;tag&quot;        # 要容忍的污点的key    operator: &quot;Equal&quot; # 操作符    value: &quot;heima&quot;    # 容忍的污点的value    effect: &quot;NoExecute&quot;   # 添加容忍的规则，这里必须和标记的污点规则相同# 添加容忍之前的pod[root@k8s-master01 ~]# kubectl get pods -n dev -o wideNAME             READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED pod-toleration   0/1     Pending   0          3s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           # 添加容忍之后的pod[root@k8s-master01 ~]# kubectl get pods -n dev -o wideNAME             READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATEDpod-toleration   1/1     Running   0          3s    10.244.1.62   node1   &lt;none&gt;        </code></pre><p>下面看一下容忍的详细配置:</p><pre><code>[root@k8s-master01 ~]# kubectl explain pod.spec.tolerations......FIELDS:   key       # 对应着要容忍的污点的键，空意味着匹配所有的键   value     # 对应着要容忍的污点的值   operator  # key-value的运算符，支持Equal和Exists（默认）   effect    # 对应污点的effect，空意味着匹配所有影响   tolerationSeconds   # 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间</code></pre><ol start="6"><li>Pod控制器详解</li></ol><p>6.1 Pod控制器介绍</p><p>Pod是kubernetes的最小管理单元，在kubernetes中，按照pod的创建方式可以将其分为两类：</p><ul><li>自主式pod：kubernetes直接创建出来的Pod，这种pod删除后就没有了，也不会重建</li><li>控制器创建的pod：kubernetes通过控制器创建的pod，这种pod删除了之后还会自动重建</li></ul><p>什么是Pod控制器</p><p>Pod控制器是管理pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。</p><p>在kubernetes中，有很多类型的pod控制器，每种都有自己的适合的场景，常见的有下面这些：</p><ul><li>ReplicationController：比较原始的pod控制器，已经被废弃，由ReplicaSet替代</li><li>ReplicaSet：保证副本数量一直维持在期望值，并支持pod数量扩缩容，镜像版本升级</li><li>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本</li><li>Horizontal Pod Autoscaler：可以根据集群负载自动水平调整Pod的数量，实现削峰填谷</li><li>DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务</li><li>Job：它创建出来的pod只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务</li><li>Cronjob：它创建的Pod负责周期性任务控制，不需要持续后台运行</li><li>StatefulSet：管理有状态应用</li></ul><p>6.2 ReplicaSet(RS)</p><p>ReplicaSet的主要作用是保证一定数量的pod正常运行，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对pod数量的扩缩容和镜像版本的升降级。</p><p><a href="https://img-blog.csdnimg.cn/55e3a977f9994f9cb0761188a424eb4c.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/55e3a977f9994f9cb0761188a424eb4c.png#pic_center" class="lazyload"></a></p><p>ReplicaSet的资源清单文件：</p><pre><code>apiVersion: apps/v1 # 版本号kind: ReplicaSet # 类型       metadata: # 元数据  name: # rs名称   namespace: # 所属命名空间   labels: #标签    controller: rsspec: # 详情描述  replicas: 3 # 副本数量  selector: # 选择器，通过它指定该控制器管理哪些pod    matchLabels:      # Labels匹配规则      app: nginx-pod    matchExpressions: # Expressions匹配规则      - {key: app, operator: In, values: [nginx-pod]}  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本    metadata:      labels:        app: nginx-pod    spec:      containers:      - name: nginx        image: nginx:1.17.1        ports:        - containerPort: 80</code></pre><p>在这里面，需要新了解的配置项就是spec下面几个选项：</p><ul><li>replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</li><li>selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制<br>在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</li><li>template：模板，就是当前控制器创建pod所使用的模板板，里面其实就是前一章学过的pod的定义</li></ul><p>创建ReplicaSet</p><p>创建pc-replicaset.yaml文件，内容如下：</p><pre><code>apiVersion: apps/v1kind: ReplicaSet   metadata:  name: pc-replicaset  namespace: devspec:  replicas: 3  selector:     matchLabels:      app: nginx-pod  template:    metadata:      labels:        app: nginx-pod    spec:      containers:      - name: nginx        image: nginx:1.17.1# 创建rs[root@k8s-master01 ~]# kubectl create -f pc-replicaset.yamlreplicaset.apps/pc-replicaset created# 查看rs# DESIRED:期望副本数量  # CURRENT:当前副本数量  # READY:已经准备好提供服务的副本数量[root@k8s-master01 ~]# kubectl get rs pc-replicaset -n dev -o wideNAME          DESIRED   CURRENT READY AGE   CONTAINERS   IMAGES             SELECTORpc-replicaset 3         3       3     22s   nginx        nginx:1.17.1       app=nginx-pod# 查看当前控制器创建出来的pod# 这里发现控制器创建出来的pod的名称是在控制器名称后面拼接了-xxxxx随机码[root@k8s-master01 ~]# kubectl get pod -n devNAME                          READY   STATUS    RESTARTS   AGEpc-replicaset-6vmvt   1/1     Running   0          54spc-replicaset-fmb8f   1/1     Running   0          54spc-replicaset-snrk2   1/1     Running   0          54s</code></pre><p>扩缩容</p><pre><code># 编辑rs的副本数量，修改spec:replicas: 6即可[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n devreplicaset.apps/pc-replicaset edited# 查看pod[root@k8s-master01 ~]# kubectl get pods -n devNAME                          READY   STATUS    RESTARTS   AGEpc-replicaset-6vmvt   1/1     Running   0          114mpc-replicaset-cftnp   1/1     Running   0          10spc-replicaset-fjlm6   1/1     Running   0          10spc-replicaset-fmb8f   1/1     Running   0          114mpc-replicaset-s2whj   1/1     Running   0          10spc-replicaset-snrk2   1/1     Running   0          114m# 当然也可以直接使用命令实现# 使用scale命令实现扩缩容， 后面--replicas=n直接指定目标数量即可[root@k8s-master01 ~]# kubectl scale rs pc-replicaset --replicas=2 -n devreplicaset.apps/pc-replicaset scaled# 命令运行完毕，立即查看，发现已经有4个开始准备退出了[root@k8s-master01 ~]# kubectl get pods -n devNAME                       READY   STATUS        RESTARTS   AGEpc-replicaset-6vmvt   0/1     Terminating   0          118mpc-replicaset-cftnp   0/1     Terminating   0          4m17spc-replicaset-fjlm6   0/1     Terminating   0          4m17spc-replicaset-fmb8f   1/1     Running       0          118mpc-replicaset-s2whj   0/1     Terminating   0          4m17spc-replicaset-snrk2   1/1     Running       0          118m#稍等片刻，就只剩下2个了[root@k8s-master01 ~]# kubectl get pods -n devNAME                       READY   STATUS    RESTARTS   AGEpc-replicaset-fmb8f   1/1     Running   0          119mpc-replicaset-snrk2   1/1     Running   0          119m</code></pre><p>镜像升级</p><pre><code># 编辑rs的容器镜像 - image: nginx:1.17.2[root@k8s-master01 ~]# kubectl edit rs pc-replicaset -n devreplicaset.apps/pc-replicaset edited# 再次查看，发现镜像版本已经变更了[root@k8s-master01 ~]# kubectl get rs -n dev -o wideNAME                DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES        ...pc-replicaset       2        2         2       140m   nginx         nginx:1.17.2  ...# 同样的道理，也可以使用命令完成这个工作# kubectl set image rs rs名称 容器=镜像版本 -n namespace[root@k8s-master01 ~]# kubectl set image rs pc-replicaset nginx=nginx:1.17.1  -n devreplicaset.apps/pc-replicaset image updated# 再次查看，发现镜像版本已经变更了[root@k8s-master01 ~]# kubectl get rs -n dev -o wideNAME                 DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES            ...pc-replicaset        2        2         2       145m   nginx        nginx:1.17.1 ... </code></pre><p>删除ReplicaSet</p><pre><code># 使用kubectl delete命令会删除此RS以及它管理的Pod# 在kubernetes删除RS前，会将RS的replicasclear调整为0，等待所有的Pod被删除后，在执行RS对象的删除[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n devreplicaset.apps &quot;pc-replicaset&quot; deleted[root@k8s-master01 ~]# kubectl get pod -n dev -o wideNo resources found in dev namespace.# 如果希望仅仅删除RS对象（保留Pod），可以使用kubectl delete命令时添加--cascade=false选项（不推荐）。[root@k8s-master01 ~]# kubectl delete rs pc-replicaset -n dev --cascade=falsereplicaset.apps &quot;pc-replicaset&quot; deleted[root@k8s-master01 ~]# kubectl get pods -n devNAME                  READY   STATUS    RESTARTS   AGEpc-replicaset-cl82j   1/1     Running   0          75spc-replicaset-dslhb   1/1     Running   0          75s# 也可以使用yaml直接删除(推荐)[root@k8s-master01 ~]# kubectl delete -f pc-replicaset.yamlreplicaset.apps &quot;pc-replicaset&quot; deleted</code></pre><p>6.3 Deployment(Deploy)</p><p>为了更好的解决服务编排的问题，kubernetes在V1.2版本开始，引入了Deployment控制器。值得一提的是，这种控制器并不直接管理pod，而是通过管理ReplicaSet来简介管理Pod，即：Deployment管理ReplicaSet，ReplicaSet管理Pod。所以Deployment比ReplicaSet功能更加强大。<br><a href="https://img-blog.csdnimg.cn/02903b654dcf4552912b9e86c12d4966.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/02903b654dcf4552912b9e86c12d4966.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>Deployment主要功能有下面几个：</p><ul><li>支持ReplicaSet的所有功能</li><li>支持发布的停止、继续</li><li>支持滚动升级和回滚版本</li></ul><p>Deployment的资源清单文件：</p><pre><code>apiVersion: apps/v1 # 版本号kind: Deployment # 类型       metadata: # 元数据  name: # rs名称   namespace: # 所属命名空间   labels: #标签    controller: deployspec: # 详情描述  replicas: 3 # 副本数量  revisionHistoryLimit: 3 # 保留历史版本  paused: false # 暂停部署，默认是false  progressDeadlineSeconds: 600 # 部署超时时间（s），默认是600  strategy: # 策略    type: RollingUpdate # 滚动更新策略    rollingUpdate: # 滚动更新      maxSurge: 30% # 最大额外可以存在的副本数，可以为百分比，也可以为整数      maxUnavailable: 30% # 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数  selector: # 选择器，通过它指定该控制器管理哪些pod    matchLabels:      # Labels匹配规则      app: nginx-pod    matchExpressions: # Expressions匹配规则      - {key: app, operator: In, values: [nginx-pod]}  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本    metadata:      labels:        app: nginx-pod    spec:      containers:      - name: nginx        image: nginx:1.17.1        ports:        - containerPort: 80</code></pre><p>创建deployment</p><p>创建pc-deployment.yaml，内容如下：</p><pre><code>apiVersion: apps/v1kind: Deployment      metadata:  name: pc-deployment  namespace: devspec:   replicas: 3  selector:    matchLabels:      app: nginx-pod  template:    metadata:      labels:        app: nginx-pod    spec:      containers:      - name: nginx        image: nginx:1.17.1# 创建deployment[root@k8s-master01 ~]# kubectl create -f pc-deployment.yaml --record=truedeployment.apps/pc-deployment created# 查看deployment# UP-TO-DATE 最新版本的pod的数量# AVAILABLE  当前可用的pod的数量[root@k8s-master01 ~]# kubectl get deploy pc-deployment -n devNAME            READY   UP-TO-DATE   AVAILABLE   AGEpc-deployment   3/3     3            3           15s# 查看rs# 发现rs的名称是在原来deployment的名字后面添加了一个10位数的随机串[root@k8s-master01 ~]# kubectl get rs -n devNAME                       DESIRED   CURRENT   READY   AGEpc-deployment-6696798b78   3         3         3       23s# 查看pod[root@k8s-master01 ~]# kubectl get pods -n devNAME                             READY   STATUS    RESTARTS   AGEpc-deployment-6696798b78-d2c8n   1/1     Running   0          107spc-deployment-6696798b78-smpvp   1/1     Running   0          107spc-deployment-6696798b78-wvjd8   1/1     Running   0          107s</code></pre><p>扩缩容</p><pre><code># 变更副本数量为5个[root@k8s-master01 ~]# kubectl scale deploy pc-deployment --replicas=5  -n devdeployment.apps/pc-deployment scaled# 查看deployment[root@k8s-master01 ~]# kubectl get deploy pc-deployment -n devNAME            READY   UP-TO-DATE   AVAILABLE   AGEpc-deployment   5/5     5            5           2m# 查看pod[root@k8s-master01 ~]#  kubectl get pods -n devNAME                             READY   STATUS    RESTARTS   AGEpc-deployment-6696798b78-d2c8n   1/1     Running   0          4m19spc-deployment-6696798b78-jxmdq   1/1     Running   0          94spc-deployment-6696798b78-mktqv   1/1     Running   0          93spc-deployment-6696798b78-smpvp   1/1     Running   0          4m19spc-deployment-6696798b78-wvjd8   1/1     Running   0          4m19s# 编辑deployment的副本数量，修改spec:replicas: 4即可[root@k8s-master01 ~]# kubectl edit deploy pc-deployment -n devdeployment.apps/pc-deployment edited# 查看pod[root@k8s-master01 ~]# kubectl get pods -n devNAME                             READY   STATUS    RESTARTS   AGEpc-deployment-6696798b78-d2c8n   1/1     Running   0          5m23spc-deployment-6696798b78-jxmdq   1/1     Running   0          2m38spc-deployment-6696798b78-smpvp   1/1     Running   0          5m23spc-deployment-6696798b78-wvjd8   1/1     Running   0          5m23s</code></pre><p>镜像更新</p><p>deployment支持两种更新策略:重建更新和滚动更新,可以通过strategy指定策略类型,支持两个属性:</p><pre><code>strategy：指定新的Pod替换旧的Pod的策略， 支持两个属性：  type：指定策略类型，支持两种策略    Recreate：在创建出新的Pod之前会先杀掉所有已存在的Pod    RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本Pod  rollingUpdate：当type为RollingUpdate时生效，用于为RollingUpdate设置参数，支持两个属性：    maxUnavailable：用来指定在升级过程中不可用Pod的最大数量，默认为25%。    maxSurge： 用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。</code></pre><p>重建更新</p><p>1) 编辑pc-deployment.yaml,在spec节点下添加更新策略</p><pre><code>spec:  strategy: # 策略    type: Recreate # 重建更新</code></pre><p>2) 创建deploy进行验证</p><pre><code># 变更镜像[root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.2 -n devdeployment.apps/pc-deployment image updated# 观察升级过程[root@k8s-master01 ~]#  kubectl get pods -n dev -wNAME                             READY   STATUS    RESTARTS   AGEpc-deployment-5d89bdfbf9-65qcw   1/1     Running   0          31spc-deployment-5d89bdfbf9-w5nzv   1/1     Running   0          31spc-deployment-5d89bdfbf9-xpt7w   1/1     Running   0          31spc-deployment-5d89bdfbf9-xpt7w   1/1     Terminating   0          41spc-deployment-5d89bdfbf9-65qcw   1/1     Terminating   0          41spc-deployment-5d89bdfbf9-w5nzv   1/1     Terminating   0          41spc-deployment-675d469f8b-grn8z   0/1     Pending       0          0spc-deployment-675d469f8b-hbl4v   0/1     Pending       0          0spc-deployment-675d469f8b-67nz2   0/1     Pending       0          0spc-deployment-675d469f8b-grn8z   0/1     ContainerCreating   0          0spc-deployment-675d469f8b-hbl4v   0/1     ContainerCreating   0          0spc-deployment-675d469f8b-67nz2   0/1     ContainerCreating   0          0spc-deployment-675d469f8b-grn8z   1/1     Running             0          1spc-deployment-675d469f8b-67nz2   1/1     Running             0          1spc-deployment-675d469f8b-hbl4v   1/1     Running             0          2s</code></pre><p>滚动更新</p><p>1) 编辑pc-deployment.yaml,在spec节点下添加更新策略</p><pre><code>spec:  strategy: # 策略    type: RollingUpdate # 滚动更新策略    rollingUpdate:      maxSurge: 25%       maxUnavailable: 25%</code></pre><p>2) 创建deploy进行验证</p><pre><code># 变更镜像[root@k8s-master01 ~]# kubectl set image deployment pc-deployment nginx=nginx:1.17.3 -n dev deployment.apps/pc-deployment image updated# 观察升级过程[root@k8s-master01 ~]# kubectl get pods -n dev -wNAME                           READY   STATUS    RESTARTS   AGEpc-deployment-c848d767-8rbzt   1/1     Running   0          31mpc-deployment-c848d767-h4p68   1/1     Running   0          31mpc-deployment-c848d767-hlmz4   1/1     Running   0          31mpc-deployment-c848d767-rrqcn   1/1     Running   0          31mpc-deployment-966bf7f44-226rx   0/1     Pending             0          0spc-deployment-966bf7f44-226rx   0/1     ContainerCreating   0          0spc-deployment-966bf7f44-226rx   1/1     Running             0          1spc-deployment-c848d767-h4p68    0/1     Terminating         0          34mpc-deployment-966bf7f44-cnd44   0/1     Pending             0          0spc-deployment-966bf7f44-cnd44   0/1     ContainerCreating   0          0spc-deployment-966bf7f44-cnd44   1/1     Running             0          2spc-deployment-c848d767-hlmz4    0/1     Terminating         0          34mpc-deployment-966bf7f44-px48p   0/1     Pending             0          0spc-deployment-966bf7f44-px48p   0/1     ContainerCreating   0          0spc-deployment-966bf7f44-px48p   1/1     Running             0          0spc-deployment-c848d767-8rbzt    0/1     Terminating         0          34mpc-deployment-966bf7f44-dkmqp   0/1     Pending             0          0spc-deployment-966bf7f44-dkmqp   0/1     ContainerCreating   0          0spc-deployment-966bf7f44-dkmqp   1/1     Running             0          2spc-deployment-c848d767-rrqcn    0/1     Terminating         0          34m# 至此，新版本的pod创建完毕，就版本的pod销毁完毕# 中间过程是滚动进行的，也就是边销毁边创建</code></pre><p>滚动更新的过程：<br><a href="https://img-blog.csdnimg.cn/0d5002adb811455e96a7baad65d22aa7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/0d5002adb811455e96a7baad65d22aa7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>镜像更新中rs的变化</p><pre><code># 查看rs,发现原来的rs的依旧存在，只是pod数量变为了0，而后又新产生了一个rs，pod数量为4# 其实这就是deployment能够进行版本回退的奥妙所在，后面会详细解释[root@k8s-master01 ~]# kubectl get rs -n devNAME                       DESIRED   CURRENT   READY   AGEpc-deployment-6696798b78   0         0         0       7m37spc-deployment-6696798b11   0         0         0       5m37spc-deployment-c848d76789   4         4         4       72s</code></pre><p>版本回退</p><p>deployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看.</p><p>kubectl rollout： 版本升级相关功能，支持下面的选项：</p><ul><li><p>status 显示当前升级状态</p></li><li><p>history 显示 升级历史记录</p></li><li><p>pause 暂停版本升级过程</p></li><li><p>resume 继续已经暂停的版本升级过程</p></li><li><p>restart 重启版本升级过程</p></li><li><p>undo 回滚到上一级版本（可以使用–to-revision回滚到指定版本）</p><h1 id="查看当前升级版本的状态"><a href="#查看当前升级版本的状态" class="headerlink" title="查看当前升级版本的状态"></a>查看当前升级版本的状态</h1><p>  [root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev<br>  deployment “pc-deployment” successfully rolled out</p><h1 id="查看升级历史记录"><a href="#查看升级历史记录" class="headerlink" title="查看升级历史记录"></a>查看升级历史记录</h1><p>  [root@k8s-master01 ~]# kubectl rollout history deploy pc-deployment -n dev<br>  deployment.apps/pc-deployment<br>  REVISION  CHANGE-CAUSE<br>  1         kubectl create –filename=pc-deployment.yaml –record=true<br>  2         kubectl create –filename=pc-deployment.yaml –record=true<br>  3         kubectl create –filename=pc-deployment.yaml –record=true</p><h1 id="可以发现有三次版本记录，说明完成过两次升级"><a href="#可以发现有三次版本记录，说明完成过两次升级" class="headerlink" title="可以发现有三次版本记录，说明完成过两次升级"></a>可以发现有三次版本记录，说明完成过两次升级</h1><h1 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h1><h1 id="这里直接使用–to-revision-1回滚到了1版本，-如果省略这个选项，就是回退到上个版本，就是2版本"><a href="#这里直接使用–to-revision-1回滚到了1版本，-如果省略这个选项，就是回退到上个版本，就是2版本" class="headerlink" title="这里直接使用–to-revision=1回滚到了1版本， 如果省略这个选项，就是回退到上个版本，就是2版本"></a>这里直接使用–to-revision=1回滚到了1版本， 如果省略这个选项，就是回退到上个版本，就是2版本</h1><p>  [root@k8s-master01 ~]# kubectl rollout undo deployment pc-deployment –to-revision=1 -n dev<br>  deployment.apps/pc-deployment rolled back</p><h1 id="查看发现，通过nginx镜像版本可以发现到了第一版"><a href="#查看发现，通过nginx镜像版本可以发现到了第一版" class="headerlink" title="查看发现，通过nginx镜像版本可以发现到了第一版"></a>查看发现，通过nginx镜像版本可以发现到了第一版</h1><p>  [root@k8s-master01 ~]# kubectl get deploy -n dev -o wide<br>  NAME            READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES<br>  pc-deployment   4/4     4            4           74m   nginx        nginx:1.17.1   </p><h1 id="查看rs，发现第一个rs中有4个pod运行，后面两个版本的rs中pod为运行"><a href="#查看rs，发现第一个rs中有4个pod运行，后面两个版本的rs中pod为运行" class="headerlink" title="查看rs，发现第一个rs中有4个pod运行，后面两个版本的rs中pod为运行"></a>查看rs，发现第一个rs中有4个pod运行，后面两个版本的rs中pod为运行</h1><h1 id="其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的，"><a href="#其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的，" class="headerlink" title="其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的，"></a>其实deployment之所以可是实现版本的回滚，就是通过记录下历史rs来实现的，</h1><h1 id="一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了"><a href="#一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了" class="headerlink" title="一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了"></a>一旦想回滚到哪个版本，只需要将当前版本pod数量降为0，然后将回滚版本的pod提升为目标数量就可以了</h1><p>  [root@k8s-master01 ~]# kubectl get rs -n dev<br>  NAME                       DESIRED   CURRENT   READY   AGE<br>  pc-deployment-6696798b78   4         4         4       78m<br>  pc-deployment-966bf7f44    0         0         0       37m<br>  pc-deployment-c848d767     0         0         0       71m</p></li></ul><p>金丝雀发布</p><p>Deployment控制器支持控制更新过程中的控制，如“暂停(pause)”或“继续(resume)”更新操作。</p><p>比如有一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布。</p><pre><code># 更新deployment的版本，并配置暂停deployment[root@k8s-master01 ~]#  kubectl set image deploy pc-deployment nginx=nginx:1.17.4 -n dev &amp;&amp; kubectl rollout pause deployment pc-deployment  -n devdeployment.apps/pc-deployment image updateddeployment.apps/pc-deployment paused#观察更新状态[root@k8s-master01 ~]# kubectl rollout status deploy pc-deployment -n dev　Waiting for deployment &quot;pc-deployment&quot; rollout to finish: 2 out of 4 new replicas have been updated...# 监控更新的过程，可以看到已经新增了一个资源，但是并未按照预期的状态去删除一个旧的资源，就是因为使用了pause暂停命令[root@k8s-master01 ~]# kubectl get rs -n dev -o wideNAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         pc-deployment-5d89bdfbf9   3         3         3       19m     nginx        nginx:1.17.1   pc-deployment-675d469f8b   0         0         0       14m     nginx        nginx:1.17.2   pc-deployment-6c9f56fcfb   2         2         2       3m16s   nginx        nginx:1.17.4   [root@k8s-master01 ~]# kubectl get pods -n devNAME                             READY   STATUS    RESTARTS   AGEpc-deployment-5d89bdfbf9-rj8sq   1/1     Running   0          7m33spc-deployment-5d89bdfbf9-ttwgg   1/1     Running   0          7m35spc-deployment-5d89bdfbf9-v4wvc   1/1     Running   0          7m34spc-deployment-6c9f56fcfb-996rt   1/1     Running   0          3m31spc-deployment-6c9f56fcfb-j2gtj   1/1     Running   0          3m31s# 确保更新的pod没问题了，继续更新[root@k8s-master01 ~]# kubectl rollout resume deploy pc-deployment -n devdeployment.apps/pc-deployment resumed# 查看最后的更新情况[root@k8s-master01 ~]# kubectl get rs -n dev -o wideNAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         pc-deployment-5d89bdfbf9   0         0         0       21m     nginx        nginx:1.17.1   pc-deployment-675d469f8b   0         0         0       16m     nginx        nginx:1.17.2   pc-deployment-6c9f56fcfb   4         4         4       5m11s   nginx        nginx:1.17.4   [root@k8s-master01 ~]# kubectl get pods -n devNAME                             READY   STATUS    RESTARTS   AGEpc-deployment-6c9f56fcfb-7bfwh   1/1     Running   0          37spc-deployment-6c9f56fcfb-996rt   1/1     Running   0          5m27spc-deployment-6c9f56fcfb-j2gtj   1/1     Running   0          5m27spc-deployment-6c9f56fcfb-rf84v   1/1     Running   0          37s</code></pre><p>删除Deployment</p><pre><code># 删除deployment，其下的rs和pod也将被删除[root@k8s-master01 ~]# kubectl delete -f pc-deployment.yamldeployment.apps &quot;pc-deployment&quot; deleted</code></pre><p>6.4 Horizontal Pod Autoscaler(HPA)</p><p>在前面的课程中，我们已经可以实现通过手工执行kubectl scale命令实现Pod扩容或缩容，但是这显然不符合Kubernetes的定位目标–自动化、智能化。 Kubernetes期望可以实现通过监测Pod的使用情况，实现pod数量的自动调整，于是就产生了Horizontal Pod Autoscaler（HPA）这种控制器。</p><p>HPA可以获取每个Pod利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。其实HPA与之前的Deployment一样，也属于一种Kubernetes资源对象，它通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性地调整目标Pod的副本数，这是HPA的实现原理。</p><p><a href="https://img-blog.csdnimg.cn/2898ce4acfa74f56af97c6e137d4d7ba.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2898ce4acfa74f56af97c6e137d4d7ba.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>接下来，我们来做一个实验</p><p>1 安装metrics-server</p><p>metrics-server可以用来收集集群中的资源使用情况</p><pre><code># 安装git[root@k8s-master01 ~]# yum install git -y# 获取metrics-server, 注意使用的版本[root@k8s-master01 ~]# git clone -b v0.3.6 https://github.com/kubernetes-incubator/metrics-server# 修改deployment, 注意修改的是镜像和初始化参数[root@k8s-master01 ~]# cd /root/metrics-server/deploy/1.8+/[root@k8s-master01 1.8+]# vim metrics-server-deployment.yaml按图中添加下面选项hostNetwork: trueimage: registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-server-amd64:v0.3.6args:- --kubelet-insecure-tls- --kubelet-preferred-address-types=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP</code></pre><p><a href="https://img-blog.csdnimg.cn/bb1ed2eb05d34fb9832efb34ef312b22.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/bb1ed2eb05d34fb9832efb34ef312b22.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><pre><code># 安装metrics-server[root@k8s-master01 1.8+]# kubectl apply -f ./# 查看pod运行情况[root@k8s-master01 1.8+]# kubectl get pod -n kube-systemmetrics-server-6b976979db-2xwbj   1/1     Running   0          90s# 使用kubectl top node 查看资源使用情况[root@k8s-master01 1.8+]# kubectl top nodeNAME           CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%k8s-master01   289m         14%    1582Mi          54%       k8s-node01     81m          4%     1195Mi          40%       k8s-node02     72m          3%     1211Mi          41%  [root@k8s-master01 1.8+]# kubectl top pod -n kube-systemNAME                              CPU(cores)   MEMORY(bytes)coredns-6955765f44-7ptsb          3m           9Micoredns-6955765f44-vcwr5          3m           8Mietcd-master                       14m          145Mi...# 至此,metrics-server安装完成</code></pre><p>2 准备deployment和servie</p><p>创建pc-hpa-pod.yaml文件，内容如下：</p><pre><code>apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx  namespace: devspec:  strategy: # 策略    type: RollingUpdate # 滚动更新策略  replicas: 1  selector:    matchLabels:      app: nginx-pod  template:    metadata:      labels:        app: nginx-pod    spec:      containers:      - name: nginx        image: nginx:1.17.1        resources: # 资源配额          limits:  # 限制资源（上限）            cpu: &quot;1&quot; # CPU限制，单位是core数          requests: # 请求资源（下限）            cpu: &quot;100m&quot;  # CPU限制，单位是core数# 创建service[root@k8s-master01 1.8+]# kubectl expose deployment nginx --type=NodePort --port=80 -n dev# 查看[root@k8s-master01 1.8+]# kubectl get deployment,pod,svc -n devNAME                    READY   UP-TO-DATE   AVAILABLE   AGEdeployment.apps/nginx   1/1     1            1           47sNAME                         READY   STATUS    RESTARTS   AGEpod/nginx-7df9756ccc-bh8dr   1/1     Running   0          47sNAME            TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGEservice/nginx   NodePort   10.101.18.29   &lt;none&gt;        80:31830/TCP   35s</code></pre><p>3 部署HPA</p><p>创建pc-hpa.yaml文件，内容如下：</p><pre><code>apiVersion: autoscaling/v1kind: HorizontalPodAutoscalermetadata:  name: pc-hpa  namespace: devspec:  minReplicas: 1  #最小pod数量  maxReplicas: 10 #最大pod数量  targetCPUUtilizationPercentage: 3 # CPU使用率指标  scaleTargetRef:   # 指定要控制的nginx信息    apiVersion: apps/v1    kind: Deployment    name: nginx# 创建hpa[root@k8s-master01 1.8+]# kubectl create -f pc-hpa.yamlhorizontalpodautoscaler.autoscaling/pc-hpa created# 查看hpa    [root@k8s-master01 1.8+]# kubectl get hpa -n devNAME     REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGEpc-hpa   Deployment/nginx   0%/3%     1         10        1          62s</code></pre><p>4 测试</p><p>使用压测工具对service地址192.168.5.4:31830进行压测，然后通过控制台查看hpa和pod的变化</p><p>hpa变化</p><pre><code>[root@k8s-master01 ~]# kubectl get hpa -n dev -wNAME   REFERENCE      TARGETS  MINPODS  MAXPODS  REPLICAS  AGEpc-hpa  Deployment/nginx  0%/3%   1     10     1      4m11spc-hpa  Deployment/nginx  0%/3%   1     10     1      5m19spc-hpa  Deployment/nginx  22%/3%   1     10     1      6m50spc-hpa  Deployment/nginx  22%/3%   1     10     4      7m5spc-hpa  Deployment/nginx  22%/3%   1     10     8      7m21spc-hpa  Deployment/nginx  6%/3%   1     10     8      7m51spc-hpa  Deployment/nginx  0%/3%   1     10     8      9m6spc-hpa  Deployment/nginx  0%/3%   1     10     8      13mpc-hpa  Deployment/nginx  0%/3%   1     10     1      14m</code></pre><p>deployment变化</p><pre><code>[root@k8s-master01 ~]# kubectl get deployment -n dev -wNAME    READY   UP-TO-DATE   AVAILABLE   AGEnginx   1/1     1            1           11mnginx   1/4     1            1           13mnginx   1/4     1            1           13mnginx   1/4     1            1           13mnginx   1/4     4            1           13mnginx   1/8     4            1           14mnginx   1/8     4            1           14mnginx   1/8     4            1           14mnginx   1/8     8            1           14mnginx   2/8     8            2           14mnginx   3/8     8            3           14mnginx   4/8     8            4           14mnginx   5/8     8            5           14mnginx   6/8     8            6           14mnginx   7/8     8            7           14mnginx   8/8     8            8           15mnginx   8/1     8            8           20mnginx   8/1     8            8           20mnginx   1/1     1            1           20m</code></pre><p>pod变化</p><pre><code>[root@k8s-master01 ~]# kubectl get pods -n dev -wNAME                     READY   STATUS    RESTARTS   AGEnginx-7df9756ccc-bh8dr   1/1     Running   0          11mnginx-7df9756ccc-cpgrv   0/1     Pending   0          0snginx-7df9756ccc-8zhwk   0/1     Pending   0          0snginx-7df9756ccc-rr9bn   0/1     Pending   0          0snginx-7df9756ccc-cpgrv   0/1     ContainerCreating   0          0snginx-7df9756ccc-8zhwk   0/1     ContainerCreating   0          0snginx-7df9756ccc-rr9bn   0/1     ContainerCreating   0          0snginx-7df9756ccc-m9gsj   0/1     Pending             0          0snginx-7df9756ccc-g56qb   0/1     Pending             0          0snginx-7df9756ccc-sl9c6   0/1     Pending             0          0snginx-7df9756ccc-fgst7   0/1     Pending             0          0snginx-7df9756ccc-g56qb   0/1     ContainerCreating   0          0snginx-7df9756ccc-m9gsj   0/1     ContainerCreating   0          0snginx-7df9756ccc-sl9c6   0/1     ContainerCreating   0          0snginx-7df9756ccc-fgst7   0/1     ContainerCreating   0          0snginx-7df9756ccc-8zhwk   1/1     Running             0          19snginx-7df9756ccc-rr9bn   1/1     Running             0          30snginx-7df9756ccc-m9gsj   1/1     Running             0          21snginx-7df9756ccc-cpgrv   1/1     Running             0          47snginx-7df9756ccc-sl9c6   1/1     Running             0          33snginx-7df9756ccc-g56qb   1/1     Running             0          48snginx-7df9756ccc-fgst7   1/1     Running             0          66snginx-7df9756ccc-fgst7   1/1     Terminating         0          6m50snginx-7df9756ccc-8zhwk   1/1     Terminating         0          7m5snginx-7df9756ccc-cpgrv   1/1     Terminating         0          7m5snginx-7df9756ccc-g56qb   1/1     Terminating         0          6m50snginx-7df9756ccc-rr9bn   1/1     Terminating         0          7m5snginx-7df9756ccc-m9gsj   1/1     Terminating         0          6m50snginx-7df9756ccc-sl9c6   1/1     Terminating         0          6m50s</code></pre><p>6.5 DaemonSet(DS)</p><p>DaemonSet类型的控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。也就是说，如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。<br><a href="https://img-blog.csdnimg.cn/f32acd3f77cc4085a26c0e8c1a0ac6ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/f32acd3f77cc4085a26c0e8c1a0ac6ad.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>DaemonSet控制器的特点：</p><ul><li>每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上</li><li>当节点从集群中移除时，Pod 也就被垃圾回收了</li></ul><p>下面先来看下DaemonSet的资源清单文件</p><pre><code>apiVersion: apps/v1 # 版本号kind: DaemonSet # 类型       metadata: # 元数据  name: # rs名称   namespace: # 所属命名空间   labels: #标签    controller: daemonsetspec: # 详情描述  revisionHistoryLimit: 3 # 保留历史版本  updateStrategy: # 更新策略    type: RollingUpdate # 滚动更新策略    rollingUpdate: # 滚动更新      maxUnavailable: 1 # 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数  selector: # 选择器，通过它指定该控制器管理哪些pod    matchLabels:      # Labels匹配规则      app: nginx-pod    matchExpressions: # Expressions匹配规则      - {key: app, operator: In, values: [nginx-pod]}  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本    metadata:      labels:        app: nginx-pod    spec:      containers:      - name: nginx        image: nginx:1.17.1        ports:        - containerPort: 80</code></pre><p>创建pc-daemonset.yaml，内容如下：</p><pre><code>apiVersion: apps/v1kind: DaemonSet      metadata:  name: pc-daemonset  namespace: devspec:   selector:    matchLabels:      app: nginx-pod  template:    metadata:      labels:        app: nginx-pod    spec:      containers:      - name: nginx        image: nginx:1.17.1# 创建daemonset[root@k8s-master01 ~]# kubectl create -f  pc-daemonset.yamldaemonset.apps/pc-daemonset created# 查看daemonset[root@k8s-master01 ~]#  kubectl get ds -n dev -o wideNAME        DESIRED  CURRENT  READY  UP-TO-DATE  AVAILABLE   AGE   CONTAINERS   IMAGES         pc-daemonset   2        2        2      2           2        24s   nginx        nginx:1.17.1   # 查看pod,发现在每个Node上都运行一个pod[root@k8s-master01 ~]#  kubectl get pods -n dev -o wideNAME                 READY   STATUS    RESTARTS   AGE   IP            NODE    pc-daemonset-9bck8   1/1     Running   0          37s   10.244.1.43   node1     pc-daemonset-k224w   1/1     Running   0          37s   10.244.2.74   node2      # 删除daemonset[root@k8s-master01 ~]# kubectl delete -f pc-daemonset.yamldaemonset.apps &quot;pc-daemonset&quot; deleted</code></pre><p>6.6 Job</p><p>Job，主要用于负责批量处理(一次要处理指定数量任务)短暂的一次性(每个任务仅运行一次就结束)任务。Job特点如下：</p><ul><li>当Job创建的pod执行成功结束时，Job将记录成功结束的pod数量</li><li>当成功结束的pod达到指定的数量时，Job将完成执行</li></ul><p>Job的资源清单文件：<br><a href="https://img-blog.csdnimg.cn/ac5385bbeadf4db1af7b567640a902e2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/ac5385bbeadf4db1af7b567640a902e2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><pre><code>apiVersion: batch/v1 # 版本号kind: Job # 类型       metadata: # 元数据  name: # rs名称   namespace: # 所属命名空间   labels: #标签    controller: jobspec: # 详情描述  completions: 1 # 指定job需要成功运行Pods的次数。默认值: 1  parallelism: 1 # 指定job在任一时刻应该并发运行Pods的数量。默认值: 1  activeDeadlineSeconds: 30 # 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。  backoffLimit: 6 # 指定job失败后进行重试的次数。默认是6  manualSelector: true # 是否可以使用selector选择器选择pod，默认是false  selector: # 选择器，通过它指定该控制器管理哪些pod    matchLabels:      # Labels匹配规则      app: counter-pod    matchExpressions: # Expressions匹配规则      - {key: app, operator: In, values: [counter-pod]}  template: # 模板，当副本数量不足时，会根据下面的模板创建pod副本    metadata:      labels:        app: counter-pod    spec:      restartPolicy: Never # 重启策略只能设置为Never或者OnFailure      containers:      - name: counter        image: busybox:1.30        command: [&quot;bin/sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 2;done&quot;]关于重启策略设置的说明：    如果指定为OnFailure，则job会在pod出现故障时重启容器，而不是创建pod，failed次数不变    如果指定为Never，则job会在pod出现故障时创建新的pod，并且故障pod不会消失，也不会重启，failed次数加1    如果指定为Always的话，就意味着一直重启，意味着job任务会重复去执行了，当然不对，所以不能设置为Always</code></pre><p>创建pc-job.yaml，内容如下：</p><pre><code>apiVersion: batch/v1kind: Job      metadata:  name: pc-job  namespace: devspec:  manualSelector: true  selector:    matchLabels:      app: counter-pod  template:    metadata:      labels:        app: counter-pod    spec:      restartPolicy: Never      containers:      - name: counter        image: busybox:1.30        command: [&quot;bin/sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;]# 创建job[root@k8s-master01 ~]# kubectl create -f pc-job.yamljob.batch/pc-job created# 查看job[root@k8s-master01 ~]# kubectl get job -n dev -o wide  -wNAME     COMPLETIONS   DURATION   AGE   CONTAINERS   IMAGES         SELECTORpc-job   0/1           21s        21s   counter      busybox:1.30   app=counter-podpc-job   1/1           31s        79s   counter      busybox:1.30   app=counter-pod# 通过观察pod状态可以看到，pod在运行完毕任务后，就会变成Completed状态[root@k8s-master01 ~]# kubectl get pods -n dev -wNAME           READY   STATUS     RESTARTS      AGEpc-job-rxg96   1/1     Running     0            29spc-job-rxg96   0/1     Completed   0            33s# 接下来，调整下pod运行的总数量和并行数量 即：在spec下设置下面两个选项#  completions: 6 # 指定job需要成功运行Pods的次数为6#  parallelism: 3 # 指定job并发运行Pods的数量为3#  然后重新运行job，观察效果，此时会发现，job会每次运行3个pod，总共执行了6个pod[root@k8s-master01 ~]# kubectl get pods -n dev -wNAME           READY   STATUS    RESTARTS   AGEpc-job-684ft   1/1     Running   0          5spc-job-jhj49   1/1     Running   0          5spc-job-pfcvh   1/1     Running   0          5spc-job-684ft   0/1     Completed   0          11spc-job-v7rhr   0/1     Pending     0          0spc-job-v7rhr   0/1     Pending     0          0spc-job-v7rhr   0/1     ContainerCreating   0          0spc-job-jhj49   0/1     Completed           0          11spc-job-fhwf7   0/1     Pending             0          0spc-job-fhwf7   0/1     Pending             0          0spc-job-pfcvh   0/1     Completed           0          11spc-job-5vg2j   0/1     Pending             0          0spc-job-fhwf7   0/1     ContainerCreating   0          0spc-job-5vg2j   0/1     Pending             0          0spc-job-5vg2j   0/1     ContainerCreating   0          0spc-job-fhwf7   1/1     Running             0          2spc-job-v7rhr   1/1     Running             0          2spc-job-5vg2j   1/1     Running             0          3spc-job-fhwf7   0/1     Completed           0          12spc-job-v7rhr   0/1     Completed           0          12spc-job-5vg2j   0/1     Completed           0          12s# 删除job[root@k8s-master01 ~]# kubectl delete -f pc-job.yamljob.batch &quot;pc-job&quot; deleted</code></pre><p>6.7 CronJob(CJ)</p><p>CronJob控制器以Job控制器资源为其管控对象，并借助它管理pod资源对象，Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以以类似于Linux操作系统的周期性任务作业计划的方式控制其运行时间点及重复运行的方式。也就是说，CronJob可以在特定的时间点(反复的)去运行job任务。</p><p><a href="https://img-blog.csdnimg.cn/eb93bb356c9845f28848d5f1a9ece14c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/eb93bb356c9845f28848d5f1a9ece14c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>CronJob的资源清单文件：</p><pre><code>apiVersion: batch/v1beta1 # 版本号kind: CronJob # 类型       metadata: # 元数据  name: # rs名称   namespace: # 所属命名空间   labels: #标签    controller: cronjobspec: # 详情描述  schedule: # cron格式的作业调度运行时间点,用于控制任务在什么时间执行  concurrencyPolicy: # 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业  failedJobHistoryLimit: # 为失败的任务执行保留的历史记录数，默认为1  successfulJobHistoryLimit: # 为成功的任务执行保留的历史记录数，默认为3  startingDeadlineSeconds: # 启动作业错误的超时时长  jobTemplate: # job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义    metadata:    spec:      completions: 1      parallelism: 1      activeDeadlineSeconds: 30      backoffLimit: 6      manualSelector: true      selector:        matchLabels:          app: counter-pod        matchExpressions: 规则          - {key: app, operator: In, values: [counter-pod]}      template:        metadata:          labels:            app: counter-pod        spec:          restartPolicy: Never           containers:          - name: counter            image: busybox:1.30            command: [&quot;bin/sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 20;done&quot;]需要重点解释的几个选项：schedule: cron表达式，用于指定任务的执行时间    */1    *      *    *     *    &lt;分钟&gt; &lt;小时&gt; &lt;日&gt; &lt;月份&gt; &lt;星期&gt;    分钟 值从 0 到 59.    小时 值从 0 到 23.    日 值从 1 到 31.    月 值从 1 到 12.    星期 值从 0 到 6, 0 代表星期日    多个时间可以用逗号隔开； 范围可以用连字符给出；*可以作为通配符； /表示每...concurrencyPolicy:    Allow:   允许Jobs并发运行(默认)    Forbid:  禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行    Replace: 替换，取消当前正在运行的作业并用新作业替换它</code></pre><p>创建pc-cronjob.yaml，内容如下：</p><pre><code>apiVersion: batch/v1beta1kind: CronJobmetadata:  name: pc-cronjob  namespace: dev  labels:    controller: cronjobspec:  schedule: &quot;*/1 * * * *&quot;  jobTemplate:    metadata:    spec:      template:        spec:          restartPolicy: Never          containers:          - name: counter            image: busybox:1.30            command: [&quot;bin/sh&quot;,&quot;-c&quot;,&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;]# 创建cronjob[root@k8s-master01 ~]# kubectl create -f pc-cronjob.yamlcronjob.batch/pc-cronjob created# 查看cronjob[root@k8s-master01 ~]# kubectl get cronjobs -n devNAME         SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGEpc-cronjob   */1 * * * *   False     0        &lt;none&gt;          6s# 查看job[root@k8s-master01 ~]# kubectl get jobs -n devNAME                    COMPLETIONS   DURATION   AGEpc-cronjob-1592587800   1/1           28s        3m26spc-cronjob-1592587860   1/1           28s        2m26spc-cronjob-1592587920   1/1           28s        86s# 查看pod[root@k8s-master01 ~]# kubectl get pods -n devpc-cronjob-1592587800-x4tsm   0/1     Completed   0          2m24spc-cronjob-1592587860-r5gv4   0/1     Completed   0          84spc-cronjob-1592587920-9dxxq   1/1     Running     0          24s</code></pre><p>​<br>    # 删除cronjob<br>    [root@k8s-master01 ~]# kubectl  delete -f pc-cronjob.yaml<br>    cronjob.batch “pc-cronjob” deleted</p><ol start="7"><li>Service详解</li></ol><p>7.1 Service介绍</p><p>在kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是pod的ip地址不是固定的，这也就意味着不方便直接采用pod的ip对服务进行访问。</p><p>为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个pod进行聚合，并且提供一个统一的入口地址。通过访问Service的入口地址就能访问到后面的pod服务。<br><a href="https://img-blog.csdnimg.cn/46951c9d8e8d453baabb4e50028b0881.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/46951c9d8e8d453baabb4e50028b0881.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后它会将最新的Service信息转换成对应的访问规则。</p><p><a href="https://img-blog.csdnimg.cn/4ffdb68fcb5e44f8b52a02c621a317a8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/4ffdb68fcb5e44f8b52a02c621a317a8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><pre><code># 10.97.97.97:80 是service提供的访问入口# 当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用，# kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去# 这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点上访问都可以。[root@node1 ~]# ipvsadm -LnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  10.97.97.97:80 rr  -&gt; 10.244.1.39:80               Masq    1      0          0  -&gt; 10.244.1.40:80               Masq    1      0          0  -&gt; 10.244.2.33:80               Masq    1      0          0</code></pre><p>kube-proxy目前支持三种工作模式:</p><p>userspace 模式</p><p>userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。  该模式下，kube-proxy充当了一个四层负责均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。<br><a href="https://img-blog.csdnimg.cn/3941b35a5b604083ad09cc1ec8076615.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/3941b35a5b604083ad09cc1ec8076615.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>iptables 模式</p><p>iptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。  该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。</p><p><a href="https://img-blog.csdnimg.cn/5f3f9c466b7545f28ccf696c0ea2cfcb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/5f3f9c466b7545f28ccf696c0ea2cfcb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>ipvs 模式</p><p>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。</p><p><a href="https://img-blog.csdnimg.cn/064732407b184c79a267f7bf5bf2e2b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/064732407b184c79a267f7bf5bf2e2b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><pre><code># 此模式必须安装ipvs内核模块，否则会降级为iptables# 开启ipvs[root@k8s-master01 ~]# kubectl edit cm kube-proxy -n kube-system# 修改mode: &quot;ipvs&quot;[root@k8s-master01 ~]# kubectl delete pod -l k8s-app=kube-proxy -n kube-system[root@node1 ~]# ipvsadm -LnIP Virtual Server version 1.2.1 (size=4096)Prot LocalAddress:Port Scheduler Flags  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConnTCP  10.97.97.97:80 rr  -&gt; 10.244.1.39:80               Masq    1      0          0  -&gt; 10.244.1.40:80               Masq    1      0          0  -&gt; 10.244.2.33:80               Masq    1      0          0</code></pre><p>7.2 Service类型</p><p>Service的资源清单文件：</p><pre><code>kind: Service  # 资源类型apiVersion: v1  # 资源版本metadata: # 元数据  name: service # 资源名称  namespace: dev # 命名空间spec: # 描述  selector: # 标签选择器，用于确定当前service代理哪些pod    app: nginx  type: # Service类型，指定service的访问方式  clusterIP:  # 虚拟服务的ip地址  sessionAffinity: # session亲和性，支持ClientIP、None两个选项  ports: # 端口信息    - protocol: TCP       port: 3017  # service端口      targetPort: 5003 # pod端口      nodePort: 31122 # 主机端口</code></pre><ul><li>ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问</li><li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务</li><li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持</li><li>ExternalName： 把集群外部的服务引入集群内部，直接使用</li></ul><p>7.3 Service使用</p><p>7.3.1 实验环境准备</p><p>在使用service之前，首先利用Deployment创建出3个pod，注意要为pod设置app=nginx-pod的标签</p><p>创建deployment.yaml，内容如下：</p><pre><code>apiVersion: apps/v1kind: Deployment      metadata:  name: pc-deployment  namespace: devspec:   replicas: 3  selector:    matchLabels:      app: nginx-pod  template:    metadata:      labels:        app: nginx-pod    spec:      containers:      - name: nginx        image: nginx:1.17.1        ports:        - containerPort: 80[root@k8s-master01 ~]# kubectl create -f deployment.yamldeployment.apps/pc-deployment created# 查看pod详情[root@k8s-master01 ~]# kubectl get pods -n dev -o wide --show-labelsNAME                             READY   STATUS     IP            NODE     LABELSpc-deployment-66cb59b984-8p84h   1/1     Running    10.244.1.39   node1    app=nginx-podpc-deployment-66cb59b984-vx8vx   1/1     Running    10.244.2.33   node2    app=nginx-podpc-deployment-66cb59b984-wnncx   1/1     Running    10.244.1.40   node1    app=nginx-pod# 为了方便后面的测试，修改下三台nginx的index.html页面（三台修改的IP地址不一致）# kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh# echo &quot;10.244.1.39&quot; &gt; /usr/share/nginx/html/index.html#修改完毕之后，访问测试[root@k8s-master01 ~]# curl 10.244.1.3910.244.1.39[root@k8s-master01 ~]# curl 10.244.2.3310.244.2.33[root@k8s-master01 ~]# curl 10.244.1.4010.244.1.40</code></pre><p>7.3.2 ClusterIP类型的Service</p><p>创建service-clusterip.yaml文件</p><pre><code>apiVersion: v1kind: Servicemetadata:  name: service-clusterip  namespace: devspec:  selector:    app: nginx-pod  clusterIP: 10.97.97.97 # service的ip地址，如果不写，默认会生成一个  type: ClusterIP  ports:  - port: 80  # Service端口           targetPort: 80 # pod端口# 创建service[root@k8s-master01 ~]# kubectl create -f service-clusterip.yamlservice/service-clusterip created# 查看service[root@k8s-master01 ~]# kubectl get svc -n dev -o wideNAME                TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE   SELECTORservice-clusterip   ClusterIP   10.97.97.97   &lt;none&gt;        80/TCP    13s   app=nginx-pod# 查看service的详细信息# 在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口[root@k8s-master01 ~]# kubectl describe svc service-clusterip -n devName:              service-clusteripNamespace:         devLabels:            &lt;none&gt;Annotations:       &lt;none&gt;Selector:          app=nginx-podType:              ClusterIPIP:                10.97.97.97Port:              &lt;unset&gt;  80/TCPTargetPort:        80/TCPEndpoints:         10.244.1.39:80,10.244.1.40:80,10.244.2.33:80Session Affinity:  NoneEvents:            &lt;none&gt;# 查看ipvs的映射规则[root@k8s-master01 ~]# ipvsadm -LnTCP  10.97.97.97:80 rr  -&gt; 10.244.1.39:80               Masq    1      0          0  -&gt; 10.244.1.40:80               Masq    1      0          0  -&gt; 10.244.2.33:80               Masq    1      0          0# 访问10.97.97.97:80观察效果[root@k8s-master01 ~]# curl 10.97.97.97:8010.244.2.33</code></pre><p>Endpoint</p><p>Endpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。</p><p>一个Service由一组Pod组成，这些Pod通过Endpoints暴露出来，Endpoints是实现实际服务的端点集合。换句话说，service和pod之间的联系是通过endpoints实现的。<br><a href="https://img-blog.csdnimg.cn/d824c5c112c24eb180697898f6115818.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/d824c5c112c24eb180697898f6115818.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>负载分发策略</p><p>对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略：</p><ul><li><p>如果不定义，默认使用kube-proxy的策略，比如随机、轮询</p></li><li><p>基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个Pod上<br>此模式可以使在spec中添加sessionAffinity:ClientIP选项</p><h1 id="查看ipvs的映射规则【rr-轮询】"><a href="#查看ipvs的映射规则【rr-轮询】" class="headerlink" title="查看ipvs的映射规则【rr 轮询】"></a>查看ipvs的映射规则【rr 轮询】</h1><p>  [root@k8s-master01 ~]# ipvsadm -Ln<br>  TCP  10.97.97.97:80 rr</p><pre><code>-&gt; 10.244.1.39:80               Masq    1      0          0-&gt; 10.244.1.40:80               Masq    1      0          0-&gt; 10.244.2.33:80               Masq    1      0          0</code></pre><h1 id="循环访问测试"><a href="#循环访问测试" class="headerlink" title="循环访问测试"></a>循环访问测试</h1><p>  [root@k8s-master01 ~]# while true;do curl 10.97.97.97:80; sleep 5; done;<br>  10.244.1.40<br>  10.244.1.39<br>  10.244.2.33<br>  10.244.1.40<br>  10.244.1.39<br>  10.244.2.33</p><h1 id="修改分发策略—-sessionAffinity-ClientIP"><a href="#修改分发策略—-sessionAffinity-ClientIP" class="headerlink" title="修改分发策略—-sessionAffinity:ClientIP"></a>修改分发策略—-sessionAffinity:ClientIP</h1><h1 id="查看ipvs规则【persistent-代表持久】"><a href="#查看ipvs规则【persistent-代表持久】" class="headerlink" title="查看ipvs规则【persistent 代表持久】"></a>查看ipvs规则【persistent 代表持久】</h1><p>  [root@k8s-master01 ~]# ipvsadm -Ln<br>  TCP  10.97.97.97:80 rr persistent 10800</p><pre><code>-&gt; 10.244.1.39:80               Masq    1      0          0-&gt; 10.244.1.40:80               Masq    1      0          0-&gt; 10.244.2.33:80               Masq    1      0          0</code></pre><h1 id="循环访问测试-1"><a href="#循环访问测试-1" class="headerlink" title="循环访问测试"></a>循环访问测试</h1><p>  [root@k8s-master01 ~]# while true;do curl 10.97.97.97; sleep 5; done;<br>  10.244.2.33<br>  10.244.2.33<br>  10.244.2.33</p><h1 id="删除service"><a href="#删除service" class="headerlink" title="删除service"></a>删除service</h1><p>  [root@k8s-master01 ~]# kubectl delete -f service-clusterip.yaml<br>  service “service-clusterip” deleted</p></li></ul><p>7.3.3 HeadLiness类型的Service</p><p>在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，针对这种情况，kubernetes提供了HeadLiness Service，这类Service不会分配Cluster IP，如果想要访问service，只能通过service的域名进行查询。</p><p>创建service-headliness.yaml</p><pre><code>apiVersion: v1kind: Servicemetadata:  name: service-headliness  namespace: devspec:  selector:    app: nginx-pod  clusterIP: None # 将clusterIP设置为None，即可创建headliness Service  type: ClusterIP  ports:  - port: 80        targetPort: 80# 创建service[root@k8s-master01 ~]# kubectl create -f service-headliness.yamlservice/service-headliness created# 获取service， 发现CLUSTER-IP未分配[root@k8s-master01 ~]# kubectl get svc service-headliness -n dev -o wideNAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE   SELECTORservice-headliness   ClusterIP   None         &lt;none&gt;        80/TCP    11s   app=nginx-pod# 查看service详情[root@k8s-master01 ~]# kubectl describe svc service-headliness  -n devName:              service-headlinessNamespace:         devLabels:            &lt;none&gt;Annotations:       &lt;none&gt;Selector:          app=nginx-podType:              ClusterIPIP:                NonePort:              &lt;unset&gt;  80/TCPTargetPort:        80/TCPEndpoints:         10.244.1.39:80,10.244.1.40:80,10.244.2.33:80Session Affinity:  NoneEvents:            &lt;none&gt;# 查看域名的解析情况[root@k8s-master01 ~]# kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh/ # cat /etc/resolv.confnameserver 10.96.0.10search dev.svc.cluster.local svc.cluster.local cluster.local[root@k8s-master01 ~]# dig @10.96.0.10 service-headliness.dev.svc.cluster.localservice-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.40service-headliness.dev.svc.cluster.local. 30 IN A 10.244.1.39service-headliness.dev.svc.cluster.local. 30 IN A 10.244.2.33</code></pre><p>7.3.4 NodePort类型的Service</p><p>在之前的样例中，创建的Service的ip地址只有集群内部才可以访问，如果希望将Service暴露给集群外部使用，那么就要使用到另外一种类型的Service，称为NodePort类型。NodePort的工作原理其实就是将service的端口映射到Node的一个端口上，然后就可以通过NodeIp:NodePort来访问service了。</p><p><a href="https://img-blog.csdnimg.cn/9fba088978554d249e4f5cce034b9c33.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/9fba088978554d249e4f5cce034b9c33.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>创建service-nodeport.yaml</p><pre><code>apiVersion: v1kind: Servicemetadata:  name: service-nodeport  namespace: devspec:  selector:    app: nginx-pod  type: NodePort # service类型  ports:  - port: 80    nodePort: 30002 # 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配    targetPort: 80# 创建service[root@k8s-master01 ~]# kubectl create -f service-nodeport.yamlservice/service-nodeport created# 查看service[root@k8s-master01 ~]# kubectl get svc -n dev -o wideNAME               TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)       SELECTORservice-nodeport   NodePort   10.105.64.191   &lt;none&gt;        80:30002/TCP  app=nginx-pod# 接下来可以通过电脑主机的浏览器去访问集群中任意一个nodeip的30002端口，即可访问到pod</code></pre><p>7.3.5 LoadBalancer类型的Service</p><p>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。<br><a href="https://img-blog.csdnimg.cn/a7e29eb5d7ca4553a76e8c429901c5f6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/a7e29eb5d7ca4553a76e8c429901c5f6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>7.3.6 ExternalName类型的Service</p><p>ExternalName类型的Service用于引入集群外部的服务，它通过externalName属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。<br><a href="https://img-blog.csdnimg.cn/2803e2c8c0624539ad2f9bad617eba7b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2803e2c8c0624539ad2f9bad617eba7b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><pre><code>apiVersion: v1kind: Servicemetadata:  name: service-externalname  namespace: devspec:  type: ExternalName # service类型  externalName: www.baidu.com  #改成ip地址也可以# 创建service[root@k8s-master01 ~]# kubectl  create -f service-externalname.yamlservice/service-externalname created# 域名解析[root@k8s-master01 ~]# dig @10.96.0.10 service-externalname.dev.svc.cluster.localservice-externalname.dev.svc.cluster.local. 30 IN CNAME www.baidu.com.www.baidu.com.          30      IN      CNAME   www.a.shifen.com.www.a.shifen.com.       30      IN      A       39.156.66.18www.a.shifen.com.       30      IN      A       39.156.66.14</code></pre><p>7.4 Ingress介绍</p><p>在前面课程中已经提到，Service对集群之外暴露服务的主要方式有两种：NotePort和LoadBalancer，但是这两种方式，都有一定的缺点：</p><ul><li>NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显</li><li>LB方式的缺点是每个service需要一个LB，浪费、麻烦，并且需要kubernetes之外设备的支持</li></ul><p>基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求。工作机制大致如下图表示：</p><p><a href="https://img-blog.csdnimg.cn/9502124d4503456385f52aeae1efbb40.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/9502124d4503456385f52aeae1efbb40.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>实际上，Ingress相当于一个7层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，可以理解成在Ingress里建立诸多映射规则，Ingress Controller通过监听这些配置规则并转化成Nginx的反向代理配置 , 然后对外部提供服务。在这里有两个核心概念：</p><ul><li>ingress：kubernetes中的一个对象，作用是定义请求如何转发到service的规则</li><li>ingress controller：具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发，实现方式有很多，比如Nginx, Contour, Haproxy等等</li></ul><p>Ingress（以Nginx为例）的工作原理如下：</p><ol><li>用户编写Ingress规则，说明哪个域名对应kubernetes集群中的哪个Service</li><li>Ingress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx反向代理配置</li><li>Ingress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新</li><li>到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求转发规则</li></ol><p><a href="https://img-blog.csdnimg.cn/a0eb0c8682924391b2412a90caf093fe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/a0eb0c8682924391b2412a90caf093fe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>7.5 Ingress使用</p><p>7.5.1 环境准备</p><p>搭建ingress环境</p><pre><code># 创建文件夹[root@k8s-master01 ~]# mkdir ingress-controller[root@k8s-master01 ~]# cd ingress-controller/# 获取ingress-nginx，本次案例使用的是0.30版本[root@k8s-master01 ingress-controller]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml[root@k8s-master01 ingress-controller]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml# 修改mandatory.yaml文件中的仓库# 修改quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0# 为quay-mirror.qiniu.com/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0# 创建ingress-nginx[root@k8s-master01 ingress-controller]# kubectl apply -f ./# 查看ingress-nginx[root@k8s-master01 ingress-controller]# kubectl get pod -n ingress-nginxNAME                                           READY   STATUS    RESTARTS   AGEpod/nginx-ingress-controller-fbf967dd5-4qpbp   1/1     Running   0          12h# 查看service[root@k8s-master01 ingress-controller]# kubectl get svc -n ingress-nginxNAME            TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGEingress-nginx   NodePort   10.98.75.163   &lt;none&gt;        80:32240/TCP,443:31335/TCP   11h</code></pre><p>准备service和pod</p><p>为了后面的实验比较方便，创建如下图所示的模型</p><p><a href="https://img-blog.csdnimg.cn/848ab45baba14ebf9b4c09aa5ec21d67.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/848ab45baba14ebf9b4c09aa5ec21d67.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>创建tomcat-nginx.yaml</p><pre><code>apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment  namespace: devspec:  replicas: 3  selector:    matchLabels:      app: nginx-pod  template:    metadata:      labels:        app: nginx-pod    spec:      containers:      - name: nginx        image: nginx:1.17.1        ports:        - containerPort: 80---apiVersion: apps/v1kind: Deploymentmetadata:  name: tomcat-deployment  namespace: devspec:  replicas: 3  selector:    matchLabels:      app: tomcat-pod  template:    metadata:      labels:        app: tomcat-pod    spec:      containers:      - name: tomcat        image: tomcat:8.5-jre10-slim        ports:        - containerPort: 8080---apiVersion: v1kind: Servicemetadata:  name: nginx-service  namespace: devspec:  selector:    app: nginx-pod  clusterIP: None  type: ClusterIP  ports:  - port: 80    targetPort: 80---apiVersion: v1kind: Servicemetadata:  name: tomcat-service  namespace: devspec:  selector:    app: tomcat-pod  clusterIP: None  type: ClusterIP  ports:  - port: 8080    targetPort: 8080# 创建[root@k8s-master01 ~]# kubectl create -f tomcat-nginx.yaml# 查看[root@k8s-master01 ~]# kubectl get svc -n devNAME             TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGEnginx-service    ClusterIP   None         &lt;none&gt;        80/TCP     48stomcat-service   ClusterIP   None         &lt;none&gt;        8080/TCP   48s</code></pre><p>7.5.2 Http代理</p><p>创建ingress-http.yaml</p><pre><code>apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: ingress-http  namespace: devspec:  rules:  - host: nginx.itheima.com    http:      paths:      - path: /        backend:          serviceName: nginx-service          servicePort: 80  - host: tomcat.itheima.com    http:      paths:      - path: /        backend:          serviceName: tomcat-service          servicePort: 8080# 创建[root@k8s-master01 ~]# kubectl create -f ingress-http.yamlingress.extensions/ingress-http created# 查看[root@k8s-master01 ~]# kubectl get ing ingress-http -n devNAME           HOSTS                                  ADDRESS   PORTS   AGEingress-http   nginx.itheima.com,tomcat.itheima.com             80      22s# 查看详情[root@k8s-master01 ~]# kubectl describe ing ingress-http  -n dev...Rules:Host                Path  Backends----                ----  --------nginx.itheima.com   / nginx-service:80 (10.244.1.96:80,10.244.1.97:80,10.244.2.112:80)tomcat.itheima.com  / tomcat-service:8080(10.244.1.94:8080,10.244.1.95:8080,10.244.2.111:8080)...# 接下来,在本地电脑上配置host文件,解析上面的两个域名到192.168.109.100(master)上# 然后,就可以分别访问tomcat.itheima.com:32240  和  nginx.itheima.com:32240 查看效果了</code></pre><p>7.5.3 Https代理</p><p>创建证书</p><pre><code># 生成证书openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj &quot;/C=CN/ST=BJ/L=BJ/O=nginx/CN=itheima.com&quot;# 创建密钥kubectl create secret tls tls-secret --key tls.key --cert tls.crt</code></pre><p>创建ingress-https.yaml</p><pre><code>apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: ingress-https  namespace: devspec:  tls:    - hosts:      - nginx.itheima.com      - tomcat.itheima.com      secretName: tls-secret # 指定秘钥  rules:  - host: nginx.itheima.com    http:      paths:      - path: /        backend:          serviceName: nginx-service          servicePort: 80  - host: tomcat.itheima.com    http:      paths:      - path: /        backend:          serviceName: tomcat-service          servicePort: 8080# 创建[root@k8s-master01 ~]# kubectl create -f ingress-https.yamlingress.extensions/ingress-https created# 查看[root@k8s-master01 ~]# kubectl get ing ingress-https -n devNAME            HOSTS                                  ADDRESS         PORTS     AGEingress-https   nginx.itheima.com,tomcat.itheima.com   10.104.184.38   80, 443   2m42s# 查看详情[root@k8s-master01 ~]# kubectl describe ing ingress-https -n dev...TLS:  tls-secret terminates nginx.itheima.com,tomcat.itheima.comRules:Host              Path Backends----              ---- --------nginx.itheima.com  /  nginx-service:80 (10.244.1.97:80,10.244.1.98:80,10.244.2.119:80)tomcat.itheima.com /  tomcat-service:8080(10.244.1.99:8080,10.244.2.117:8080,10.244.2.120:8080)...# 下面可以通过浏览器访问https://nginx.itheima.com:31335 和 https://tomcat.itheima.com:31335来查看了</code></pre><ol start="8"><li>数据存储</li></ol><p>在前面已经提到，容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes引入了Volume的概念。</p><p>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命容器不与Pod中单个容器的生命周期相关，当容器终止或者重启时，Volume中的数据也不会丢失。</p><p>kubernetes的Volume支持多种类型，比较常见的有下面几个：</p><ul><li>简单存储：EmptyDir、HostPath、NFS</li><li>高级存储：PV、PVC</li><li>配置存储：ConfigMap、Secret</li></ul><p>8.1 基本存储</p><p>8.1.1 EmptyDir</p><p>EmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录。</p><p>EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时， EmptyDir中的数据也会被永久删除。 EmptyDir用途如下：</p><ul><li>临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留</li><li>一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</li></ul><p>接下来，通过一个容器之间文件共享的案例来使用一下EmptyDir。</p><p>在一个Pod中准备两个容器nginx和busybox，然后声明一个Volume分别挂在到两个容器的目录中，然后nginx容器负责向Volume中写日志，busybox中通过命令将日志内容读到控制台。</p><p><a href="https://img-blog.csdnimg.cn/c6eb5b0133be422c8c730b1a6496b8fc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/c6eb5b0133be422c8c730b1a6496b8fc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>创建一个volume-emptydir.yaml</p><pre><code>apiVersion: v1kind: Podmetadata:  name: volume-emptydir  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    ports:    - containerPort: 80    volumeMounts:  # 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx    - name: logs-volume      mountPath: /var/log/nginx  - name: busybox    image: busybox:1.30    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;tail -f /logs/access.log&quot;] # 初始命令，动态读取指定文件中内容    volumeMounts:  # 将logs-volume 挂在到busybox容器中，对应的目录为 /logs    - name: logs-volume      mountPath: /logs  volumes: # 声明volume， name为logs-volume，类型为emptyDir  - name: logs-volume    emptyDir: {}# 创建Pod[root@k8s-master01 ~]# kubectl create -f volume-emptydir.yamlpod/volume-emptydir created# 查看pod[root@k8s-master01 ~]# kubectl get pods volume-emptydir -n dev -o wideNAME                  READY   STATUS    RESTARTS   AGE      IP       NODE   ...... volume-emptydir       2/2     Running   0          97s   10.42.2.9   node1  ......# 通过podIp访问nginx[root@k8s-master01 ~]# curl 10.42.2.9......# 通过kubectl logs命令查看指定容器的标准输出[root@k8s-master01 ~]# kubectl logs -f volume-emptydir -n dev -c busybox10.42.1.0 - - [27/Jun/2021:15:08:54 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot;</code></pre><p>8.1.2 HostPath</p><p>上节课提到，EmptyDir中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。</p><p>HostPath就是将Node主机中一个实际目录挂在到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依据可以存在于Node主机上。<br><a href="https://img-blog.csdnimg.cn/ca0fb2dcb1a0498fbb4b9d73cf6fcad9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/ca0fb2dcb1a0498fbb4b9d73cf6fcad9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>创建一个volume-hostpath.yaml：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: volume-hostpath  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    ports:    - containerPort: 80    volumeMounts:    - name: logs-volume      mountPath: /var/log/nginx  - name: busybox    image: busybox:1.30    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;tail -f /logs/access.log&quot;]    volumeMounts:    - name: logs-volume      mountPath: /logs  volumes:  - name: logs-volume    hostPath:       path: /root/logs      type: DirectoryOrCreate  # 目录存在就使用，不存在就先创建后使用关于type的值的一点说明：    DirectoryOrCreate 目录存在就使用，不存在就先创建后使用    Directory   目录必须存在    FileOrCreate  文件存在就使用，不存在就先创建后使用    File 文件必须存在     Socket  unix套接字必须存在    CharDevice  字符设备必须存在    BlockDevice 块设备必须存在# 创建Pod[root@k8s-master01 ~]# kubectl create -f volume-hostpath.yamlpod/volume-hostpath created# 查看Pod[root@k8s-master01 ~]# kubectl get pods volume-hostpath -n dev -o wideNAME                  READY   STATUS    RESTARTS   AGE   IP             NODE   ......pod-volume-hostpath   2/2     Running   0          16s   10.42.2.10     node1  ......#访问nginx[root@k8s-master01 ~]# curl 10.42.2.10# 接下来就可以去host的/root/logs目录下查看存储的文件了###  注意: 下面的操作需要到Pod所在的节点运行（案例中是node1）[root@node1 ~]# ls /root/logs/access.log  error.log# 同样的道理，如果在此目录下创建一个文件，到容器中也是可以看到的</code></pre><p>8.1.3 NFS</p><p>HostPath可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用NFS、CIFS。</p><p>NFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样的话，无论Pod在节点上怎么转移，只要Node跟NFS的对接没问题，数据就可以成功访问。</p><p><a href="https://img-blog.csdnimg.cn/64dacf12a7ab4061a1c12ac29e142a24.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/64dacf12a7ab4061a1c12ac29e142a24.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>1）首先要准备nfs的服务器，这里为了简单，直接是master节点做nfs服务器</p><pre><code># 在nfs上安装nfs服务[root@nfs ~]# yum install nfs-utils -y# 准备一个共享目录[root@nfs ~]# mkdir /root/data/nfs -pv# 将共享目录以读写权限暴露给192.168.5.0/24网段中的所有主机[root@nfs ~]# vim /etc/exports[root@nfs ~]# more /etc/exports/root/data/nfs     192.168.5.0/24(rw,no_root_squash)# 启动nfs服务[root@nfs ~]# systemctl restart nfs</code></pre><p>2）接下来，要在的每个node节点上都安装下nfs，这样的目的是为了node节点可以驱动nfs设备</p><pre><code># 在node上安装nfs服务，注意不需要启动[root@k8s-master01 ~]# yum install nfs-utils -y</code></pre><p>3）接下来，就可以编写pod的配置文件了，创建volume-nfs.yaml</p><pre><code>apiVersion: v1kind: Podmetadata:  name: volume-nfs  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    ports:    - containerPort: 80    volumeMounts:    - name: logs-volume      mountPath: /var/log/nginx  - name: busybox    image: busybox:1.30    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;tail -f /logs/access.log&quot;]     volumeMounts:    - name: logs-volume      mountPath: /logs  volumes:  - name: logs-volume    nfs:      server: 192.168.5.6  #nfs服务器地址      path: /root/data/nfs #共享文件路径</code></pre><p>4）最后，运行下pod，观察结果</p><pre><code># 创建pod[root@k8s-master01 ~]# kubectl create -f volume-nfs.yamlpod/volume-nfs created# 查看pod[root@k8s-master01 ~]# kubectl get pods volume-nfs -n devNAME                  READY   STATUS    RESTARTS   AGEvolume-nfs        2/2     Running   0          2m9s# 查看nfs服务器上的共享目录，发现已经有文件了[root@k8s-master01 ~]# ls /root/data/access.log  error.log</code></pre><p>8.2 高级存储</p><p>前面已经学习了使用NFS提供存储，此时就要求用户会搭建NFS系统，并且会在yaml配置nfs。由于kubernetes支持的存储系统有很多，要求客户全都掌握，显然不现实。为了能够屏蔽底层存储实现的细节，方便用户使用， kubernetes引入PV和PVC两种资源对象。</p><p>PV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下PV由kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。</p><p>PVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。<br><a href="https://img-blog.csdnimg.cn/33733ef80cd44edbbae1b9818094d430.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/33733ef80cd44edbbae1b9818094d430.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>使用了PV和PVC之后，工作可以得到进一步的细分：</p><ul><li>存储：存储工程师维护</li><li>PV： kubernetes管理员维护</li><li>PVC：kubernetes用户维护</li></ul><p>8.2.1 PV</p><p>PV是存储资源的抽象，下面是资源清单文件:</p><pre><code>apiVersion: v1  kind: PersistentVolumemetadata:  name: pv2spec:  nfs: # 存储类型，与底层真正存储对应  capacity:  # 存储能力，目前只支持存储空间的设置    storage: 2Gi  accessModes:  # 访问模式  storageClassName: # 存储类别  persistentVolumeReclaimPolicy: # 回收策略</code></pre><p>PV 的关键配置参数说明：</p><ul><li>存储类型<br>底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置都有所差异</li><li>存储能力（capacity）</li></ul><p>目前只支持存储空间的设置( storage=1Gi )，不过未来可能会加入IOPS、吞吐量等指标的配置</p><ul><li>访问模式（accessModes）<br>用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：<ul><li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</li><li>ReadOnlyMany（ROX）： 只读权限，可以被多个节点挂载</li><li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载<br>需要注意的是，底层不同的存储类型可能支持的访问模式不同</li></ul></li><li>回收策略（persistentVolumeReclaimPolicy）<br>当PV不再被使用了之后，对其的处理方式。目前支持三种策略：<ul><li>Retain （保留） 保留数据，需要管理员手工清理数据</li><li>Recycle（回收） 清除 PV 中的数据，效果相当于执行 rm -rf /thevolume/*</li><li>Delete （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务<br>需要注意的是，底层不同的存储类型可能支持的回收策略不同</li></ul></li><li>存储类别<br>PV可以通过storageClassName参数指定一个存储类别<ul><li>具有特定类别的PV只能与请求了该类别的PVC进行绑定</li><li>未设定类别的PV则只能与不请求任何类别的PVC进行绑定</li></ul></li><li>状态（status）<br>一个 PV 的生命周期中，可能会处于4中不同的阶段：<ul><li>Available（可用）： 表示可用状态，还未被任何 PVC 绑定</li><li>Bound（已绑定）： 表示 PV 已经被 PVC 绑定</li><li>Released（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明</li><li>Failed（失败）： 表示该 PV 的自动回收失败</li></ul></li></ul><p>实验</p><p>使用NFS作为存储，来演示PV的使用，创建3个PV，对应NFS中的3个暴露的路径。</p><p>1) 准备NFS环境</p><pre><code># 创建目录[root@nfs ~]# mkdir /root/data/{pv1,pv2,pv3} -pv# 暴露服务[root@nfs ~]# more /etc/exports/root/data/pv1     192.168.5.0/24(rw,no_root_squash)/root/data/pv2     192.168.5.0/24(rw,no_root_squash)/root/data/pv3     192.168.5.0/24(rw,no_root_squash)# 重启服务[root@nfs ~]#  systemctl restart nfs</code></pre><p>2) 创建pv.yaml</p><pre><code>apiVersion: v1kind: PersistentVolumemetadata:  name:  pv1spec:  capacity:     storage: 1Gi  accessModes:  - ReadWriteMany  persistentVolumeReclaimPolicy: Retain  nfs:    path: /root/data/pv1    server: 192.168.5.6---apiVersion: v1kind: PersistentVolumemetadata:  name:  pv2spec:  capacity:     storage: 2Gi  accessModes:  - ReadWriteMany  persistentVolumeReclaimPolicy: Retain  nfs:    path: /root/data/pv2    server: 192.168.5.6---apiVersion: v1kind: PersistentVolumemetadata:  name:  pv3spec:  capacity:     storage: 3Gi  accessModes:  - ReadWriteMany  persistentVolumeReclaimPolicy: Retain  nfs:    path: /root/data/pv3    server: 192.168.5.6# 创建 pv[root@k8s-master01 ~]# kubectl create -f pv.yamlpersistentvolume/pv1 createdpersistentvolume/pv2 createdpersistentvolume/pv3 created# 查看pv[root@k8s-master01 ~]# kubectl get pv -o wideNAME   CAPACITY   ACCESS MODES  RECLAIM POLICY  STATUS      AGE   VOLUMEMODEpv1    1Gi        RWX            Retain        Available    10s   Filesystempv2    2Gi        RWX            Retain        Available    10s   Filesystempv3    3Gi        RWX            Retain        Available    9s    Filesystem</code></pre><p>8.2.2 PVC</p><p>PVC是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息。下面是资源清单文件:</p><pre><code>apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: pvc  namespace: devspec:  accessModes: # 访问模式  selector: # 采用标签对PV选择  storageClassName: # 存储类别  resources: # 请求空间    requests:      storage: 5Gi</code></pre><p>PVC 的关键配置参数说明：</p><ul><li>访问模式（accessModes）</li></ul><p>用于描述用户应用对存储资源的访问权限</p><ul><li>选择条件（selector）<br>通过Label Selector的设置，可使PVC对于系统中己存在的PV进行筛选</li><li>存储类别（storageClassName）<br>PVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出</li><li>资源请求（Resources ）<br>描述对存储资源的请求</li></ul><p>实验</p><p>1) 创建pvc.yaml，申请pv</p><pre><code>apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: pvc1  namespace: devspec:  accessModes:   - ReadWriteMany  resources:    requests:      storage: 1Gi---apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: pvc2  namespace: devspec:  accessModes:   - ReadWriteMany  resources:    requests:      storage: 1Gi---apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: pvc3  namespace: devspec:  accessModes:   - ReadWriteMany  resources:    requests:      storage: 1Gi# 创建pvc[root@k8s-master01 ~]# kubectl create -f pvc.yamlpersistentvolumeclaim/pvc1 createdpersistentvolumeclaim/pvc2 createdpersistentvolumeclaim/pvc3 created# 查看pvc[root@k8s-master01 ~]# kubectl get pvc  -n dev -o wideNAME   STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE   VOLUMEMODEpvc1   Bound    pv1      1Gi        RWX                           15s   Filesystempvc2   Bound    pv2      2Gi        RWX                           15s   Filesystempvc3   Bound    pv3      3Gi        RWX                           15s   Filesystem# 查看pv[root@k8s-master01 ~]# kubectl get pv -o wideNAME  CAPACITY ACCESS MODES  RECLAIM POLICY  STATUS    CLAIM       AGE     VOLUMEMODEpv1    1Gi        RWx        Retain          Bound    dev/pvc1    3h37m    Filesystempv2    2Gi        RWX        Retain          Bound    dev/pvc2    3h37m    Filesystempv3    3Gi        RWX        Retain          Bound    dev/pvc3    3h37m    Filesystem   </code></pre><p>2) 创建pods.yaml, 使用pv</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod1  namespace: devspec:  containers:  - name: busybox    image: busybox:1.30    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;while true;do echo pod1 &gt;&gt; /root/out.txt; sleep 10; done;&quot;]    volumeMounts:    - name: volume      mountPath: /root/  volumes:    - name: volume      persistentVolumeClaim:        claimName: pvc1        readOnly: false---apiVersion: v1kind: Podmetadata:  name: pod2  namespace: devspec:  containers:  - name: busybox    image: busybox:1.30    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;while true;do echo pod2 &gt;&gt; /root/out.txt; sleep 10; done;&quot;]    volumeMounts:    - name: volume      mountPath: /root/  volumes:    - name: volume      persistentVolumeClaim:        claimName: pvc2        readOnly: false# 创建pod[root@k8s-master01 ~]# kubectl create -f pods.yamlpod/pod1 createdpod/pod2 created# 查看pod[root@k8s-master01 ~]# kubectl get pods -n dev -o wideNAME   READY   STATUS    RESTARTS   AGE   IP            NODE   pod1   1/1     Running   0          14s   10.244.1.69   node1   pod2   1/1     Running   0          14s   10.244.1.70   node1  # 查看pvc[root@k8s-master01 ~]# kubectl get pvc -n dev -o wideNAME   STATUS   VOLUME   CAPACITY   ACCESS MODES      AGE   VOLUMEMODEpvc1   Bound    pv1      1Gi        RWX               94m   Filesystempvc2   Bound    pv2      2Gi        RWX               94m   Filesystempvc3   Bound    pv3      3Gi        RWX               94m   Filesystem# 查看pv[root@k8s-master01 ~]# kubectl get pv -n dev -o wideNAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM       AGE     VOLUMEMODEpv1    1Gi        RWX            Retain           Bound    dev/pvc1    5h11m   Filesystempv2    2Gi        RWX            Retain           Bound    dev/pvc2    5h11m   Filesystempv3    3Gi        RWX            Retain           Bound    dev/pvc3    5h11m   Filesystem# 查看nfs中的文件存储[root@nfs ~]# more /root/data/pv1/out.txtnode1node1[root@nfs ~]# more /root/data/pv2/out.txtnode2node2</code></pre><p>8.2.3 生命周期</p><p>PVC和PV是一一对应的，PV和PVC之间的相互作用遵循以下生命周期：</p><ul><li>资源供应：管理员手动创建底层存储和PV</li><li>资源绑定：用户创建PVC，kubernetes负责根据PVC的声明去寻找PV，并绑定<br>在用户定义好PVC之后，系统将根据PVC对存储资源的请求在已存在的PV中选择一个满足条件的<ul><li>一旦找到，就将该PV与用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了</li><li>如果找不到，PVC则会无限期处于Pending状态，直到等到系统管理员创建了一个符合其要求的PV<br>PV一旦绑定到某个PVC上，就会被这个PVC独占，不能再与其他PVC进行绑定了</li></ul></li><li>资源使用：用户可在pod中像volume一样使用pvc<br>Pod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用。</li><li>资源释放：用户删除pvc来释放pv<br>当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。</li><li>资源回收：kubernetes根据pv设置的回收策略进行资源的回收<br>对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用</li></ul><p><a href="https://img-blog.csdnimg.cn/9c5819b13b294b4dbb79a1425510f381.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/9c5819b13b294b4dbb79a1425510f381.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>8.3 配置存储</p><p>8.3.1 ConfigMap</p><p>ConfigMap是一种比较特殊的存储卷，它的主要作用是用来存储配置信息的。</p><p>创建configmap.yaml，内容如下：</p><pre><code>apiVersion: v1kind: ConfigMapmetadata:  name: configmap  namespace: devdata:  info: |    username:admin    password:123456</code></pre><p>接下来，使用此配置文件创建configmap</p><pre><code># 创建configmap[root@k8s-master01 ~]# kubectl create -f configmap.yamlconfigmap/configmap created# 查看configmap详情[root@k8s-master01 ~]# kubectl describe cm configmap -n devName:         configmapNamespace:    devLabels:       &lt;none&gt;Annotations:  &lt;none&gt;Data====info:----username:adminpassword:123456Events:  &lt;none&gt;</code></pre><p>接下来创建一个pod-configmap.yaml，将上面创建的configmap挂载进去</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-configmap  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    volumeMounts: # 将configmap挂载到目录    - name: config      mountPath: /configmap/config  volumes: # 引用configmap  - name: config    configMap:      name: configmap# 创建pod[root@k8s-master01 ~]# kubectl create -f pod-configmap.yamlpod/pod-configmap created# 查看pod[root@k8s-master01 ~]# kubectl get pod pod-configmap -n devNAME            READY   STATUS    RESTARTS   AGEpod-configmap   1/1     Running   0          6s#进入容器[root@k8s-master01 ~]# kubectl exec -it pod-configmap -n dev /bin/sh# cd /configmap/config/# lsinfo# more infousername:adminpassword:123456# 可以看到映射已经成功，每个configmap都映射成了一个目录# key---&gt;文件     value----&gt;文件中的内容# 此时如果更新configmap的内容, 容器中的值也会动态更新</code></pre><p>8.3.2 Secret</p><p>在kubernetes中，还存在一种和ConfigMap非常类似的对象，称为Secret对象。它主要用于存储敏感信息，例如密码、秘钥、证书等等。</p><p>1) 首先使用base64对数据进行编码</p><pre><code>[root@k8s-master01 ~]# echo -n &apos;admin&apos; | base64 #准备usernameYWRtaW4=[root@k8s-master01 ~]# echo -n &apos;123456&apos; | base64 #准备passwordMTIzNDU2</code></pre><p>2) 接下来编写secret.yaml，并创建Secret</p><pre><code>apiVersion: v1kind: Secretmetadata:  name: secret  namespace: devtype: Opaquedata:  username: YWRtaW4=  password: MTIzNDU2# 创建secret[root@k8s-master01 ~]# kubectl create -f secret.yamlsecret/secret created# 查看secret详情[root@k8s-master01 ~]# kubectl describe secret secret -n devName:         secretNamespace:    devLabels:       &lt;none&gt;Annotations:  &lt;none&gt;Type:  OpaqueData====password:  6 bytesusername:  5 bytes</code></pre><p>3) 创建pod-secret.yaml，将上面创建的secret挂载进去：</p><pre><code>apiVersion: v1kind: Podmetadata:  name: pod-secret  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1    volumeMounts: # 将secret挂载到目录    - name: config      mountPath: /secret/config  volumes:  - name: config    secret:      secretName: secret# 创建pod[root@k8s-master01 ~]# kubectl create -f pod-secret.yamlpod/pod-secret created# 查看pod[root@k8s-master01 ~]# kubectl get pod pod-secret -n devNAME            READY   STATUS    RESTARTS   AGEpod-secret      1/1     Running   0          2m28s# 进入容器，查看secret信息，发现已经自动解码了[root@k8s-master01 ~]# kubectl exec -it pod-secret /bin/sh -n dev/ # ls /secret/config/password  username/ # more /secret/config/usernameadmin/ # more /secret/config/password123456</code></pre><p>至此，已经实现了利用secret实现了信息的编码。</p><ol start="9"><li>安全认证</li></ol><p>9.1 访问控制概述</p><p>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对Kubernetes的各种客户端进行认证和鉴权操作。</p><p>客户端</p><p>在Kubernetes集群中，客户端通常有两类：</p><ul><li>User Account：一般是独立于kubernetes之外的其他服务管理的用户账号。</li><li>Service Account：kubernetes管理的账号，用于为Pod中的服务进程在访问Kubernetes时提供身份标识。</li></ul><p><a href="https://img-blog.csdnimg.cn/2a636a4d8e8c4448af5f76888e07e003.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2a636a4d8e8c4448af5f76888e07e003.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>认证、授权与准入控制</p><p>ApiServer是访问及管理资源对象的唯一入口。任何一个请求访问ApiServer，都要经过下面三个流程：</p><ul><li>Authentication（认证）：身份鉴别，只有正确的账号才能够通过认证</li><li>Authorization（授权）： 判断用户是否有权限对访问的资源执行特定的动作</li><li>Admission Control（准入控制）：用于补充授权机制以实现更加精细的访问控制功能。</li></ul><p><a href="https://img-blog.csdnimg.cn/0bde0f7703e246519026744e29fdc341.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/0bde0f7703e246519026744e29fdc341.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>9.2 认证管理</p><p>Kubernetes集群安全的最关键点在于如何识别并认证客户端身份，它提供了3种客户端身份认证方式：</p><ul><li>HTTP Base认证：通过用户名+密码的方式认证<pre><code>这种认证方式是把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header Authorization域里发送给服务端。服务端收到后进行解码，获取用户名及密码，然后进行用户身份认证的过程。</code></pre></li><li>HTTP Token认证：通过一个Token来识别合法用户<pre><code>这种认证方式是用一个很长的难以被模仿的字符串--Token来表明客户身份的一种方式。每个Token对应一个用户名，当客户端发起API调用请求时，需要在HTTP Header里放入Token，API Server接到Token后会跟服务器中保存的token进行比对，然后进行用户身份认证的过程。</code></pre></li><li>HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式<pre><code>这种认证方式是安全性最高的一种方式，但是同时也是操作起来最麻烦的一种方式。</code></pre><a href="https://img-blog.csdnimg.cn/24bf9d2180374795b47cc4e3e9088530.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/24bf9d2180374795b47cc4e3e9088530.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></li></ul><p>HTTPS认证大体分为3个过程：</p><ol><li>证书申请和下发<pre><code>HTTPS通信双方的服务器向CA机构申请证书，CA机构下发根证书、服务端证书及私钥给申请者</code></pre></li><li>客户端和服务端的双向认证<pre><code>1&gt; 客户端向服务器端发起请求，服务端下发自己的证书给客户端，   客户端接收到证书后，通过私钥解密证书，在证书中获得服务端的公钥，   客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器2&gt; 客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书，   在证书中获得客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法</code></pre></li><li>服务器端和客户端进行通信<pre><code>服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥并加密，然后发送到服务器端。服务器端接收这个秘钥后，双方接下来通信的所有内容都通过该随机秘钥加密</code></pre></li></ol><p>注意: Kubernetes允许同时配置多种认证方式，只要其中任意一个方式认证通过即可</p><p>9.3 授权管理</p><p>授权发生在认证成功之后，通过认证就可以知道请求用户是谁， 然后Kubernetes会根据事先定义的授权策略来决定用户是否有权限访问，这个过程就称为授权。</p><p>每个发送到ApiServer的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误。</p><p>API Server目前支持以下几种授权策略：</p><ul><li>AlwaysDeny：表示拒绝所有请求，一般用于测试</li><li>AlwaysAllow：允许接收所有请求，相当于集群不需要授权流程（Kubernetes默认的策略）</li><li>ABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li><li>Webhook：通过调用外部REST服务对用户进行授权</li><li>Node：是一种专用模式，用于对kubelet发出的请求进行访问控制</li><li>RBAC：基于角色的访问控制（kubeadm安装方式下的默认选项）</li></ul><p>RBAC(Role-Based Access Control) 基于角色的访问控制，主要是在描述一件事情：给哪些对象授予了哪些权限</p><p>其中涉及到了下面几个概念：</p><ul><li>对象：User、Groups、ServiceAccount</li><li>角色：代表着一组定义在资源上的可操作动作(权限)的集合</li><li>绑定：将定义好的角色跟用户绑定在一起<br><a href="https://img-blog.csdnimg.cn/21478531aa914e86bd60922bac98caef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/21478531aa914e86bd60922bac98caef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></li></ul><p>RBAC引入了4个顶级资源对象：</p><ul><li>Role、ClusterRole：角色，用于指定一组权限</li><li>RoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限）赋予给对象</li></ul><p>Role、ClusterRole</p><p>一个角色就是一组权限的集合，这里的权限都是许可形式的（白名单）。</p><pre><code># Role只能对命名空间内的资源进行授权，需要指定nameapcekind: RoleapiVersion: rbac.authorization.k8s.io/v1beta1metadata:  namespace: dev  name: authorization-rolerules:- apiGroups: [&quot;&quot;]  # 支持的API组列表,&quot;&quot; 空字符串，表示核心API群  resources: [&quot;pods&quot;] # 支持的资源对象列表  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;] # 允许的对资源对象的操作方法列表# ClusterRole可以对集群范围内资源、跨namespaces的范围资源、非资源类型进行授权kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1beta1metadata: name: authorization-clusterrolerules:- apiGroups: [&quot;&quot;]  resources: [&quot;pods&quot;]  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]</code></pre><p>需要详细说明的是，rules中的参数：</p><ul><li>apiGroups: 支持的API组列表<pre><code>&quot;&quot;,&quot;apps&quot;, &quot;autoscaling&quot;, &quot;batch&quot;</code></pre></li><li>resources：支持的资源对象列表<pre><code>&quot;services&quot;, &quot;endpoints&quot;, &quot;pods&quot;,&quot;secrets&quot;,&quot;configmaps&quot;,&quot;crontabs&quot;,&quot;deployments&quot;,&quot;jobs&quot;,&quot;nodes&quot;,&quot;rolebindings&quot;,&quot;clusterroles&quot;,&quot;daemonsets&quot;,&quot;replicasets&quot;,&quot;statefulsets&quot;,&quot;horizontalpodautoscalers&quot;,&quot;replicationcontrollers&quot;,&quot;cronjobs&quot;</code></pre></li><li>verbs：对资源对象的操作方法列表<pre><code>&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;, &quot;exec&quot;</code></pre></li></ul><p>RoleBinding、ClusterRoleBinding</p><p>角色绑定用来把一个角色绑定到一个目标对象上，绑定目标可以是User、Group或者ServiceAccount。</p><pre><code># RoleBinding可以将同一namespace中的subject绑定到某个Role下，则此subject即具有该Role定义的权限kind: RoleBindingapiVersion: rbac.authorization.k8s.io/v1beta1metadata:  name: authorization-role-binding  namespace: devsubjects:- kind: User  name: heima  apiGroup: rbac.authorization.k8s.ioroleRef:  kind: Role  name: authorization-role  apiGroup: rbac.authorization.k8s.io# ClusterRoleBinding在整个集群级别和所有namespaces将特定的subject与ClusterRole绑定，授予权限kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1beta1metadata: name: authorization-clusterrole-bindingsubjects:- kind: User  name: heima  apiGroup: rbac.authorization.k8s.ioroleRef:  kind: ClusterRole  name: authorization-clusterrole  apiGroup: rbac.authorization.k8s.io</code></pre><p>RoleBinding引用ClusterRole进行授权</p><p>RoleBinding可以引用ClusterRole，对属于同一命名空间内ClusterRole定义的资源主体进行授权。</p><pre><code>    一种很常用的做法就是，集群管理员为集群范围预定义好一组角色（ClusterRole），然后在多个命名空间中重复使用这些ClusterRole。这样可以大幅提高授权管理工作效率，也使得各个命名空间下的基础性授权规则与使用体验保持一致。# 虽然authorization-clusterrole是一个集群角色，但是因为使用了RoleBinding# 所以heima只能读取dev命名空间中的资源kind: RoleBindingapiVersion: rbac.authorization.k8s.io/v1beta1metadata:  name: authorization-role-binding-ns  namespace: devsubjects:- kind: User  name: heima  apiGroup: rbac.authorization.k8s.ioroleRef:  kind: ClusterRole  name: authorization-clusterrole  apiGroup: rbac.authorization.k8s.io</code></pre><p>实战：创建一个只能管理dev空间下Pods资源的账号</p><p>1) 创建账号</p><pre><code># 1) 创建证书[root@k8s-master01 pki]# cd /etc/kubernetes/pki/[root@k8s-master01 pki]# (umask 077;openssl genrsa -out devman.key 2048)# 2) 用apiserver的证书去签署# 2-1) 签名申请，申请的用户是devman,组是devgroup[root@k8s-master01 pki]# openssl req -new -key devman.key -out devman.csr -subj &quot;/CN=devman/O=devgroup&quot;     # 2-2) 签署证书[root@k8s-master01 pki]# openssl x509 -req -in devman.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out devman.crt -days 3650# 3) 设置集群、用户、上下文信息[root@k8s-master01 pki]# kubectl config set-cluster kubernetes --embed-certs=true --certificate-authority=/etc/kubernetes/pki/ca.crt --server=https://192.168.109.100:6443[root@k8s-master01 pki]# kubectl config set-credentials devman --embed-certs=true --client-certificate=/etc/kubernetes/pki/devman.crt --client-key=/etc/kubernetes/pki/devman.key[root@k8s-master01 pki]# kubectl config set-context devman@kubernetes --cluster=kubernetes --user=devman# 切换账户到devman[root@k8s-master01 pki]# kubectl config use-context devman@kubernetesSwitched to context &quot;devman@kubernetes&quot;.# 查看dev下pod，发现没有权限[root@k8s-master01 pki]# kubectl get pods -n devError from server (Forbidden): pods is forbidden: User &quot;devman&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;dev&quot;# 切换到admin账户[root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetesSwitched to context &quot;kubernetes-admin@kubernetes&quot;.</code></pre><p>2） 创建Role和RoleBinding，为devman用户授权</p><pre><code>kind: RoleapiVersion: rbac.authorization.k8s.io/v1beta1metadata:  namespace: dev  name: dev-rolerules:- apiGroups: [&quot;&quot;]  resources: [&quot;pods&quot;]  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]---kind: RoleBindingapiVersion: rbac.authorization.k8s.io/v1beta1metadata:  name: authorization-role-binding  namespace: devsubjects:- kind: User  name: devman  apiGroup: rbac.authorization.k8s.ioroleRef:  kind: Role  name: dev-role  apiGroup: rbac.authorization.k8s.io[root@k8s-master01 pki]# kubectl create -f dev-role.yamlrole.rbac.authorization.k8s.io/dev-role createdrolebinding.rbac.authorization.k8s.io/authorization-role-binding created</code></pre><p>3) 切换账户，再次验证</p><pre><code># 切换账户到devman[root@k8s-master01 pki]# kubectl config use-context devman@kubernetesSwitched to context &quot;devman@kubernetes&quot;.# 再次查看[root@k8s-master01 pki]# kubectl get pods -n devNAME                                 READY   STATUS             RESTARTS   AGEnginx-deployment-66cb59b984-8wp2k    1/1     Running            0          4d1hnginx-deployment-66cb59b984-dc46j    1/1     Running            0          4d1hnginx-deployment-66cb59b984-thfck    1/1     Running            0          4d1h# 为了不影响后面的学习,切回admin账户[root@k8s-master01 pki]# kubectl config use-context kubernetes-admin@kubernetesSwitched to context &quot;kubernetes-admin@kubernetes&quot;.</code></pre><p>9.4 准入控制</p><p>通过了前面的认证和授权之后，还需要经过准入控制处理通过之后，apiserver才会处理这个请求。</p><p>准入控制是一个可配置的控制器列表，可以通过在Api-Server上通过命令行设置选择执行哪些准入控制器：</p><pre><code>--admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,                      DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds</code></pre><p>只有当所有的准入控制器都检查通过之后，apiserver才执行该请求，否则返回拒绝。</p><p>当前可配置的Admission Control准入控制如下：</p><ul><li>AlwaysAdmit：允许所有请求</li><li>AlwaysDeny：禁止所有请求，一般用于测试</li><li>AlwaysPullImages：在启动容器之前总去下载镜像</li><li>DenyExecOnPrivileged：它会拦截所有想在Privileged Container上执行命令的请求</li><li>ImagePolicyWebhook：这个插件将允许后端的一个Webhook程序来完成admission controller的功能。</li><li>Service Account：实现ServiceAccount实现了自动化</li><li>SecurityContextDeny：这个插件将使用SecurityContext的Pod中的定义全部失效</li><li>ResourceQuota：用于资源配额管理目的，观察所有请求，确保在namespace上的配额不会超标</li><li>LimitRanger：用于资源限制管理，作用于namespace上，确保对Pod进行资源限制</li><li>InitialResources：为未设置资源请求与限制的Pod，根据其镜像的历史资源的使用情况进行设置</li><li>NamespaceLifecycle：如果尝试在一个不存在的namespace中创建资源对象，则该创建请求将被拒绝。当删除一个namespace时，系统将会删除该namespace中所有对象。</li><li>DefaultStorageClass：为了实现共享存储的动态供应，为未指定StorageClass或PV的PVC尝试匹配默认的StorageClass，尽可能减少用户在申请PVC时所需了解的后端存储细节</li><li>DefaultTolerationSeconds：这个插件为那些没有设置forgiveness tolerations并具有notready:NoExecute和unreachable:NoExecute两种taints的Pod设置默认的“容忍”时间，为5min</li><li>PodSecurityPolicy：这个插件用于在创建或修改Pod时决定是否根据Pod的security context和可用的PodSecurityPolicy对Pod的安全策略进行控制</li></ul><ol start="10"><li>DashBoard</li></ol><p>之前在kubernetes中完成的所有操作都是通过命令行工具kubectl完成的。其实，为了提供更丰富的用户体验，kubernetes还开发了一个基于web的用户界面（Dashboard）。用户可以使用Dashboard部署容器化的应用，还可以监控应用的状态，执行故障排查以及管理kubernetes中各种资源。</p><p>10.1 部署Dashboard</p><p>1) 下载yaml，并运行Dashboard</p><pre><code># 下载yaml[root@k8s-master01 ~]# wget  https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml# 修改kubernetes-dashboard的Service类型kind: ServiceapiVersion: v1metadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard  namespace: kubernetes-dashboardspec:  type: NodePort  # 新增  ports:    - port: 443      targetPort: 8443      nodePort: 30009  # 新增  selector:    k8s-app: kubernetes-dashboard# 部署[root@k8s-master01 ~]# kubectl create -f recommended.yaml# 查看namespace下的kubernetes-dashboard下的资源[root@k8s-master01 ~]# kubectl get pod,svc -n kubernetes-dashboardNAME                                            READY   STATUS    RESTARTS   AGEpod/dashboard-metrics-scraper-c79c65bb7-zwfvw   1/1     Running   0          111spod/kubernetes-dashboard-56484d4c5-z95z5        1/1     Running   0          111sNAME                               TYPE       CLUSTER-IP      EXTERNAL-IP  PORT(S)         AGEservice/dashboard-metrics-scraper  ClusterIP  10.96.89.218    &lt;none&gt;       8000/TCP        111sservice/kubernetes-dashboard       NodePort   10.104.178.171  &lt;none&gt;       443:30009/TCP   111s</code></pre><p>2）创建访问账户，获取token</p><pre><code># 创建账号[root@k8s-master01-1 ~]# kubectl create serviceaccount dashboard-admin -n kubernetes-dashboard# 授权[root@k8s-master01-1 ~]# kubectl create clusterrolebinding dashboard-admin-rb --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-admin# 获取账号token[root@k8s-master01 ~]#  kubectl get secrets -n kubernetes-dashboard | grep dashboard-admindashboard-admin-token-xbqhh        kubernetes.io/service-account-token   3      2m35s[root@k8s-master01 ~]# kubectl describe secrets dashboard-admin-token-xbqhh -n kubernetes-dashboardName:         dashboard-admin-token-xbqhhNamespace:    kubernetes-dashboardLabels:       &lt;none&gt;Annotations:  kubernetes.io/service-account.name: dashboard-admin              kubernetes.io/service-account.uid: 95d84d80-be7a-4d10-a2e0-68f90222d039Type:  kubernetes.io/service-account-tokenData====namespace:  20 bytestoken:      eyJhbGciOiJSUzI1NiIsImtpZCI6ImJrYkF4bW5XcDhWcmNGUGJtek5NODFuSXl1aWptMmU2M3o4LTY5a2FKS2cifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4teGJxaGgiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiOTVkODRkODAtYmU3YS00ZDEwLWEyZTAtNjhmOTAyMjJkMDM5Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmVybmV0ZXMtZGFzaGJvYXJkOmRhc2hib2FyZC1hZG1pbiJ9.NAl7e8ZfWWdDoPxkqzJzTB46sK9E8iuJYnUI9vnBaY3Jts7T1g1msjsBnbxzQSYgAG--cV0WYxjndzJY_UWCwaGPrQrt_GunxmOK9AUnzURqm55GR2RXIZtjsWVP2EBatsDgHRmuUbQvTFOvdJB4x3nXcYLN2opAaMqg3rnU2rr-A8zCrIuX_eca12wIp_QiuP3SF-tzpdLpsyRfegTJZl6YnSGyaVkC9id-cxZRb307qdCfXPfCHR_2rt5FVfxARgg_C0e3eFHaaYQO7CitxsnIoIXpOFNAR8aUrmopJyODQIPqBWUehb7FhlU1DCduHnIIXVC_UICZ-MKYewBDLwca.crt:     1025 bytes</code></pre><p>3）通过浏览器访问Dashboard的UI</p><p>在登录页面上输入上面的token</p><p><a href="https://img-blog.csdnimg.cn/2884f3f049d4480f84437a1ec12358e0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2884f3f049d4480f84437a1ec12358e0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>出现下面的页面代表成功</p><p><a href="https://img-blog.csdnimg.cn/bec692224154464bb95f19165a433e5c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/bec692224154464bb95f19165a433e5c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>10.2 使用DashBoard</p><p>本章节以Deployment为例演示DashBoard的使用</p><p>查看</p><p>选择指定的命名空间dev，然后点击Deployments，查看dev空间下的所有deployment</p><p><a href="https://img-blog.csdnimg.cn/7ac0c3946a1d4133830efc28dda8ae05.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/7ac0c3946a1d4133830efc28dda8ae05.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>扩缩容</p><p>在Deployment上点击规模，然后指定目标副本数量，点击确定</p><p><a href="https://img-blog.csdnimg.cn/39f9b834e1544412a6eb062046cc77ac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/39f9b834e1544412a6eb062046cc77ac.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>编辑</p><p>在Deployment上点击编辑，然后修改yaml文件，点击确定</p><p><a href="https://img-blog.csdnimg.cn/823616b6f4274596b455c84b07055b8e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/823616b6f4274596b455c84b07055b8e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>查看Pod</p><p>点击Pods, 查看pods列表<br><a href="https://img-blog.csdnimg.cn/1383aa86326e4a3e8908e0e7dd2c60dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/1383aa86326e4a3e8908e0e7dd2c60dc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>操作Pod</p><p>选中某个Pod，可以对其执行日志（logs）、进入执行（exec）、编辑、删除操作</p><p><a href="https://img-blog.csdnimg.cn/18c8616fe9ba4e5581db90fa09bfcc19.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/18c8616fe9ba4e5581db90fa09bfcc19.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQWngvJLgv4g=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" class="lazyload"></a></p><p>Dashboard提供了kubectl的绝大部分功能，这里不再一一演示</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes入门到精通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Compose</title>
      <link href="/2021/08/18/Docker%20Compose/"/>
      <url>/2021/08/18/Docker%20Compose/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Docker Compose是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。<br>Compose 通过一个配置文件来管理多个Docker容器，在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。</p><p>Compose 使用的三个步骤：</p><ul><li><p>使用 Dockerfile 定义应用程序的环境。</p></li><li><p>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</p></li><li><p>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</p></li></ul><h1 id="Compose-安装"><a href="#Compose-安装" class="headerlink" title="Compose 安装"></a>Compose 安装</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：</p><p><a href="https://github.com/docker/compose/releases。" target="_blank" rel="noopener">https://github.com/docker/compose/releases。</a><br>运行以下命令以下载 Docker Compose 的当前稳定版本：</p><pre><code>$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code></pre><p>   若是github访问太慢，可以用daocloud下载</p><pre><code>sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</code></pre><p>要安装其他版本的 Compose，请替换 1.24.1。</p><p>将可执行权限应用于二进制文件：</p><pre><code>$ sudo chmod +x /usr/local/bin/docker-compose</code></pre><p>创建软链：</p><pre><code>$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code></pre><p>测试是否安装成功：</p><pre><code>$ docker-compose --versioncker-compose version 1.24.1, build 4667896b</code></pre><h1 id="Compose和Docker兼容性"><a href="#Compose和Docker兼容性" class="headerlink" title="Compose和Docker兼容性"></a>Compose和Docker兼容性</h1><table><thead><tr><th>compose文件格式版本</th><th>docker版本</th></tr></thead><tbody><tr><td>3.4</td><td>17.09.0+</td></tr><tr><td>3.3</td><td>17.06.0+</td></tr><tr><td>3.2</td><td>17.04.0+</td></tr><tr><td>3.1</td><td>1.13.1+</td></tr><tr><td>3.0</td><td>1.13.0+</td></tr><tr><td>2.3</td><td>17.06.0+</td></tr><tr><td>2.2</td><td>1.13.0+</td></tr><tr><td>2.1</td><td>1.12.0+</td></tr><tr><td>2.0</td><td>1.10.0+</td></tr><tr><td>1.0</td><td>1.9.1.+</td></tr></tbody></table><h1 id="docker-compose文件结构"><a href="#docker-compose文件结构" class="headerlink" title="docker-compose文件结构"></a>docker-compose文件结构</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  wordpress:    <span class="comment">#### 服务之一: wordpress               </span></span><br><span class="line">    image: wordpress:5.1</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:    <span class="comment">### 服务之间我们可以设置一个依赖. 让 wordpress 依赖下面的 db 服务. </span></span><br><span class="line">      - db</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80    <span class="comment">### 让让8080这个端口的对应容器里面的80端口，这样在主机上面访问 8080 端口的时候，对应得到的就是容器里面的在 80 端口上面运行的服务</span></span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: db    <span class="comment">### db表示 workpress 使用的数据库的主机，这里可以把它设置成db，</span></span><br><span class="line">      WORDPRESS_DB_USER: <span class="string">'toview'</span></span><br><span class="line">      WORDPRESS_DB_PASSWORD: <span class="string">'6H58v3hl9p2'</span></span><br><span class="line">      WORDPRESS_DB_NAME: <span class="string">'toview'</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./app/wp-content:/var/www/html/wp-content/    <span class="comment">### 当前目录(toview 目录)下的 app 文件夹</span></span><br><span class="line">      - ./app/config/php-uploads.ini:/usr/<span class="built_in">local</span>/etc/php/conf.d/uploads.ini</span><br><span class="line">  db:        <span class="comment">#### 服务之二: db 数据库服务</span></span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">     - 3366:3306</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_DATABASE: <span class="string">'toview'</span>    <span class="comment">### Mysql 镜像里面有一个 mysql database，添加一个数据库，这个数据库应该是 toview.</span></span><br><span class="line">      MYSQL_USER: <span class="string">'toview'</span>        <span class="comment">### toview 这个数据库就是上面 wordpress 使用的数据库名字.</span></span><br><span class="line">      MYSQL_PASSWORD: <span class="string">'6H58v3hl9p2'</span></span><br><span class="line">      MYSQL_ROOT_PASSWORD: <span class="string">'SlCUeVxNVbNpu9eESC3b14h'</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./app/db:/var/lib/mysql</span><br></pre></td></tr></table></figure></div><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>参考文档：<a href="https://docs.docker.com/compose/gettingstarted/" target="_blank" rel="noopener">https://docs.docker.com/compose/gettingstarted/</a></p><p>通过docker-compose构建一个在docker中运行的基于python flask框架的web应用。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><strong>1.创建一个测试目录：</strong></p><pre><code>$ mkdir composetest$ cd composetest$touch app.py </code></pre><p><strong>2.在 app.py 的文件中写入以下内容：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span><span class="params">()</span>:</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">'hits'</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World! I have been seen &#123;&#125; times.\n'</span>.format(count)</span><br></pre></td></tr></table></figure></div><p><strong>3.在 composetest 目录中创建另一个名为 requirements.txt 的文件，内容如下：</strong></p><pre><code>flaskredis</code></pre><p><strong>4.在 composetest 目录中，创建一个名为的文件 Dockerfile，内容如下：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7-alpine</span><br><span class="line">WORKDIR /code</span><br><span class="line">ENV FLASK_APP app.py</span><br><span class="line">ENV FLASK_RUN_HOST 0.0.0.0</span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">COPY . .</span><br><span class="line">CMD [<span class="string">"flask"</span>, <span class="string">"run"</span>]</span><br></pre></td></tr></table></figure></div><hr><p><strong>Dockerfile 内容解释：</strong></p><p>FROM python:3.7-alpine: </p><pre><code>从 Python 3.7 映像开始构建镜像。</code></pre><p>WORKDIR /code: </p><pre><code>将工作目录设置为 /code。</code></pre><p>设置 flask 命令使用的环境变量。    </p><pre><code>ENV FLASK_APP app.pyENV FLASK_RUN_HOST 0.0.0.0</code></pre><p><strong>RUN apk add –no-cache gcc musl-dev linux-headers:</strong> 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。</p><pre><code>COPY requirements.txt requirements.txtRUN pip install -r requirements.txt</code></pre><p>复制 requirements.txt 并安装 Python 依赖项。</p><ul><li>COPY . .: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。</li><li>CMD [“flask”, “run”]: 容器提供默认的执行命令为：flask run。</li></ul><hr><p><strong>5.在测试目录中创建一个名为 docker-compose.yml 的文件，然后粘贴以下内容：</strong></p><h1 id="yaml-配置"><a href="#yaml-配置" class="headerlink" title="yaml 配置"></a>yaml 配置</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">"5000:5000"</span></span><br><span class="line">  redis:</span><br><span class="line">    image: <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure></div><p>该 Compose 文件定义了两个服务：web 和 redis。</p><ul><li>web：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。</li><li>redis：该 redis 服务使用 Docker Hub 的公共 Redis 映像。</li></ul><p><strong>6、使用 Compose 命令构建和运行您的应用</strong></p><pre><code>docker-compose up</code></pre><p>如果你想在后台执行该服务可以加上 -d 参数：</p><pre><code>docker-compose up -d</code></pre><h1 id="yml-配置指令参考"><a href="#yml-配置指令参考" class="headerlink" title="yml 配置指令参考"></a>yml 配置指令参考</h1><p><strong>version</strong></p><pre><code>指定本 yml 依从的 compose 哪个版本制定的。</code></pre><p><strong>build</strong></p><pre><code>指定为构建镜像上下文路径：</code></pre><p>示例：</p><pre><code>version: &quot;3.7&quot;services:  webapp:    build:      context: ./dir      dockerfile: Dockerfile-alternate      args:        buildno: 1      labels:        - &quot;com.example.description=Accounting webapp&quot;        - &quot;com.example.department=Finance&quot;        - &quot;com.example.label-with-empty-value&quot;      target: prod</code></pre><p>解释:</p><ul><li>服务名：webapp</li><li>context：上下文路径。</li><li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li><li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li><li>labels：设置构建镜像的标签。</li><li>target：多层构建，可以指定构建哪一层。</li></ul><p><strong>devices</strong></p><pre><code>指定设备映射列表。</code></pre><p><strong>dns</strong></p><pre><code>自定义 DNS 服务器，可以是单个值或列表的多个值</code></pre><p><strong>dns_search</strong></p><pre><code>自定义 DNS 搜索域。可以是单个值或列表。</code></pre><p><strong>env_file</strong></p><pre><code>从文件添加环境变量。可以是单个值或列表的多个值。</code></pre><p><strong>environment</strong></p><pre><code>添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</code></pre><p><strong>image</strong></p><pre><code>指定容器运行的镜像。</code></pre><p>volumes</p><pre><code>将主机的数据卷或着文件挂载到容器里。</code></pre><hr><pre><code>version: &quot;3.7&quot;services:  db:    image: postgres:latest    volumes:      - &quot;/localhost/postgres.sock:/var/run/postgres/postgres.sock&quot;      - &quot;/localhost/data:/var/lib/postgresql/data&quot;</code></pre><p>restart</p><ul><li>no：是默认的重启策略，在任何情况下都不会重启容器。</li><li>always：容器总是重新启动。</li><li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li><li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li></ul><p><strong>logging</strong></p><pre><code>服务的日志记录配置。</code></pre><p>driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项</p><pre><code>driver: &quot;json-file&quot;driver: &quot;syslog&quot;driver: &quot;none&quot;</code></pre><p><strong>network_mode</strong><br>设置网络模式</p><pre><code>network_mode: &quot;bridge&quot;network_mode: &quot;host&quot;network_mode: &quot;none&quot;network_mode: &quot;service:[service name]&quot;network_mode: &quot;container:[container name/id]&quot;</code></pre><p><strong>networks</strong></p><p>配置容器连接的网络，引用顶级 networks 下的条目 </p><pre><code>services:  some-service:    networks:      some-network:        aliases:         - alias1      other-network:        aliases:         - alias2networks:  some-network:    # Use a custom driver    driver: custom-driver-1  other-network:    # Use a custom driver which takes special options    driver: custom-driver-2</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker Compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile详解</title>
      <link href="/2021/08/13/Dockerfile%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/08/13/Dockerfile%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h1><p>Dockerfile可以看做是被Docker程序所解释翻译的脚本，由一组命令集合而成，每一条命令都对应一条操作命令，有其翻译为Linux下的具体命令。用户可以通过自定义内容来快速构建镜像。</p><p><strong>Docker 执行 Dockerfile 的大致流程：</strong></p><ol><li>docker从基础镜像运行一个容器；</li><li>执行一条指令并对容器作出修改；</li><li>执行类似dockercommit的操作提交一个新的镜像层；</li><li>docker再基于刚提交的镜像运行一个新容器；</li><li>执行dockerfile中的下一条指令直到所有指令都执行完成；</li></ol><p><strong>Dockerfile的基本结构：</strong></p><p>Dockerfile 一般分为四部分：<strong>基础镜像信息</strong>、<strong>维护者信息</strong>、<strong>镜像操作指令</strong>和<strong>容器启动时执行指令</strong>，’#’ 为 Dockerfile 中的注释。</p><h1 id="构建httpd服务镜像"><a href="#构建httpd服务镜像" class="headerlink" title="构建httpd服务镜像"></a>构建httpd服务镜像</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /opt/</span></span><br><span class="line">[root@localhost opt]<span class="comment"># mkdir apache ##创建目录</span></span><br><span class="line">[root@localhost opt]<span class="comment"># cd apache/</span></span><br><span class="line">[root@localhost sshd]<span class="comment"># vim Dockerfile  ##编写dockerfile文件</span></span><br><span class="line"><span class="comment">#基于的基础镜像</span></span><br><span class="line">FROM centos</span><br><span class="line"><span class="comment">#维护镜像的用户信息</span></span><br><span class="line">MAINTAINER zjz</span><br><span class="line"><span class="comment">#镜像操作指令安装Apache软件</span></span><br><span class="line">RUN yum -y update</span><br><span class="line">RUN yum -y install httpd</span><br><span class="line"><span class="comment">#开启 80端口</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"><span class="comment">#复制网站首页文件</span></span><br><span class="line">ADD index.html /var/www/html/index.html</span><br><span class="line"><span class="comment">#将执行脚本复制到镜像中</span></span><br><span class="line">ADD run.sh /run.sh</span><br><span class="line">RUN chmod 755 /run.sh</span><br><span class="line"><span class="comment">#启动容器是执行脚本</span></span><br><span class="line">CMD [<span class="string">"/run.sh"</span>]</span><br><span class="line"></span><br><span class="line">其中注意：run 命令可以有多条CMD只能有一条，若有多条则只会执行最后一条</span><br><span class="line"></span><br><span class="line">编写启动httpd服务的shell脚本</span><br><span class="line"></span><br><span class="line">vim run.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">rm -rf /run/httpd/*</span><br><span class="line"><span class="built_in">exec</span> /usr/sbin/apachectl -D FOREGROUND</span><br><span class="line"></span><br><span class="line">编写测试页面</span><br><span class="line"></span><br><span class="line">vim index.html</span><br><span class="line">&lt;h1&gt;this is docker httpd web&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">使用tree命令查看目录的文件结构</span><br><span class="line">没有tree这个命令，用yum -y install tree 装一哈</span><br><span class="line"></span><br><span class="line">[root@localhost apache]<span class="comment"># tree ./</span></span><br><span class="line">./</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── index.html</span><br><span class="line">└── run.sh</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure></div><p>构建和使用镜像（创建运行容器）</p><pre><code>[root@localhost apache]# docker build -t httpd:new .</code></pre><p>查看镜像：</p><pre><code>[root@localhost apache]# docker images</code></pre><p><a href="https://img-blog.csdnimg.cn/20200728102803213.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200728102803213.png#pic_center" class="lazyload"></a><br>基于构建的镜像创建并运行容器，给容器取名为test</p><pre><code>[root@localhost apache]# docker run --name test -d -P httpd:new  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200728102913188.png#pic_center)</code></pre><p>查看容器：</p><pre><code>[root@localhost apache]# docker ps -a</code></pre><p><a href="https://img-blog.csdnimg.cn/20200728103018381.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200728103018381.png#pic_center" class="lazyload"></a><br>这样我们进入容器中检查一下这个页面文件是否存在</p><pre><code>[root@localhost apache]# docker exec -it test /bin/bash[root@0467d8d2d590 /]# cat /var/www/html/index.html &lt;h1&gt;this is docker httpd web&lt;/h1&gt;</code></pre><p><a href="https://img-blog.csdnimg.cn/20200728103316453.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200728103316453.png#pic_center" class="lazyload"></a></p><h1 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h1><p>先看示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.7-alpine <span class="comment"># 从 Python 3.7 映像开始构建镜像。</span></span><br><span class="line">WORKDIR /code <span class="comment">#将工作目录设置为 /code</span></span><br><span class="line">ENV FLASK_APP app.py <span class="comment">#设置环境变量</span></span><br><span class="line">ENV FLASK_RUN_HOST 0.0.0.0 <span class="comment">#设置环境变量</span></span><br><span class="line">RUN apk add --no-cache gcc musl-dev linux-headers</span><br><span class="line">COPY requirements.txt requirements.txt <span class="comment">#</span></span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">COPY . .</span><br><span class="line">CMD [<span class="string">"flask"</span>, <span class="string">"run"</span>]</span><br></pre></td></tr></table></figure></div><p>解释：</p><p><strong>RUN apk add –no-cache gcc musl-dev linux-headers</strong>: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。</p><pre><code>COPY requirements.txt requirements.txtRUN pip install -r requirements.txt</code></pre><p>复制 requirements.txt 并安装 Python 依赖项。</p><ul><li>COPY . .: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。</li><li>CMD [“flask”, “run”]: 容器提供默认的执行命令为：flask run。</li></ul><hr><p>Docker以从上到下的顺序运行Dockerfile的指令。为了指定基本映像，第一条指令必须是FROM。一个声明以＃字符开头则被视为注释。可以在Docker文件中使用RUN，CMD，FROM，EXPOSE，ENV等指令。</p><p><strong>FROM：指定基础镜像，必须为第一个命令</strong></p><pre><code>格式：　　FROM &lt;image&gt;　　FROM &lt;image&gt;:&lt;tag&gt;　　FROM &lt;image&gt;@&lt;digest&gt;示例：　　FROM mysql:5.7注：　　tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像</code></pre><p><strong>MAINTAINER: 维护者信息</strong></p><pre><code>格式：    MAINTAINER &lt;name&gt;示例：    MAINTAINER GK    MAINTAINER ggk@163.com    MAINTAINER GK &lt;ggk@163.com&gt;</code></pre><p><strong>RUN：构建镜像时执行的命令</strong></p><pre><code>shell执行格式：    RUN &lt;command&gt;exec执行格式：    RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]示例：    RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]    RUN apk update    RUN [&quot;/etc/execfile&quot;, &quot;arg1&quot;, &quot;arg1&quot;]注：　　RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache</code></pre><p><strong>ADD：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget</strong></p><pre><code>格式：    ADD &lt;src&gt;... &lt;dest&gt;    ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] 用于支持包含空格的路径示例：    ADD hom* /mydir/          # 添加所有以&quot;hom&quot;开头的文件    ADD hom?.txt /mydir/      # ? 替代一个单字符,例如：&quot;home.txt&quot;    ADD test relativeDir/     # 添加 &quot;test&quot; 到 `WORKDIR`/relativeDir/    ADD test /absoluteDir/    # 添加 &quot;test&quot; 到 /absoluteDir/</code></pre><p><strong>COPY：功能类似ADD，但是是不会自动解压文件，也不能访问网络资源</strong></p><pre><code>格式：COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;...  &lt;目标路径&gt;COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]示例：COPY hom* /mydir/COPY hom?.txt /mydir/</code></pre><p><strong>CMD：构建容器后调用，也就是在容器启动时才进行调用。</strong></p><pre><code>格式：    CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (执行可执行文件，优先)    CMD [&quot;param1&quot;,&quot;param2&quot;] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数)    CMD command param1 param2 (执行shell内部命令)示例：    CMD echo &quot;This is a test.&quot; | wc -    CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]注： 　　CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。</code></pre><p><strong>ENTRYPOINT：配置容器，使其可执行化。配合CMD可省去”application”，只使用参数。</strong></p><pre><code>格式：    ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (可执行文件, 优先)    ENTRYPOINT command param1 param2 (shell内部命令)示例：    FROM ubuntu    ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]    CMD [&quot;-c&quot;]注：　　　ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。</code></pre><p><strong>LABEL：用于为镜像添加元数据</strong></p><pre><code>格式：    LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...示例：　　LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;IT笔录&quot;注：　　使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。</code></pre><p><strong>ENV：设置环境变量</strong></p><pre><code>格式：    ENV &lt;key&gt; &lt;value&gt;  #&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置一个变量    ENV &lt;key&gt;=&lt;value&gt; ...  #可以设置多个变量，每个变量为一个&quot;&lt;key&gt;=&lt;value&gt;&quot;的键值对，如果&lt;key&gt;中包含空格，可以使用\来进行转义，也可以通过&quot;&quot;来进行标示；另外，反斜线也可以用于续行示例：    ENV myName gk    ENV mycatxx The cat    ENV myCat=fluffy</code></pre><p><strong>EXPOSE：指定于外界交互的端口</strong></p><pre><code>格式：    EXPOSE &lt;port&gt; [&lt;port&gt;...]示例：    EXPOSE 80 443    EXPOSE 8080    EXPOSE 11211/tcp 11211/udp注：　　EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口</code></pre><p><strong>VOLUME：用于指定持久化目录</strong></p><pre><code>格式：    VOLUME [&quot;/path/to/dir&quot;]示例：    VOLUME [&quot;/data&quot;]    VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;注：一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：1 卷可以容器间共享和重用2 容器并不一定要和其它容器共享卷3 修改卷后会立即生效4 对卷的修改不会对镜像产生影响5 卷会一直存在，直到没有任何容器在使用它</code></pre><p><strong>WORKDIR：工作目录，类似于cd命令</strong></p><pre><code>格式：    WORKDIR /path/to/workdir示例：    WORKDIR /a  (这时工作目录为/a)    WORKDIR b  (这时工作目录为/a/b)    WORKDIR c  (这时工作目录为/a/b/c)注：　　通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。</code></pre><p><strong>USER:指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户</strong></p><pre><code>格式:　　USER user　　USER user:group　　USER uid　　USER uid:gid　　USER user:gid　　USER uid:group 示例：　　USER www 注：　　使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。</code></pre><p><strong>ARG：用于指定传递给构建运行时的变量</strong></p><pre><code>格式：    ARG &lt;name&gt;[=&lt;default value&gt;]示例：    ARG site    ARG build_user=www</code></pre><p><strong>ONBUILD：用于设置镜像触发器</strong></p><pre><code>格式：　　ONBUILD [INSTRUCTION]示例：　　ONBUILD ADD . /app/src　　ONBUILD RUN /usr/local/bin/python-build --dir /app/src注：　　当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发</code></pre><h1 id="构建Nginx运行环境"><a href="#构建Nginx运行环境" class="headerlink" title="构建Nginx运行环境"></a>构建Nginx运行环境</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line">FROM sameersbn/ubuntu:14.04.20161014</span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER sameer@damagehead.com</span><br><span class="line"><span class="comment"># 设置环境</span></span><br><span class="line">ENV RTMP_VERSION=1.1.10 \</span><br><span class="line">    NPS_VERSION=1.11.33.4 \</span><br><span class="line">    LIBAV_VERSION=11.8 \</span><br><span class="line">    NGINX_VERSION=1.10.1 \</span><br><span class="line">    NGINX_USER=www-data \</span><br><span class="line">    NGINX_SITECONF_DIR=/etc/nginx/sites-enabled \</span><br><span class="line">    NGINX_LOG_DIR=/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">    NGINX_TEMP_DIR=/var/lib/nginx \</span><br><span class="line">    NGINX_SETUP_DIR=/var/cache/nginx</span><br><span class="line"><span class="comment"># 设置构建时变量，镜像建立完成后就失效</span></span><br><span class="line">ARG BUILD_LIBAV=<span class="literal">false</span></span><br><span class="line">ARG WITH_DEBUG=<span class="literal">false</span></span><br><span class="line">ARG WITH_PAGESPEED=<span class="literal">true</span></span><br><span class="line">ARG WITH_RTMP=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 复制本地文件到容器目录中</span></span><br><span class="line">COPY setup/ <span class="variable">$&#123;NGINX_SETUP_DIR&#125;</span>/</span><br><span class="line">RUN bash <span class="variable">$&#123;NGINX_SETUP_DIR&#125;</span>/install.sh</span><br><span class="line"><span class="comment"># 复制本地配置文件到容器目录中</span></span><br><span class="line">COPY nginx.conf /etc/nginx/nginx.conf</span><br><span class="line">COPY entrypoint.sh /sbin/entrypoint.sh</span><br><span class="line"><span class="comment"># 运行指令</span></span><br><span class="line">RUN chmod 755 /sbin/entrypoint.sh</span><br><span class="line"><span class="comment"># 允许指定的端口</span></span><br><span class="line">EXPOSE 80/tcp 443/tcp 1935/tcp</span><br><span class="line"><span class="comment"># 指定网站目录挂载点</span></span><br><span class="line">VOLUME [<span class="string">"<span class="variable">$&#123;NGINX_SITECONF_DIR&#125;</span>"</span>]</span><br><span class="line"> </span><br><span class="line">ENTRYPOINT [<span class="string">"/sbin/entrypoint.sh"</span>]</span><br><span class="line">CMD [<span class="string">"/usr/sbin/nginx"</span>]</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dockerfile详解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言第四天</title>
      <link href="/2021/07/02/GO%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E5%A4%A9%20/"/>
      <url>/2021/07/02/GO%E8%AF%AD%E8%A8%80%E7%AC%AC%E5%9B%9B%E5%A4%A9%20/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"># 指针</span><br><span class="line">任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</span><br><span class="line"></span><br><span class="line">地址：就是内存地址（用字节来描述的内存地址）</span><br><span class="line"></span><br><span class="line">指针：指针是带类型的。</span><br><span class="line"></span><br><span class="line">**&amp;和***</span><br><span class="line"></span><br><span class="line">&amp;：表示取地址</span><br><span class="line"></span><br><span class="line">*:根据地址取值</span><br><span class="line">定义一个变量：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">取变量a的内存地址：</span><br><span class="line"></span><br><span class="line">b := &amp;a</span><br><span class="line">取地址对应的值：</span><br><span class="line"></span><br><span class="line">fmt.Println(*b)</span><br><span class="line"></span><br><span class="line">定义一个修改数组第一个元素为<span class="number">100</span>的函数：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">(a1 [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">//只是修改的内部的a1这个数组</span></span><br><span class="line">&#125;</span><br><span class="line"> 定义一个修改数组第一个元素为<span class="number">100</span>的函数，接收的参数是一个数组的指针</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyArray2</span><span class="params">(a1 *[3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// (*a1)[0] = 100 //只是修改的内部的a1这个数组</span></span><br><span class="line"><span class="comment">//语法糖：因为Go语言中指针不支持修改</span></span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">//只是修改的内部的a1这个数组</span></span><br><span class="line">&#125;</span><br><span class="line"># <span class="built_in">new</span>和<span class="built_in">make</span></span><br><span class="line"></span><br><span class="line">二者都是内存的分配（堆上），但是<span class="built_in">make</span>只用于slice、<span class="keyword">map</span>以及channel的初始化（非零值）；</span><br><span class="line"></span><br><span class="line">而<span class="built_in">new</span>用于类型的内存分配，并且内存置为零。所以在我们编写程序的时候，就可以根据自己的需要很好的选择了。</span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span>返回的还是这三个引用类型本身；而<span class="built_in">new</span>返回的是指向类型的指针。</span><br><span class="line"></span><br><span class="line">**<span class="built_in">new</span>()**</span><br><span class="line"></span><br><span class="line">该方法的参数要求传入一个类型，而不是一个值，它会申请一个该类型大小的内存空间，并会初始化为对应的零值，返回指向该内存空间的一个指针。如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**<span class="built_in">make</span>()**</span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span>也是用于内存分配，但是和<span class="built_in">new</span>不同，它只用于slice、<span class="keyword">map</span>和channel的内存创建，它返回的类型就是类型本身，而不是它们的指针类型。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br><span class="line"></span><br><span class="line">案例：</span><br><span class="line"></span><br><span class="line">​<span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">package main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import "fmt"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">// 以下是错误的写法</span></span><br><span class="line"><span class="string">// var a *int //a是一个int类型的指针</span></span><br><span class="line"><span class="string">// var b *string</span></span><br><span class="line"><span class="string">// var c *[3]int</span></span><br><span class="line"><span class="string">// 以上是错误的写法</span></span><br><span class="line"><span class="string">var a = new(int) //得到一个int类型的指针</span></span><br><span class="line"><span class="string">fmt.Println(a)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*a = 10</span></span><br><span class="line"><span class="string">fmt.Println(a)</span></span><br><span class="line"><span class="string">fmt.Println(*a)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var c = new([3]int)</span></span><br><span class="line"><span class="string">fmt.Println(c)</span></span><br><span class="line"><span class="string">c[0] = 1</span></span><br><span class="line"><span class="string">fmt.Println(*c)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">​</span></span><br></pre></td></tr></table></figure></div><h1 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h1><p>其实，Go语言是不支持 try…catch…finally 这种异常处理的，因为Go语言的设计者们认为，将异常与控制结构混在一起会很容易使得代码变得混乱。因为开发者很容易滥用异常，甚至一个小小的错误都抛出一个异常。</p><p>在Go语言中，使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，才使用Go中引入的Exception处理：defer, panic, recover。</p><p><strong>panic：运行时异常</strong></p><p>panic用法挺简单的, 其实就是throw exception。</p><p>panic是golang的内建函数，panic会中断函数F的正常执行流程, 从F函数中跳出来, 跳回到F函数的调用者. 对于调用者来说, F看起来就是一个panic, 所以调用者会继续向上跳出, 直到当前goroutine返回. 在跳出的过程中, 进程会保持这个函数栈. 当goroutine退出时, 程序会crash。</p><p>要注意的是, F函数中的defered函数会正常执行, 按照上面defer的规则。</p><p>同时引起panic除了我们主动调用panic之外, 其他的任何运行时错误, 例如数组越界都会造成panic</p><p><strong>panic用法：</strong></p><p>​```go<br>package main</p><p>import (<br>    “fmt”<br>)</p><p>func main() {<br>    test()<br>}</p><p>func test() {<br>    defer func() { fmt.Println(“打印前”) }()<br>    defer func() { fmt.Println(“打印中”) }()<br>    defer func() { fmt.Println(“打印后”) }()<br>    panic(“触发异常”)<br>    fmt.Println(“test”)<br>}</p><p>——-output——-打印后 打印中 打印前 panic: 触发异常 goroutine 1 [running]: main.test() 　　　　D:/Go_Path/go/src/logDemo/main.go:15 +0x98 　　　　main.main() D:/Go_Path/go/src/logDemo/main.go:8 +0x27 exit status 2```</p><p><strong>recover：用来将函数在panic时恢复回来，用于做一些资源回收的操作</strong></p><p>recover也是golang的一个内建函数， 其实就是try catch。</p><p>不过需要注意的是：</p><p>　　1. recover如果想起作用的话， 必须在defered函数中使用。<br>　　2. 在正常函数执行过程中，调用recover没有任何作用, 他会返回nil。如这样：fmt.Println(recover()) 。<br>　　3. 如果当前的goroutine panic了，那么recover将会捕获这个panic的值，并且让程序正常执行下去。不会让程序crash。</p><p><strong>recover 用法：</strong></p><p>​```go<br>func main() {<br>   fmt.Println(“c”)<br>   defer func() { // 必须要先声明defer，否则不能捕获到panic异常<br>      fmt.Println(“d”)<br>      if err := recover(); err != nil {<br>         fmt.Println(err) // 这里的err其实就是panic传入的内容<br>      }<br>      fmt.Println(“e”)<br>   }()<br>   f() //开始调用f<br>   fmt.Println(“f”) //这里开始下面代码不会再执行<br>}</p><p>func f() {<br>   fmt.Println(“a”)<br>   panic(“异常信息”)<br>   fmt.Println(“b”) //这里开始下面代码不会再执行<br>}<br>——-output——-<br>c<br>a<br>d<br>异常信息<br>e<br>​```</p><h1 id="结构体（struct）和方法"><a href="#结构体（struct）和方法" class="headerlink" title="结构体（struct）和方法"></a>结构体（struct）和方法</h1><p>type关键字用来在Go语言中定义新的类型。</p><p>创造一个新类型</p><pre><code>type NewInt int</code></pre><p>类型别名（软链）</p><pre><code>var MyInt = int</code></pre><p>byte: uint8 和 rune:int32是Go语言内置的别名。</p><p>类型别名只在代码编写过程中生效，编译完不存在。</p><h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><p>​```go<br>    //结构体<br>    // 创在新的类型要使用type关键字<br>    type student struct {<br>        name   string<br>        age    int<br>        gender string<br>        hobby  []string<br>    }</p><pre><code>func main() {    var haojie = student{        name:   &quot;豪杰&quot;,        age:    19,        gender: &quot;男&quot;,        hobby:  []string{&quot;篮球&quot;, &quot;足球&quot;, &quot;双色球&quot;},    }    //结构体支持.访问属性    fmt.Println(haojie)    fmt.Println(haojie.name)    fmt.Println(haojie.age)    fmt.Println(haojie.gender)    fmt.Println(haojie.hobby)}</code></pre><p>​```</p><h2 id="结构体的实例化"><a href="#结构体的实例化" class="headerlink" title="结构体的实例化"></a>结构体的实例化</h2><p>​<code>govar haojie = student{        name:   &quot;豪杰&quot;,        age:    19,        gender: &quot;男&quot;,        hobby:  []string{&quot;篮球&quot;, &quot;足球&quot;, &quot;双色球&quot;},    }​</code></p><p><strong>结构体支持.访问属性</strong></p><p>​<code>gofmt.Println(haojie)    fmt.Println(haojie.name)    fmt.Println(haojie.age)    fmt.Println(haojie.gender)    fmt.Println(haojie.hobby)​</code></p><p><strong>实例化方法1</strong></p><p>​<code>go// struct是值类型的    // 如果初始化时没有给属性（字段）设置对应的初始值，那么对应属性就是其类型的默认值    var wangzhan = student{}    fmt.Println(wangzhan.name)    fmt.Println(wangzhan.age)    fmt.Println(wangzhan.gender)    fmt.Println(wangzhan.hobby)​</code></p><p><strong>实例化方法2 new(T) T:表示类型或结构体</strong></p><p>​<code>govar yawei = new(student)    fmt.Println(yawei)    // (*yawei).name    yawei.name = &quot;亚伟&quot;    yawei.age = 18    fmt.Println(yawei.name, yawei.age)    // 实例化方法3    var nazha = &amp;student{}    fmt.Println(nazha)    nazha.name = &quot;沙河娜扎&quot;    fmt.Println(nazha.name)​</code></p><h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><p>​<code>govar stu1 = student{        &quot;豪杰&quot;,        18,        &quot;男&quot;,        []string{&quot;男人&quot;, &quot;女人&quot;},    }    fmt.Println(stu1.name, stu1.age)    //键值对初始化    var stu2 = &amp;student{        name:   &quot;豪杰&quot;,        gender: &quot;男&quot;,    }    fmt.Println(stu2.name, stu2.age, stu2.gender)}​</code></p><h2 id="结构体的内存布局"><a href="#结构体的内存布局" class="headerlink" title="结构体的内存布局"></a>结构体的内存布局</h2><p>​```go<br>// 内存是以字节为单位的十六进制数<br>// 1字节 = 8位 = 8bit</p><p>func main() {<br>    type test struct {<br>        a int16<br>        b int16<br>        c int16<br>    }</p><pre><code>var t = test{    a: 1,    b: 2,    c: 3,}fmt.Println(&amp;(t.a))fmt.Println(&amp;(t.b))fmt.Println(&amp;(t.c))</code></pre><p>}</p><p>​```</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法就是某个具体的类型才能调用的函数，Go的方法是在函数前面加上一个接收者。</p><p>​```go<br>type people struct {<br>    name   string<br>    gender string<br>}</p><p>//函数指定接受者之后就是方法<br>// 在go语言中约定成俗不用this也不用self,而是使用后面类型的首字母的小写<br>func (p *people) dream() {<br>    p.gender = “男”<br>    fmt.Printf(“%s的梦想是不用上班也有钱拿！\n”, p.name)<br>}<br>func main() {<br>    var haojie = &amp;people{<br>        name:   “豪杰”,<br>        gender: “爷们”,<br>    }<br>    // (&amp;haojie).dream()<br>    haojie.dream()<br>    fmt.Println(haojie.gender)<br>}</p><p>​```</p><p>​```go<br>package main</p><p>import “fmt”</p><p>// 可以给任意类型追加方法<br>// 不能给别的包定义的类型添加方法</p><p>type MyInt int</p><p>func (m *MyInt) sayHi() {<br>    fmt.Println(“Hello MyInt~”)<br>}</p><p>func main() {<br>    var a MyInt<br>    fmt.Println(a)<br>    a.sayHi()<br>}</p><p>​```</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>​<code>go    func newStudent(n string, age int, g string, h []string) *student {        return &amp;student{            name:   n,            age:    age,            gender: g,            hobby:  h,        }​</code></p><h2 id="结构体的嵌套"><a href="#结构体的嵌套" class="headerlink" title="结构体的嵌套"></a>结构体的嵌套</h2><p>​```go<br>package main</p><p>import “fmt”</p><p>// 结构体内嵌模拟“继承”<br>type animal struct {<br>    name string<br>}</p><p>//定义一个动物会动的方法<br>func (a *animal) move() {<br>    fmt.Printf(“%s会动~\n”, a.name)<br>}</p><p>//定义一个狗的结构体<br>type dog struct {<br>    feet int<br>    animal<br>}</p><p>//定义了一个狗的方法 wangwang<br>func (d *dog) wangwang() {<br>    fmt.Printf(“%s 在叫：汪汪汪~\n”, d.name)<br>}</p><p>func main() {<br>    var a = dog{<br>        feet: 4,<br>        animal: animal{<br>            name: “旺财”,<br>        },<br>    }<br>    a.wangwang() //调用狗的方法<br>    a.move()     //调用动物的方法<br>}<br>​```</p><h2 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h2><p>​```go<br>package main</p><p>import “fmt”</p><p>// 匿名字段<br>type student struct {<br>    name string<br>    string<br>    int<br>}</p><p>func main() {<br>    var stu1 = student{<br>        name: “豪杰”,<br>    }<br>    fmt.Println(stu1.name)<br>    fmt.Println(stu1.string)<br>    fmt.Println(stu1.int)<br>}<br>​```</p><p>```</p>]]></content>
      
      
      <categories>
          
          <category> GO语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO语言第四天 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言第三天</title>
      <link href="/2021/06/28/GO%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E5%A4%A9%20/"/>
      <url>/2021/06/28/GO%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%89%E5%A4%A9%20/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。<br><a href="https://img-blog.csdnimg.cn/img_convert/b3bbcc9fda936dc90d1de9d7af10bbe0.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/b3bbcc9fda936dc90d1de9d7af10bbe0.png#pic_center" class="lazyload"></a></p><h2 id="声明一维数组"><a href="#声明一维数组" class="headerlink" title="声明一维数组"></a>声明一维数组</h2><p>语法：</p><pre><code>var variable_name [SIZE] variable_type</code></pre><p>实例：</p><pre><code>var balance [10] float32</code></pre><h2 id="初始化一维数组"><a href="#初始化一维数组" class="headerlink" title="初始化一维数组"></a>初始化一维数组</h2><pre><code>var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}</code></pre><hr><pre><code>balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}</code></pre><p>如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度：</p><pre><code>var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}或者balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}</code></pre><h2 id="一维数组遍历"><a href="#一维数组遍历" class="headerlink" title="一维数组遍历"></a>一维数组遍历</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a1 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> a1 &#123;</span><br><span class="line">other := <span class="number">9</span> - value</span><br><span class="line"><span class="keyword">for</span> index2 := index + <span class="number">1</span>; index2 &lt; <span class="built_in">len</span>(a1); index2++ &#123;</span><br><span class="line"><span class="keyword">if</span> a1[index2] == other &#123;</span><br><span class="line"><span class="comment">// 另一半在数组中，把它们的索引打印出来</span></span><br><span class="line">fmt.Printf(<span class="string">"它们的索引是：(%d %d)\n"</span>, index, index2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>完整实例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义一个数组[1,3,5,7,8]，求数组中所有元素的和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a1 := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">fmt.Println(a1)</span><br><span class="line"><span class="comment">// // 1. 数组求和</span></span><br><span class="line"><span class="comment">// sum := 0</span></span><br><span class="line"><span class="comment">// // := 相当于声明变量并且赋值</span></span><br><span class="line"><span class="comment">// for _, v := range a1 &#123;</span></span><br><span class="line"><span class="comment">// // fmt.Println(v)</span></span><br><span class="line"><span class="comment">// sum = sum + v</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// fmt.Println(sum)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 找出数组中和为指定值的两个元素的下标，比如从数组[1,3,5,7,8]中找出和为8的两个元素的下标分别为(0,3)和(1,2)。</span></span><br><span class="line"><span class="comment">//   遍历数组，</span></span><br><span class="line"><span class="comment">// 2.1依次取出每个元素</span></span><br><span class="line"><span class="comment">// 2.2 计算一下 other= 8-当前值</span></span><br><span class="line"><span class="comment">// 2.3 在不在数组中，在的话把索引拿出来</span></span><br><span class="line"><span class="comment">// [1, 3, 5, 7, 8]</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> a1 &#123;</span><br><span class="line">other := <span class="number">9</span> - value</span><br><span class="line"><span class="keyword">for</span> index2 := index + <span class="number">1</span>; index2 &lt; <span class="built_in">len</span>(a1); index2++ &#123;</span><br><span class="line"><span class="keyword">if</span> a1[index2] == other &#123;</span><br><span class="line"><span class="comment">// 另一半在数组中，把它们的索引打印出来</span></span><br><span class="line">fmt.Printf(<span class="string">"它们的索引是：(%d %d)\n"</span>, index, index2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>语法:</p><pre><code>　     var 数组名 [大小][大小]类型</code></pre><p>比如: </p><pre><code>var b [3][2]intb = [3][2]int{        [2]int{1, 2},        [2]int{3, 4},}</code></pre><p>声明同时赋值：</p><pre><code>var c = [3][2]int{   {1, 2},   {3, 4},   {5, 6},}</code></pre><p>多维数组遍历：</p><pre><code>for i := 0; i &lt; len(d); i++ {        for j := 0; j &lt; len(d[i]); j++ {           fmt.Printf(&quot;%d-%d\n&quot;, i, d[i][j])       }    }</code></pre><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片和数组相似,它们都是保存相同数组类型元素的容器,但是切片的元素个数是可变的, 数组不可变</p><p>切片不需要明确指定元素的个数</p><h2 id="切片创建"><a href="#切片创建" class="headerlink" title="切片创建"></a>切片创建</h2><p>1.方式一：</p><pre><code>var s []int  //创建int类型切片var s []string  //创建string类型切片</code></pre><p>2.通过 make() 函数创建切片：</p><pre><code>slice := make([]int, 5)</code></pre><p>内部实现：</p><p>切片是一个很小的对象,它对底层的数组(内部是通过数组保存数据的)进行了抽象,并提供相关的操作方法;</p><p>切片是有三个字段的数据结构,这些数据结构包含Go语言需要操作底层数组的元数据</p><p><a href="https://img-blog.csdnimg.cn/img_convert/680a8e5fffdbe4b1929676129d78f1c0.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/680a8e5fffdbe4b1929676129d78f1c0.png#pic_center" class="lazyload"></a></p><p>使用append可以往切片里添加元素：</p><pre><code>var a = []int{} //空切片a = append(a, 1)</code></pre><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p><h2 id="声明类型"><a href="#声明类型" class="headerlink" title="声明类型"></a>声明类型</h2><p> <strong>声明map类型</strong></p><pre><code>var m1 map[string]int                       //未初始化就是 nil</code></pre><p><strong>使用make初始化map</strong></p><pre><code>m1 = make(map[string]int, 100)m1[&quot;nazha&quot;] = 90m1[&quot;haojie&quot;] = 100</code></pre><p><strong>声明map类型时直接初始化</strong></p><pre><code>m2 := map[string]string{        &quot;haojie&quot;: &quot;hehe&quot;,        &quot;yawei&quot;:  &quot;heihei&quot;,    }</code></pre><h2 id="map的键值对操作"><a href="#map的键值对操作" class="headerlink" title="map的键值对操作"></a>map的键值对操作</h2><p><strong>遍历键值对</strong></p><pre><code>for k, v := range m2 {        fmt.Println(k, v)    }</code></pre><p><strong>遍历键</strong></p><pre><code>for k := range m2 {        fmt.Println(k)    }</code></pre><p><strong>判断map中是否存在某个键值对</strong></p><pre><code>v, ok := m2[&quot;haojie&quot;]    // ok返回的是布尔值，能取到就返回true，取不到就返回false    if !ok {        fmt.Println(&quot;查无此人&quot;)    } else {        fmt.Println(v)    }</code></pre><p><strong>删除键值对</strong></p><pre><code>delete(m2, &quot;haojie&quot;)</code></pre><h1 id="Map和切片操作"><a href="#Map和切片操作" class="headerlink" title="Map和切片操作"></a>Map和切片操作</h1><h2 id="切片的元素是map"><a href="#切片的元素是map" class="headerlink" title="切片的元素是map"></a>切片的元素是map</h2><p><strong>初始化切片</strong></p><pre><code>mapSlice := make([]map[string]int, 3, 10)</code></pre><p><strong>添加元素</strong></p><pre><code>mapSlice = append(mapSlice, map[string]int{&quot;aaa&quot;: 10})mapSlice = append(mapSlice, map[string]int{&quot;bbb&quot;: 100})</code></pre><h2 id="map中元素的值是切片"><a href="#map中元素的值是切片" class="headerlink" title="map中元素的值是切片"></a>map中元素的值是切片</h2><p> <strong>对外层的map做初始化</strong></p><pre><code>sliceMap := make(map[string][]int, 10)</code></pre><p><strong>对map的值（切片）做初始化</strong></p><pre><code>sliceMap[&quot;haojie&quot;] = make([]int, 3, 10)sliceMap[&quot;haojie&quot;][0] = 1sliceMap[&quot;haojie&quot;][1] = 2sliceMap[&quot;haojie&quot;][2] = 3</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Go 语言函数定义格式如下：</p><pre><code>func function_name( [parameter list] ) [return_types] {   函数体}</code></pre><p>函数定义解析：</p><ul><li>func：函数由 func 开始声明</li><li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li><li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li><li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li><li>函数体：函数定义的代码集合。</li></ul><p><strong>没有参数没有返回值的函数</strong></p><pre><code>func sayHello() {    fmt.Println(&quot;Hello 沙河！&quot;)}</code></pre><p><strong>带参数的函数</strong></p><pre><code>func sayHi(name string) {    fmt.Printf(&quot;Hello %s\n&quot;, name)}</code></pre><p><strong>带参数和返回值</strong></p><pre><code>func add(a int, b int) int {ret := a + breturn ret}</code></pre><hr><pre><code>func add3(a, b int) (ret int) {    ret = a + b    return}</code></pre><p>可变参数</p><pre><code>func add4(a int, b ...int) int {    ret := a    fmt.Println(a)    fmt.Printf(&quot;b=%v type:%T\n&quot;, b, b)    for _, v := range b {        ret = ret + v    }    return ret}</code></pre><hr><pre><code>func add5() (int, int, int) {    return 1, 2, 3}</code></pre><p><strong>函数可以作为变量、参数、返回值</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数可以作为变量、参数、返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calc是一个函数，它接收三个参数，返回一个int类型的返回值</span></span><br><span class="line"><span class="comment">// 其中，参数a和b是int类型</span></span><br><span class="line"><span class="comment">// 参数f 是一个函数类型，这个函数接收两个int类型的参数，返回一个int类型的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(a, b <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> f(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := add</span><br><span class="line">fmt.Printf(<span class="string">"f1:%T\n"</span>, f1)</span><br><span class="line">fmt.Println(f1(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//把add当成一个参数传进calc中</span></span><br><span class="line">ret := calc(<span class="number">100</span>, <span class="number">200</span>, add)</span><br><span class="line">fmt.Println(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把sub当成一个参数传进calc中</span></span><br><span class="line">ret = calc(<span class="number">100</span>, <span class="number">200</span>, sub)</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>匿名函数</strong><br>匿名函数由一个不带函数名的函数声明和函数体组成，如下所示：</p><pre><code>func（a,b int,z float64） bool{                return a*b            } </code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello world!"</span>)</span><br><span class="line">&#125;()     <span class="comment">//   花括号后加()表示函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h2><p>闭包函数，即在一个封闭作用域中的函数，这个函数可以使用封闭作用域中的所有变量。也就是使用该函数时除了函数中的变量（函数变量）还可以对闭包中的函数（自由变量进行操作）</p><p>示例一：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数f1</span></span><br><span class="line"><span class="comment">// f1不接受参数</span></span><br><span class="line"><span class="comment">// f1返回一个函数类型，这个函数不接收参数也没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"找到外层函数的变量num"</span>, num)</span><br><span class="line"><span class="keyword">return</span> num + x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>示例二：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffixFunc</span><span class="params">(suffix <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line"><span class="keyword">return</span> name + suffix</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>示例三：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calc</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">add := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">base += i <span class="comment">// 引用了外层的base变量同时还修改了base</span></span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">base -= i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> add, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="延迟语句defer"><a href="#延迟语句defer" class="headerlink" title="延迟语句defer"></a>延迟语句defer</h2><p>Go语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testDefer</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"函数马上要结束了..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">testDefer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><p> <strong>打印200~1000之间的质数(素数)</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">200</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="comment">// fmt.Println(i)</span></span><br><span class="line">flag := <span class="literal">true</span></span><br><span class="line"><span class="comment">//判断i是否为质数,如果是就打印,如果不是就不打印</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">2</span>; j &lt; i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> i%j == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//不是质数</span></span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整个第二层的for循环结束了还没有break说明是质数</span></span><br><span class="line"><span class="keyword">if</span> flag &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d是质数."</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>打印9*9乘法表</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := i; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d*%d=%d\t"</span>, j, i, i*j)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> GO语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO语言第三天 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言第二天</title>
      <link href="/2021/06/26/GO%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
      <url>/2021/06/26/GO%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> </span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">m <span class="keyword">int</span></span><br><span class="line">    n <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"nazha"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    age := <span class="number">18</span><span class="comment">//声明变量age同时初始化;编译器会根据右边的初始值推断出age是什么类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> KB = <span class="number">1024</span></span><br></pre></td></tr></table></figure></div><h1 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h1><p>Go中借助iota来实现枚举</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">n2        <span class="comment">//1</span></span><br><span class="line">n3        <span class="comment">//2</span></span><br><span class="line">n4        <span class="comment">//3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><ul><li>iota在const关键字出现时将被重置为0</li><li>const中每新增一行常量声明将使iota累加一次</li><li>const声明的常量后面没有内容默认就跟上一行一致</li></ul><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre><code>使用双引号表示字符串 &quot;hello&quot;使用单引号表示字符   &apos;h&apos;字符串的常用方法</code></pre><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><pre><code>int int8 int16 int32 int64uint uint8 uint16 uint32 uint64</code></pre><p>int是特殊的,会根据你的操作系统的位数来决定是int32还是int64</p><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>float32 flot64</p><p>浮点数永远都是不精确.</p><ul><li>转换成字符串去做运算</li><li>整体放大多少倍转换成整数进行运算</li></ul><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>complex64和complex128</p><h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><pre><code>var a bool//默认是falsevar b = true</code></pre><p>Go语言中布尔类型不能和其他类型做类型转换</p><h2 id="byte和rune"><a href="#byte和rune" class="headerlink" title="byte和rune"></a>byte和rune</h2><pre><code>英文字符用byte(ASCII码能表示的)   01010101 rune(中文,UTF8编码)   01010101   01010101   01010101 </code></pre><h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><h2 id="IF语句"><a href="#IF语句" class="headerlink" title="IF语句"></a>IF语句</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">age := <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age&gt;<span class="number">18</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="number">20</span> &gt; <span class="number">18</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时age只在if语句中有效</span></span><br><span class="line"><span class="keyword">if</span> age:=<span class="number">20</span>;age&gt;<span class="number">18</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准for循环</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似while循环</span></span><br><span class="line">n := <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> n&gt;<span class="number">0</span> &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    n--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无限循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="switch和case"><a href="#switch和case" class="headerlink" title="switch和case"></a>switch和case</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> n&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> n&gt;<span class="number">0</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> n ==<span class="number">0</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h2><p> Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">        fmt.Println(<span class="string">"The integer was &lt;= 4"</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">        fmt.Println(<span class="string">"The integer was &lt;= 5"</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">        fmt.Println(<span class="string">"The integer was &lt;= 6"</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">        fmt.Println(<span class="string">"The integer was &lt;= 7"</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">        fmt.Println(<span class="string">"The integer was &lt;= 8"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"default case"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>输出结果：</p><pre><code>The integer was &lt;= 5The integer was &lt;= 6The integer was &lt;= 7The integer was &lt;= 8</code></pre><p><strong>fallthrough不能用在switch的最后一个分支。</strong></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>Go 语言内置的运算符有：</p><p>算术运算符<br><a href="https://img-blog.csdnimg.cn/img_convert/84e0baaaa417affbb891b0e38dabb861.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/84e0baaaa417affbb891b0e38dabb861.png#pic_center" class="lazyload"></a></p><p>关系运算符<br><a href="https://img-blog.csdnimg.cn/img_convert/dddee0298e3e40fae51ff3e67447ca04.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/dddee0298e3e40fae51ff3e67447ca04.png#pic_center" class="lazyload"></a></p><p>逻辑运算符<br><a href="https://img-blog.csdnimg.cn/img_convert/4544d772cf877b26573defd9b79ef670.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/4544d772cf877b26573defd9b79ef670.png#pic_center" class="lazyload"></a></p><p>位运算符<br><a href="https://img-blog.csdnimg.cn/img_convert/392b7954e77afb7f9fcfcedb4fb7dba6.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/392b7954e77afb7f9fcfcedb4fb7dba6.png#pic_center" class="lazyload"></a></p><p>赋值运算符<br><a href="https://img-blog.csdnimg.cn/img_convert/3417a623fcfb4fcbfdf9d023e8993f1c.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/3417a623fcfb4fcbfdf9d023e8993f1c.png#pic_center" class="lazyload"></a><br>其他<br><a href="https://img-blog.csdnimg.cn/img_convert/1e3095f2ee52e5d095cb38dbebd2d3e7.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/1e3095f2ee52e5d095cb38dbebd2d3e7.png#pic_center" class="lazyload"></a><br>案例：</p><p>以下假设A = 60 , B = 13 ，A的8位二进制：00111100 ，B的8位二进制：00001101</p><p>按位与运算符&amp;：</p><pre><code>A：   0 0 1 1 1 1 0 0 B：   0 0 0 0 1 1 0 1A&amp;B： 0 0 0 0 1 1 0 0 对应位比较，如果都为1，那么按位与的结果为1，否则为0</code></pre><p>按位或运算符|：</p><pre><code>A：   0 0 1 1 1 1 0 0 B：   0 0 0 0 1 1 0 1A|B： 0 0 1 1 1 1 0 1 对应位比较，只要有一个为1，那么按位或的结果为1，否则为0</code></pre><p>按位异或运算符^：</p><pre><code>A：   0 0 1 1 1 1 0 0 B：   0 0 0 0 1 1 0 1A^B： 0 0 1 1 0 0 0 1 对应位比较，只要不相同就为1，否则为0</code></pre><p>左移运算符&lt;&lt;</p><pre><code>A：   0 0 1 1 1 1 0 0 A&lt;&lt;2: 1 1 1 1 0 0 0 0A&lt;&lt;3: 1 1 1 0 0 0 0 0各二进位全部左移n位,超出总位数就丢弃在不丢弃的情况下，相当于10进制上乘以了2的n次方</code></pre><p>右移运算符&gt;&gt;</p><pre><code>A：   0 0 1 1 1 1 0 0 A&gt;&gt;2: 0 0 0 0 1 1 1 1A&gt;&gt;3: 0 0 0 0 0 1 1 1各二进位全部右移n位,超出范围就丢弃在不丢弃的情况下，相当于10进制上除以了2的n次方</code></pre>]]></content>
      
      
      <categories>
          
          <category> GO语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO语言第二天 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言第一天</title>
      <link href="/2021/05/26/GO%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2021/05/26/GO%E8%AF%AD%E8%A8%80%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.自选以下任意地址进行安装包下载：</p><p>下载地址1:<a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a></p><p><a href="https://img-blog.csdnimg.cn/20200723182358263.png#pic_center#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200723182358263.png#pic_center#pic_center" class="lazyload"></a></p><p>下载地址2:<a href="https://golang.google.cn/" target="_blank" rel="noopener">https://golang.google.cn/</a><br><a href="https://img-blog.csdnimg.cn/20200723182300587.png#pic_center#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20200723182300587.png#pic_center#pic_center" class="lazyload"></a><br>2.下载好安装程序包进行安装，一路next下去，即可完成安装。</p><p>安装完成后，在我们所设置的安装目录下将生成一些目录和文件，如下图所示：<br><a href="https://img-blog.csdnimg.cn/img_convert/6c68d09f5ecaee7cc6fbe40da4282b3e.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/6c68d09f5ecaee7cc6fbe40da4282b3e.png#pic_center" class="lazyload"></a></p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>开发包安装完成后，我们还需要配置一下GOPATH 环境变量，之后才可以使用Go语言进行开发。GOPATH 是一个路径，用来存放开发中需要用到的代码包。</p><p>在桌面或者资源管理器右键“此电脑”（或者“我的电脑”）→“属性”→“高级系统设置”→“环境变量”，如下图所示。<br><a href="https://img-blog.csdnimg.cn/img_convert/2bcb2bfb734ae641558ea10ad02ad541.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/2bcb2bfb734ae641558ea10ad02ad541.png#pic_center" class="lazyload"></a><br>在弹出的菜单里找到 GOPATH 对应的选项点击编辑之后就可以修改了，没有的话可以选择新建，并将变量名填写为 GOPATH，变量值设置为任意目录均可（尽量选择空目录），例如 D:\Go。</p><p><a href="https://img-blog.csdnimg.cn/img_convert/1abb13f89c2c8dad40410f70331ec80a.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/1abb13f89c2c8dad40410f70331ec80a.png#pic_center" class="lazyload"></a><br>在GOPATH目录下新建三个文件夹.</p><p>我们的开发的代码都放在src目录下:</p><p><a href="https://img-blog.csdnimg.cn/20210414220041902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MDY2NjI4,size_16,color_FFFFFF,t_70#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20210414220041902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MDY2NjI4,size_16,color_FFFFFF,t_70#pic_center" class="lazyload"></a></p><p>其它的环境变量安装包均会进行自动设置。在默认情况下，Go 将会被安装在目录 c:\go 下，但如果你在安装过程中修改安装目录，则可能需要手动修改所有的环境变量的值。</p><p>环境变量设置好后，可以通过go env 命令来进行测试。<br><a href="https://img-blog.csdn.net/20160118173339514#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdn.net/20160118173339514#pic_center" class="lazyload"></a></p><h2 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h2><p>下载:<a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">https://code.visualstudio.com/Download</a></p><p>安装:下载好安装程序包进行安装，一路next下去，即可完成安装。<br>配置：<br>安装中文简体插件<br><a href="https://img-blog.csdnimg.cn/20210414220402684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MDY2NjI4,size_16,color_FFFFFF,t_70#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20210414220402684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MDY2NjI4,size_16,color_FFFFFF,t_70#pic_center" class="lazyload"></a><br>安装Go语言开发工具<br><a href="https://img-blog.csdnimg.cn/20210414220432877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MDY2NjI4,size_16,color_FFFFFF,t_70#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20210414220432877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MDY2NjI4,size_16,color_FFFFFF,t_70#pic_center" class="lazyload"></a><br>到此就完成了环境搭建步骤，下面写一个程序测试一下吧。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"hello 010"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> GO语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO语言第一天 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyMongo操作大全</title>
      <link href="/2021/03/18/PyMongo%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/"/>
      <url>/2021/03/18/PyMongo%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PyMongo"><a href="#PyMongo" class="headerlink" title="PyMongo"></a>PyMongo</h1><p>安装：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pymongo</span><br></pre></td></tr></table></figure></div><p>一、数据库连接<br>数据库连接，无密码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库链接，必须保证当前系统能正常访问mongodb!!!</span></span><br><span class="line">connect = MongoClient(<span class="string">'mongodb://127.0.0.1:27017/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建/切换数据库，数据库不存在则会库中有文档以后，自动创建</span></span><br><span class="line">my_db = connect[<span class="string">'mofang'</span>]</span><br><span class="line">print(my_db)  <span class="comment"># 数据库信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建/进入集合，集合不存在则会集合中有文档以后，自动创建</span></span><br><span class="line">my_collections = my_db[<span class="string">'my_collections'</span>]</span><br><span class="line">print(my_collections)  <span class="comment"># 集合信息</span></span><br></pre></td></tr></table></figure></div><p><strong>数据库连接，有密码</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line"># 数据库链接，必须保证当前系统能正常访问mongodb!!!</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;方式1：如果帐号密码没有特殊字符&quot;&quot;&quot;</span><br><span class="line"># connect &#x3D; MongoClient(&#39;mongodb:&#x2F;&#x2F;mofang:123456@127.0.0.1:27017&#x2F;mofang&#39;)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;方式2：当前库的管理员连接&quot;&quot;&quot;</span><br><span class="line"># from urllib import parse</span><br><span class="line"></span><br><span class="line"># username &#x3D; parse.quote_plus(&#39;mofang&#39;)  # 对用户名进行编码</span><br><span class="line"># password &#x3D; parse.quote_plus(&#39;123456&#39;)  # 对密码进行编码</span><br><span class="line"># database &#x3D; parse.quote_plus(&#39;mofang&#39;)  # 对数据库进行编码</span><br><span class="line"># connect &#x3D; MongoClient(&#39;mongodb:&#x2F;&#x2F;%s:%s@127.0.0.1:27017&#x2F;%s&#39; % (username, password, database))</span><br><span class="line"># my_db &#x3D; connect[&#39;mofang&#39;]</span><br><span class="line"># my_collections &#x3D; my_db[&#39;my_collections&#39;]</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;方式3：基于超级管理员身份连接，不需要当前库的管理员了&quot;&quot;&quot;</span><br><span class="line">from urllib import parse</span><br><span class="line">username &#x3D; parse.quote_plus(&#39;root&#39;)  # 对用户名进行编码</span><br><span class="line">password &#x3D; parse.quote_plus(&#39;123&#39;)  # 对密码进行编码</span><br><span class="line">database &#x3D; parse.quote_plus(&#39;admin&#39;)  # 对数据库进行编码</span><br><span class="line">connect &#x3D; MongoClient(&#39;mongodb:&#x2F;&#x2F;%s:%s@127.0.0.1:27017&#x2F;%s&#39; % (username, password, database))</span><br><span class="line">my_db &#x3D; connect[&#39;mofang&#39;]</span><br><span class="line">my_collections &#x3D; my_db[&#39;my_collections&#39;]</span><br><span class="line"># 添加一篇文档</span><br><span class="line">data &#x3D; &#123;&#39;name&#39;: &#39;xiaoming1号&#39;, &#39;sex&#39;: True, &#39;age&#39;:17&#125;</span><br><span class="line">ret &#x3D; my_collections.insert_one(data)</span><br><span class="line">print(ret.inserted_id)</span><br></pre></td></tr></table></figure></div><h2 id="二、数据库管理"><a href="#二、数据库管理" class="headerlink" title="二、数据库管理"></a>二、数据库管理</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line"># 数据库链接，必须保证当前系统能正常访问mongodb!!!</span><br><span class="line"></span><br><span class="line">connect &#x3D; MongoClient(&#39;mongodb:&#x2F;&#x2F;root:123@127.0.0.1:27017&#x2F;admin&#39;)</span><br><span class="line">my_db &#x3D; connect[&#39;mofang&#39;]</span><br><span class="line">my_collecctions &#x3D; my_db[&#39;my_collections&#39;]</span><br><span class="line"></span><br><span class="line"># 查看所有数据库[除了三个基本数据库以外，其他数据库只会显示有文档数据的]</span><br><span class="line">ret &#x3D; connect.list_database_names()</span><br><span class="line">print(ret)  # [&#39;admin&#39;, &#39;config&#39;, &#39;local&#39;, &#39;mofang&#39;]</span><br><span class="line">ret &#x3D; my_db.list_collection_names()</span><br><span class="line">print(ret)  # [&#39;my_collections&#39;]</span><br><span class="line"></span><br><span class="line"># 数据库的删除,仅仅是清空所有集合就可以了</span><br></pre></td></tr></table></figure></div><h2 id="三、集合管理"><a href="#三、集合管理" class="headerlink" title="三、集合管理"></a>三、集合管理</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line"># 数据库链接，必须保证当前系统能正常访问mongodb!!!</span><br><span class="line"></span><br><span class="line">connect &#x3D; MongoClient(&#39;mongodb:&#x2F;&#x2F;root:123@127.0.0.1:27017&#x2F;admin&#39;)</span><br><span class="line">my_db &#x3D; connect[&#39;mofang&#39;]</span><br><span class="line">my_collecctions &#x3D; my_db[&#39;my_collections&#39;]</span><br><span class="line"></span><br><span class="line"># 查看所有数据库[除了三个基本数据库以外，其他数据库只会显示有文档数据的]</span><br><span class="line"># ret &#x3D; connect.list_database_names()</span><br><span class="line"># print(ret)  # [&#39;admin&#39;, &#39;config&#39;, &#39;local&#39;, &#39;mofang&#39;]</span><br><span class="line"># ret &#x3D; my_db.list_collection_names()</span><br><span class="line"># print(ret)  # [&#39;my_collections&#39;]</span><br><span class="line"># 删除集合的方式1</span><br><span class="line">my_collecctions &#x3D; my_db[&#39;notify_list&#39;]</span><br><span class="line">my_collecctions.drop()</span><br><span class="line"></span><br><span class="line"># 删除集合的方式2</span><br><span class="line">my_db.drop_collection(&#39;notify_list&#39;)</span><br></pre></td></tr></table></figure></div><h2 id="四、文档管理"><a href="#四、文档管理" class="headerlink" title="四、文档管理"></a>四、文档管理</h2><h3 id="1-添加文档"><a href="#1-添加文档" class="headerlink" title="1.添加文档"></a>1.添加文档</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line"># 数据库链接，必须保证当前系统能正常访问mongodb!!!</span><br><span class="line">connect &#x3D; MongoClient(&#39;mongodb:&#x2F;&#x2F;root:123@127.0.0.1:27017&#x2F;admin&#39;)</span><br><span class="line">my_db &#x3D; connect[&#39;mofang&#39;]</span><br><span class="line">my_collections &#x3D; my_db[&#39;my_collections&#39;]</span><br><span class="line"></span><br><span class="line"># 添加一条数据</span><br><span class="line">document &#x3D; &#123;&#39;name&#39;: &#39;xiaoming&#39;, &#39;mobile&#39;: &#39;13012345678&#39;, &#39;age&#39;: 16, &#39;sex&#39;: True&#125;</span><br><span class="line">ret &#x3D; my_collections.insert_one(document)</span><br><span class="line">print(ret.inserted_id)  # 返回主键ID</span><br><span class="line"></span><br><span class="line"># 添加多条数据</span><br><span class="line">data_list &#x3D; [</span><br><span class="line">    &#123; &quot;name&quot;: &quot;xiaobai&quot;, &quot;mobile&quot;: &quot;13322345678&quot;,&quot;age&quot;:16,&quot;sex&quot;:False&#125;,</span><br><span class="line">    &#123; &quot;name&quot;: &quot;xiaohei&quot;, &quot;mobile&quot;: &quot;13322345678&quot;,&quot;age&quot;:20,&quot;sex&quot;:True&#125;,</span><br><span class="line">    &#123; &quot;name&quot;: &quot;xiaohong&quot;, &quot;mobile&quot;: &quot;13322345678&quot;,&quot;age&quot;:13,&quot;sex&quot;:False&#125;,</span><br><span class="line">    &#123; &quot;name&quot;: &quot;xiaolan&quot;, &quot;mobile&quot;: &quot;13322345678&quot;,&quot;age&quot;:17,&quot;sex&quot;:True&#125;,</span><br><span class="line">    &#123; &quot;name&quot;: &quot;xiaolv&quot;, &quot;mobile&quot;: &quot;13322345678&quot;,&quot;age&quot;:17,&quot;sex&quot;:True&#125;,</span><br><span class="line">    &#123; &quot;name&quot;: &quot;xiaolong&quot;, &quot;mobile&quot;: &quot;13322345678&quot;,&quot;age&quot;:16,&quot;sex&quot;:False&#125;,</span><br><span class="line">    &#123; &quot;name&quot;: &quot;xiaofei&quot;, &quot;mobile&quot;: &quot;13322345678&quot;,&quot;age&quot;:18,&quot;sex&quot;:True&#125;,</span><br><span class="line">]</span><br><span class="line">ret &#x3D; my_collections.insert_many(data_list)</span><br><span class="line">print(ret.inserted_ids)</span><br></pre></td></tr></table></figure></div><h3 id="2-查询文档"><a href="#2-查询文档" class="headerlink" title="2.查询文档"></a>2.查询文档</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line"></span><br><span class="line"># 数据库链接，必须保证当前系统能正常访问mongodb</span><br><span class="line">connect &#x3D; MongoClient(&#39;mongodb:&#x2F;&#x2F;root:123@127.0.0.1:27017&#x2F;admin&#39;)</span><br><span class="line">my_db &#x3D; connect[&#39;mofang&#39;]</span><br><span class="line">my_collections &#x3D; my_db[&#39;my_collections&#39;]</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;获取一条&quot;&quot;&quot;</span><br><span class="line"># document &#x3D; my_collections.find_one()</span><br><span class="line"># print(document)  # &#123;&#39;_id&#39;: ObjectId(&#39;5fd21237d883925209b60067&#39;), &#39;name&#39;: &#39;xiaoming1号&#39;, &#39;sex&#39;: True, &#39;age&#39;: 17&#125;</span><br><span class="line"># 获取数据中的信息</span><br><span class="line"># print(document[&#39;name&#39;])  # xiaoming1号</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;获取多条数据&quot;&quot;&quot;</span><br><span class="line"># document_list &#x3D; my_collections.find()</span><br><span class="line"># print(document_list)</span><br><span class="line"># for document in document_list:</span><br><span class="line">#     print(document)</span><br><span class="line">#     print(document[&#39;_id&#39;])</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;字段投影：只显示部分字段，1表示显示，0表示隐藏&quot;&quot;&quot;</span><br><span class="line"># document_list &#x3D; my_collections.find(&#123;&#125;, &#123;&#39;name&#39;: 1, &#39;_id&#39;: 0&#125;)</span><br><span class="line"># for document in document_list:</span><br><span class="line">#     print(document)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;基于查询条件获取数据&quot;&quot;&quot;</span><br><span class="line"># 值相等</span><br><span class="line"># query &#x3D; &#123;&#39;name&#39;: &#123;&#39;$eq&#39;: &#39;xiaoming&#39;&#125;&#125;</span><br><span class="line"># query &#x3D; &#123;&#39;name&#39;: &#39;xiaoming&#39;&#125;</span><br><span class="line"># document &#x3D; my_collections.find_one(query)</span><br><span class="line"># print(document)  # &#123;&#39;_id&#39;: ObjectId(&#39;5fd2184326c8493bb4e2ace3&#39;), &#39;name&#39;: &#39;xiaoming&#39;, &#39;mobile&#39;: &#39;13012345678&#39;, &#39;age&#39;: 16, &#39;sex&#39;: True&#125;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">query &#x3D; &#123;&quot;age&quot;:&#123;&quot;$gt&quot;:17&#125;&#125;    age  &gt;  17</span><br><span class="line">query &#x3D; &#123;&quot;age&quot;:&#123;&quot;$gte&quot;:17&#125;&#125;    age &gt;&#x3D; 17</span><br><span class="line">query &#x3D; &#123;&quot;age&quot;:&#123;&quot;$lte&quot;:17&#125;&#125;    age &lt;&#x3D; 17</span><br><span class="line">query &#x3D; &#123;&quot;age&quot;:&#123;&quot;$lt&quot;:17&#125;&#125;    age  &lt;  17</span><br><span class="line">query &#x3D; &#123;&quot;age&quot;:&#123;&quot;$ne&quot;:17&#125;&#125;    age  !&#x3D; 17</span><br><span class="line">query &#x3D; &#123;&quot;age&quot;:&#123;&quot;$in&quot;:[16,17]&#125;&#125;    age in [16,17]</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># query &#x3D; &#123;&#39;age&#39;: &#123;&#39;$in&#39;: [16, 18]&#125;&#125;</span><br><span class="line"># document_list &#x3D; my_collections.find(query)</span><br><span class="line"># for document in document_list:</span><br><span class="line">#     print(document)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;排序&quot;&quot;&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">单个字段：</span><br><span class="line">    sort(&quot;age&quot;,-1) # 倒序</span><br><span class="line">    sort(&quot;age&quot;,1)  # 升序</span><br><span class="line">多个字段：</span><br><span class="line">    sort([(&quot;age&quot;,-1),(&quot;_id&quot;,1)])</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># document_list &#x3D; my_collections.find().sort(&#39;age&#39;, -1)</span><br><span class="line"># document_list &#x3D; my_collections.find().sort([(&#39;age&#39;, -1), (&#39;_id&#39;, 1)])</span><br><span class="line"># for document in document_list:</span><br><span class="line">#     print(document)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;限制结果&quot;&quot;&quot;</span><br><span class="line">document_list &#x3D; my_collections.find().limit(3)</span><br><span class="line">for document in document_list:</span><br><span class="line">    print(document)</span><br></pre></td></tr></table></figure></div><h3 id="3-删除文档"><a href="#3-删除文档" class="headerlink" title="3.删除文档"></a>3.删除文档</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line"># 数据库链接，必须保证当前系统能正常访问mongodb</span><br><span class="line">connect &#x3D; MongoClient(&#39;mongodb:&#x2F;&#x2F;root:123@127.0.0.1:27017&#x2F;admin&#39;)</span><br><span class="line">my_db &#x3D; connect[&#39;mofang&#39;]</span><br><span class="line">my_collections &#x3D; my_db[&#39;my_collections&#39;]</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;删除文档&quot;&quot;&quot;</span><br><span class="line"># 删除一个文档</span><br><span class="line">query &#x3D; &#123;&#39;name&#39;: &#39;xiaoming&#39;&#125;</span><br><span class="line">ret &#x3D; my_collections.delete_one(query)</span><br><span class="line">print(ret.deleted_count)  # 1:删除成功 0:没有删除的数据</span><br><span class="line"></span><br><span class="line"># 删除多个文档</span><br><span class="line">query &#x3D; &#123;&#39;name&#39;: &#39;xiaoming1号&#39;&#125;</span><br><span class="line">ret &#x3D; my_collections.delete_many(query)</span><br><span class="line">print(ret.deleted_count)  # 大于0:删除成功 0:没有删除的数据</span><br><span class="line"></span><br><span class="line"># 查询一条数据出来并删除</span><br><span class="line"># 返回一条数据，如果没有，则返回None</span><br><span class="line">query &#x3D; &#123;&#39;name&#39;: &#39;xiaobai&#39;&#125;</span><br><span class="line">document &#x3D; my_collections.find_one_and_delete(query)</span><br><span class="line">print(document)  # &#123;&#39;_id&#39;: ObjectId(&#39;5fd218accf506de09fbecd68&#39;), &#39;name&#39;: &#39;xiaobai&#39;, &#39;mobile&#39;: &#39;13322345678&#39;, &#39;age&#39;: 16, &#39;sex&#39;: False&#125;</span><br></pre></td></tr></table></figure></div><h3 id="4-更新文档"><a href="#4-更新文档" class="headerlink" title="4.更新文档"></a>4.更新文档</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line"># 数据库链接，必须保证当前系统能正常访问mongodb</span><br><span class="line">connect &#x3D; MongoClient(&#39;mongodb:&#x2F;&#x2F;root:123@127.0.0.1:27017&#x2F;admin&#39;)</span><br><span class="line">my_db &#x3D; connect[&#39;mofang&#39;]</span><br><span class="line">my_collections &#x3D; my_db[&#39;my_collections&#39;]</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;更新文档&quot;&quot;&quot;</span><br><span class="line">&quot;&quot;&quot;按条件更新一个文档的指定数据&quot;&quot;&quot;</span><br><span class="line">query &#x3D; &#123;&#39;name&#39;: &#39;xiaofei&#39;&#125;</span><br><span class="line">upsert &#x3D; &#123;&#39;$set&#39;: &#123;&#39;age&#39;: 22&#125;&#125;</span><br><span class="line">ret &#x3D; my_collections.update_one(query, upsert)</span><br><span class="line">print(ret.modified_count)  # 0 表示没有任何修改，1表示修改成功</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;按条件累加&#x2F;累减指定数值一个文档的指定数据&quot;&quot;&quot;</span><br><span class="line">query &#x3D; &#123;&#39;name&#39;: &#39;xiaofei&#39;&#125;</span><br><span class="line">upsert &#x3D; &#123;&#39;$inc&#39;: &#123;&#39;age&#39;: -1&#125;&#125;  # 累减</span><br><span class="line">upsert &#x3D; &#123;&#39;$inc&#39;: &#123;&#39;age&#39;: 1&#125;&#125;  # 累加</span><br><span class="line">ret &#x3D; my_collections.update_one(query, upsert)</span><br><span class="line">print(ret.modified_count)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;更新多条数据&quot;&quot;&quot;</span><br><span class="line"># 把所有以&quot;133&quot;开头的手机码号的文档，全部改成15012345678</span><br><span class="line">query &#x3D; &#123;&#39;mobile&#39;: &#123;&#39;$regex&#39;: &#39;^133&#39;&#125;&#125;</span><br><span class="line">upsert &#x3D; &#123;&#39;$set&#39;: &#123;&#39;mobile&#39;: &#39;15012345678&#39;&#125;&#125;</span><br><span class="line">ret &#x3D; my_collections.update_many(query, upsert)</span><br><span class="line">print(ret.modified_count)</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Mongo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyMongo操作大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker四种网络模式</title>
      <link href="/2021/03/01/Docker/"/>
      <url>/2021/03/01/Docker/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="四类网络模式"><a href="#四类网络模式" class="headerlink" title="四类网络模式"></a>四类网络模式</h1><table><thead><tr><th>Docker网络模式</th><th>配置</th><th>说明</th></tr></thead><tbody><tr><td>host模式</td><td>–net=host</td><td>容器和宿主机共享Network namespace。</td></tr><tr><td>container模式</td><td>–net=container:NAME_or_ID</td><td>容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。</td></tr><tr><td>none模式</td><td>–net=none</td><td>容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。</td></tr><tr><td>bridge模式</td><td>–net=bridge</td><td>（默认为该模式）</td></tr></tbody></table><h2 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h2><p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><p>使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。</p><p><a href="https://img-blog.csdnimg.cn/img_convert/aec0737082b5839c35bf19cd4220af28.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/aec0737082b5839c35bf19cd4220af28.png#pic_center" class="lazyload"></a></p><h2 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h2><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><p><a href="https://img-blog.csdnimg.cn/img_convert/ba707e595c743ae734443253e842ce14.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/ba707e595c743ae734443253e842ce14.png#pic_center" class="lazyload"></a></p><h2 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h2><p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p><p>这种网络模式下容器只有lo回环网络，没有其他网卡。none模式可以在容器创建时通过–network=none来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p><p><a href="https://img-blog.csdnimg.cn/img_convert/040ed2224550051b3d7bc0955337a1d4.png#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/img_convert/040ed2224550051b3d7bc0955337a1d4.png#pic_center" class="lazyload"></a><br>bridge模式<br>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p><p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</p><p>bridge模式是docker的默认网络模式，不写–net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看。</p><p><a href="https://img-blog.csdnimg.cn/20210513144453773.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MDY2NjI4,size_16,color_FFFFFF,t_70#pic_center" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" title="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20210513144453773.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MDY2NjI4,size_16,color_FFFFFF,t_70#pic_center" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker四种网络模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux之limit_conn、stub_status、location，wordpress(博客)、EduSoho（网络课堂）、kodcloud (网盘)，扩展应用节点，拆分数据库</title>
      <link href="/2021/01/20/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99/"/>
      <url>/2021/01/20/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、续"><a href="#一、续" class="headerlink" title="一、续"></a>一、续</h2><h5 id="1-限制连接-limit-conn"><a href="#1-限制连接-limit-conn" class="headerlink" title="1.限制连接 limit_conn"></a>1.限制连接 limit_conn</h5><p>场景: 下载</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu mirror]# cat  &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;mirror.oldboyedu.com.conf </span><br><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;addr:10m;# 定义限制的key, 分配区域大小</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name mirror.oldboyedu.com;</span><br><span class="line">charset utf8;</span><br><span class="line">limit_conn addr 1;# 调用区域限制,限制key只可以出现1次, 相当于限制来源客户端IP的连接数为1</span><br><span class="line">limit_conn_status 500;# 限制成功后,会返回500的错误状态码,默认返回503</span><br><span class="line"></span><br><span class="line">limit_rate_after 200m;# 全速下载200m资源</span><br><span class="line">limit_rate       300k;# 达到200m以后,限制300k的速度</span><br><span class="line"></span><br><span class="line">error_page 500 &#x3D; @testerror;# 如果 出现500错误,则让其跳转到内部的 @testerror </span><br><span class="line"></span><br><span class="line">location @testerror &#123;# 定义 @testerror, 返回具体的动作 </span><br><span class="line">default_type text&#x2F;html;</span><br><span class="line">return 200 &#39;$remote_addr 你超过了最大连接限制, 请充值VIP解封!&#39;;</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">root &#x2F;code&#x2F;mirror;</span><br><span class="line">autoindex on;</span><br><span class="line">autoindex_exact_size off;</span><br><span class="line">autoindex_localtime on;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=./bigdata bs=1M count=500  <span class="comment"># 产生一个500M文件</span></span><br><span class="line">tail -f /var/<span class="built_in">log</span>/nginx/error.log</span><br></pre></td></tr></table></figure></div><h5 id="2-状态监控-stub-status-7种状态"><a href="#2-状态监控-stub-status-7种状态" class="headerlink" title="2.状态监控 stub_status [ 7种状态 ]"></a>2.状态监控 stub_status [ 7种状态 ]</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x3D; &#x2F;status &#123;</span><br><span class="line">stub_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Active connections: 2 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 2 2 3 </span><br><span class="line">Reading: 0 Writing: 1 Waiting: 1 </span><br><span class="line"></span><br><span class="line">Active connections: <span class="comment"># 活跃的连接数</span></span><br><span class="line">accepts: <span class="comment"># 接受的总TCP连接数</span></span><br><span class="line">handled: <span class="comment"># 总处理的TCP连接数</span></span><br><span class="line">requests: <span class="comment"># 总的 http 请求数</span></span><br></pre></td></tr></table></figure></div><h5 id="3-location"><a href="#3-location" class="headerlink" title="3.location"></a>3.location</h5><p>作用: 控制用户请求 uri 的具体路径<br>用法: location [ = | ~ | <del>* | ^</del> ] uri { … }</p><p>多个location时会用上, 但多个location会出现优先级的问题.</p><blockquote><p>1).Location优先级:</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#匹配符 匹配规则                  优先级</span><br><span class="line">#&#x3D;     精确匹配                    1 </span><br><span class="line">#^~    以某个字符串开头             2</span><br><span class="line">#~     区分大小写的正则匹配          3</span><br><span class="line">#~*    不区分大小写的正则匹配            4</span><br><span class="line">#&#x2F;     通用匹配，任何请求都会匹配到      5</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name location.oldboyedu.com;</span><br><span class="line"></span><br><span class="line">    location = / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        <span class="built_in">return</span> 200 <span class="string">'location = /'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line"><span class="built_in">return</span> 200 <span class="string">'location /'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">location /documents/ &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line"><span class="built_in">return</span> 200 <span class="string">'location /documents/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    location ^~ /images/ &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line"><span class="built_in">return</span> 200 <span class="string">'location ^~ /images/'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line"><span class="built_in">return</span> 200 <span class="string">'location ~* \.(gif|jpg|jpeg)'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http://location.oldboyedu.com/index.htmllocation /</span><br><span class="line">http://location.oldboyedu.com/documents/1.htmllocation /documents/</span><br><span class="line">http://location.oldboyedu.com/images/1.giflocation ^~ /images/</span><br><span class="line">[root@cwj-python ~]<span class="comment"># curl -HHost:location.oldboyedu.com http://10.0.0.200/images/1.gif</span></span><br><span class="line">location ^~ /images/</span><br><span class="line">http://location.oldboyedu.com/documents/1.jpglocation ~* \.(gif|jpg|jpeg)</span><br><span class="line">[root@cwj-python ~]<span class="comment"># curl -HHost:location.oldboyedu.com http://10.0.0.200/documents/1.jpg</span></span><br><span class="line">location ~* \.(gif|jpg|jpeg)</span><br></pre></td></tr></table></figure></div><blockquote><p>2).Location具体如何使用:</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name location.oldboyedu.com;</span><br><span class="line"></span><br><span class="line">    # 通用匹配，任何请求都会匹配到</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root html;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 精准匹配,必须请求的uri是&#x2F;nginx_status</span><br><span class="line">    location &#x3D; &#x2F;nginx_status &#123;</span><br><span class="line">        stub_status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 严格区分大小写，匹配以.php结尾的都走这个location    </span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        default_type text&#x2F;html;</span><br><span class="line">        return 200 &#39;php访问成功&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 严格区分大小写，匹配以.jsp结尾的都走这个location </span><br><span class="line">    location ~ \.jsp$ &#123;</span><br><span class="line">        default_type text&#x2F;html;</span><br><span class="line">        return 200 &#39;jsp访问成功&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 不区分大小写匹配，只要用户访问.jpg,gif,png,js,css 都走这条location</span><br><span class="line">    location ~* \.(jpg|gif|png|js|css)$ &#123;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 不区分大小写匹配</span><br><span class="line">    location ~* \.(sql|bak|tgz|tar.gz|.git)$ &#123;</span><br><span class="line">        deny all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="二、nginx-php"><a href="#二、nginx-php" class="headerlink" title="二、nginx+php"></a>二、nginx+php</h2><h5 id="1-wordpress-博客"><a href="#1-wordpress-博客" class="headerlink" title="1.wordpress(博客)"></a>1.wordpress(博客)</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">LNMP 架构:</span><br><span class="line">1) 什么是LNMP架构</span><br><span class="line">L &#x3D; Linux</span><br><span class="line">N &#x3D; Nginx</span><br><span class="line">M ~&#x3D; MySQL | Mariadb</span><br><span class="line">p ~&#x3D; PHP   | Python</span><br><span class="line"></span><br><span class="line">2) LNMP架构如何工作</span><br><span class="line">3) LNMP架构安装</span><br><span class="line">nginx:</span><br><span class="line"></span><br><span class="line">php:</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -e $(rpm -qa |grep php)   #卸载php5版本</span><br><span class="line">[root@oldboy-pythonedu ~]# wget http:&#x2F;&#x2F;cdn.xuliangwei.com&#x2F;php.zip</span><br><span class="line">[root@oldboy-pythonedu ~]# unzip php.zip </span><br><span class="line">[root@oldboy-pythonedu ~]# yum localinstall php&#x2F;*.rpm -y</span><br><span class="line"></span><br><span class="line"># 修改进程运行的身份</span><br><span class="line">[root@oldboy-pythonedu ~]# sed -i &#39;s#user &#x3D; apache#user &#x3D; nginx#g&#39; &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf </span><br><span class="line">[root@oldboy-pythonedu ~]# sed -i &#39;s#group &#x3D; apache#group &#x3D; nginx#g&#39; &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf </span><br><span class="line"></span><br><span class="line"># 启动php-fpm</span><br><span class="line">[root@oldboy-pythonedu ~]# systemctl enable php-fpm</span><br><span class="line">[root@oldboy-pythonedu ~]# systemctl start php-fpm</span><br><span class="line"></span><br><span class="line">nginx+ php 检查: </span><br><span class="line">[root@oldboy-pythonedu ~]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;php.oldboyedu.com.conf </span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name php.oldboyedu.com;</span><br><span class="line">root &#x2F;code;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">index index.php;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">include fastcgi_params;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 代码:</span><br><span class="line">[root@oldboy-pythonedu ~]# cat &#x2F;code&#x2F;index.php </span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">[root@oldboy-pythonedu ~]# yum install mariadb mariadb-server -y</span><br><span class="line">[root@oldboy-pythonedu ~]# systemctl enable mariadb</span><br><span class="line">[root@oldboy-pythonedu ~]# systemctl start mariadb</span><br><span class="line">[root@oldboy-pythonedu ~]# mysqladmin password &#39;123456&#39;</span><br><span class="line">[root@oldboy-pythonedu ~]# mysql -uroot -p123456</span><br><span class="line">MariaDB [(none)]&gt; </span><br><span class="line">MariaDB [(none)]&gt; create database wordpress charset utf8;</span><br><span class="line"></span><br><span class="line">测试php+mysql是否成功:</span><br><span class="line">[root@oldboy-pythonedu ~]# cat &#x2F;code&#x2F;mysql.php </span><br><span class="line">   &lt;?php</span><br><span class="line">$servername &#x3D; &quot;localhost&quot;;</span><br><span class="line">$username &#x3D; &quot;root&quot;;</span><br><span class="line">$password &#x3D; &quot;123456&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建连接</span><br><span class="line">$conn &#x3D; mysqli_connect($servername, $username, $password);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检测连接</span><br><span class="line">if (!$conn) &#123;</span><br><span class="line">die(&quot;Connection failed: &quot; . mysqli_connect_error());</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;php连接MySQL数据库成功&quot;;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">[root@oldboy-pythonedu ~]# php &#x2F;code&#x2F;mysql.php </span><br><span class="line">    php连接MySQL数据库成功</span><br><span class="line"></span><br><span class="line">4) 部署Wordpress</span><br><span class="line"></span><br><span class="line">第一步: 下载代码,存储至指定位置,变更权限</span><br><span class="line">[root@oldboy-pythonedu ~]# cd &#x2F;code&#x2F;</span><br><span class="line">[root@oldboy-pythonedu code]# wget https:&#x2F;&#x2F;cn.wordpress.org&#x2F;latest-zh_CN.tar.gz</span><br><span class="line">[root@oldboy-pythonedu code]# tar xf latest-zh_CN.tar.gz </span><br><span class="line">[root@oldboy-pythonedu code]# chown -R nginx.nginx wordpress&#x2F;</span><br><span class="line"></span><br><span class="line">第二步: 编写Nginx配置文件</span><br><span class="line">[root@oldboy-pythonedu code]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;blog.oldboyedu.com.conf </span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name blog.oldboyedu.com;</span><br><span class="line">root &#x2F;code&#x2F;wordpress;</span><br><span class="line">client_max_body_size 50m;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">index index.php;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">include fastcgi_params;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@oldboy-pythonedu code]# nginx -t</span><br><span class="line">[root@oldboy-pythonedu code]# systemctl reload nginx</span><br><span class="line"></span><br><span class="line">第三步: 配置域名解析.访问浏览器.安装该产品</span><br><span class="line">10.0.0.200 blog.oldboyedu.com</span><br></pre></td></tr></table></figure></div><h5 id="2-部署edusoho项目-网络课堂"><a href="#2-部署edusoho项目-网络课堂" class="headerlink" title="2.部署edusoho项目(网络课堂)"></a>2.部署edusoho项目(网络课堂)</h5><blockquote><blockquote><p>1).安装EduSoho</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;code</span><br><span class="line">cd &#x2F;code</span><br><span class="line">rz #上传文件</span><br><span class="line">tar xf edusoho-8.2.17.tar.gz</span><br><span class="line"></span><br><span class="line">#注意：我们的进程能够以什么方式去访问一个文件或目录，取决于进程所运行的用户身份对该文件有什么权限</span><br><span class="line">chown -R nginx.nginx edusoho</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></blockquote><blockquote><p>2)增加EduSoho nginx配置</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;edu.oldboyedu.com.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name edu.oldboyedu.com;</span><br><span class="line">    root &#x2F;code&#x2F;edusoho&#x2F;web;</span><br><span class="line">    client_max_body_size 1024m;#允许上传视频大小限制</span><br><span class="line">    client_body_buffer_size 100m;#缓冲区大小(太小会提示a client request body is buffered to a temporary)</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        index app.php;</span><br><span class="line">        try_files $uri @rewriteapp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @rewriteapp &#123;</span><br><span class="line">        rewrite ^(.*)$ &#x2F;app.php&#x2F;$1 last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ ^&#x2F;udisk &#123;</span><br><span class="line">        internal;</span><br><span class="line">        root &#x2F;code&#x2F;edusoho&#x2F;app&#x2F;data&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ ^&#x2F;(app|app_dev)\.php(&#x2F;|$) &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_split_path_info ^(.+\.php)(&#x2F;.*)$;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_param  HTTPS              off;</span><br><span class="line">        fastcgi_param HTTP_X-Sendfile-Type X-Accel-Redirect;</span><br><span class="line">        fastcgi_param HTTP_X-Accel-Mapping &#x2F;udisk&#x3D;&#x2F;code&#x2F;edusoho&#x2F;app&#x2F;data&#x2F;udisk;</span><br><span class="line">        fastcgi_buffer_size 128k;</span><br><span class="line">        fastcgi_buffers 8 128k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~* \.(jpg|jpeg|gif|png|ico|swf)$ &#123;</span><br><span class="line">        expires 3y;</span><br><span class="line">        access_log off;</span><br><span class="line">        gzip off;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~* \.(css|js)$ &#123;</span><br><span class="line">        access_log off;</span><br><span class="line">        expires 3y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ ^&#x2F;files&#x2F;.*\.(php|php5)$ &#123;</span><br><span class="line">        deny all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_split_path_info ^(.+\.php)(&#x2F;.*)$;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</span><br><span class="line">        fastcgi_param  HTTPS              off;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>3)重启nginx服务</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure></div><blockquote><p>4)修改php.ini 配置文件,调整解析器支持的最大上传限制</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log</span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;php.ini</span><br><span class="line">upload_max_filesize &#x3D; 1024M</span><br><span class="line">post_max_size &#x3D; 1024M</span><br><span class="line"></span><br><span class="line">systemctl restart php-fpm</span><br></pre></td></tr></table></figure></div><blockquote><p>5)上传视频</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">课程-&gt;创建课程</span><br><span class="line">课程-&gt;管理课程--&gt;</span><br><span class="line">课程文件--&gt;添加视频</span><br><span class="line">计划任务--&gt;添加章节--&gt;添加视频--&gt;发布</span><br></pre></td></tr></table></figure></div><blockquote><p>6)修改图片</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运营-&gt;编辑区管理-&gt;首页顶部.轮播图</span><br><span class="line">系统-&gt;站点设置-&gt;网站Logo</span><br><span class="line">系统-&gt;站点设置-&gt;主题-&gt;管理</span><br><span class="line">-&gt;组件调整</span><br><span class="line">-&gt;配色方案</span><br></pre></td></tr></table></figure></div><h5 id="3-kodcloud-网盘-【-oss-对象存储-花钱-】"><a href="#3-kodcloud-网盘-【-oss-对象存储-花钱-】" class="headerlink" title="3.kodcloud (网盘) 【+ oss 对象存储 ( 花钱 )】"></a>3.kodcloud (网盘) 【+ oss 对象存储 ( 花钱 )】</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1) Nginx + PHP 环境</span><br><span class="line">2) kodcloud代码</span><br><span class="line">[root@oldboy-pythonedu ~]# cd &#x2F;code</span><br><span class="line">[root@oldboy-pythonedu code]# wget http:&#x2F;&#x2F;static.kodcloud.com&#x2F;update&#x2F;download&#x2F;kodbox.1.13.zip</span><br><span class="line">[root@oldboy-pythonedu code]# mkdir kodcloud</span><br><span class="line">[root@oldboy-pythonedu code]# unzip kodbox.1.13.zip -d kodcloud&#x2F;</span><br><span class="line">[root@oldboy-pythonedu code]# chown -R nginx.nginx &#x2F;code&#x2F;kodcloud&#x2F;</span><br><span class="line"></span><br><span class="line">3) Nginx配置文件</span><br><span class="line">[root@oldboy-pythonedu code]# cat &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;kod.oldboyedu.com.conf</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name kod.oldboyedu.com;</span><br><span class="line">root &#x2F;code&#x2F;kodcloud;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">index index.php;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">include fastcgi_params;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chown -R nginx.nginx &#x2F;code&#x2F;kodcloud&#x2F;</span><br><span class="line">[root@oldboy-pythonedu code]# nginx -t</span><br><span class="line">[root@oldboy-pythonedu code]# systemctl reload nginx</span><br><span class="line"></span><br><span class="line">4) 域名解析</span><br><span class="line">10.0.0.200 blog.oldboyedu.com</span><br><span class="line">10.0.0.200 edu.oldboyedu.com</span><br><span class="line">10.0.0.200 kod.oldboyedu.com</span><br></pre></td></tr></table></figure></div><h2 id="三、扩展应用节点及拆分数据库"><a href="#三、扩展应用节点及拆分数据库" class="headerlink" title="三、扩展应用节点及拆分数据库"></a>三、扩展应用节点及拆分数据库</h2><h5 id="1-扩展一台应用节点"><a href="#1-扩展一台应用节点" class="headerlink" title="1.扩展一台应用节点"></a>1.扩展一台应用节点</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1) 克隆一台全新的Linux主机,需要修改IP地址 node2(201)</span><br><span class="line">sed -i &#39;s#old#new#g&#39; &#x2F;etc&#x2F;sysconfig&#x2F;network-script&#x2F;ifcfg-ens</span><br><span class="line"></span><br><span class="line"># old: 旧的IP尾号</span><br><span class="line"># new: 新的IP尾号</span><br><span class="line"></span><br><span class="line">[root@oldboy-pythonedu ~]# hostnamectl set-hostname node2</span><br><span class="line"></span><br><span class="line">2) 安装Nginx PHP环境</span><br><span class="line">[root@node2 ~]# yum install vim net-tools unzip wget lrzsz -y# 基础工具</span><br><span class="line">[root@node2 ~]# wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo</span><br><span class="line">[root@node2 ~]# wget http:&#x2F;&#x2F;cdn.xuliangwei.com&#x2F;php.zip</span><br><span class="line"></span><br><span class="line"># 安装Nginx</span><br><span class="line">[root@node2 ~]# yum install nginx -y</span><br><span class="line"></span><br><span class="line"># 安装PHP</span><br><span class="line">[root@node2 ~]# unzip php.zip</span><br><span class="line">[root@node2 ~]# yum localinstall php&#x2F;*.rpm -y</span><br><span class="line"></span><br><span class="line">3) 拷贝Nginx配置 PHP配置   scp</span><br><span class="line">[root@node2 ~]# scp root@10.0.0.200:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">[root@node2 ~]# scp -r root@10.0.0.200:&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</span><br><span class="line"></span><br><span class="line"># php</span><br><span class="line">[root@node2 ~]# scp root@10.0.0.200:&#x2F;etc&#x2F;php.ini &#x2F;etc&#x2F;php.ini   </span><br><span class="line">[root@node2 ~]# scp root@10.0.0.200:&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf  &#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf </span><br><span class="line"></span><br><span class="line">4) 拷贝代码, 关闭防火墙</span><br><span class="line">[root@node2 ~]# systemctl disable firewalld</span><br><span class="line">[root@node2 ~]# systemctl stop firewalld</span><br><span class="line">[root@node2 ~]# setenforce 0</span><br><span class="line">[root@node2 ~]# sed -i &#39;s#SELINUX&#x3D;enforcing#SELINUX&#x3D;disabled#g&#39; &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line"></span><br><span class="line"># 拷贝所有代码</span><br><span class="line">[root@node2 ~]# scp -rp root@10.0.0.200:&#x2F;code &#x2F;</span><br><span class="line">[root@node2 ~]# chown -R nginx.nginx &#x2F;code&#x2F;</span><br><span class="line"></span><br><span class="line">5) 启动服务</span><br><span class="line">[root@node2 ~]# systemctl enable nginx php-fpm</span><br><span class="line">[root@node2 ~]# systemctl start nginx php-fpm</span><br></pre></td></tr></table></figure></div><h5 id="2-拆分数据库至独立服务器-应用节点可以共享使用-数据库还可以组集群架构"><a href="#2-拆分数据库至独立服务器-应用节点可以共享使用-数据库还可以组集群架构" class="headerlink" title="2.拆分数据库至独立服务器 ( 应用节点可以共享使用, 数据库还可以组集群架构. )"></a>2.拆分数据库至独立服务器 ( 应用节点可以共享使用, 数据库还可以组集群架构. )</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1) 准备基础环境, 修改IP地址,修改主机名称,关闭防火墙</span><br><span class="line"></span><br><span class="line">sed -i &#39;s#200#202#g&#39; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens32 </span><br><span class="line">systemctl restart network</span><br><span class="line">hostnamectl set-hostname node-mysql</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#39;s#SELINUX&#x3D;enforcing#SELINUX&#x3D;disabled#g&#39; &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line"></span><br><span class="line">yum install vim net-tools unzip wget lrzsz -y</span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo</span><br><span class="line"></span><br><span class="line">2) 在202安装Mariadb</span><br><span class="line">[root@node-mysql ~]# yum install mariadb mariadb-server -y</span><br><span class="line">[root@node-mysql ~]# systemctl enable mariadb</span><br><span class="line">[root@node-mysql ~]# systemctl start mariadb</span><br><span class="line">[root@node-mysql ~]# mysql -u root -p</span><br><span class="line">MariaDB [(none)]&gt; grant all privileges on *.* to &#39;all&#39;@&#39;%&#39; identified by &#39;123456&#39;;</span><br><span class="line">MariaDB [(none)]&gt;</span><br><span class="line"></span><br><span class="line">3) 在原有数据上,将库备份下来,然后恢复至 10.0.0.202 主机的MySQL上</span><br><span class="line">[root@oldboy-pythonedu ~]# mysqldump -uroot -p123456 -B wordpress edusoho &gt; bak.sql</span><br><span class="line">[root@oldboy-pythonedu ~]# scp bak.sql root@10.0.0.202:~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4) 在新的数据库服务上恢复数据</span><br><span class="line">[root@node-mysql ~]# mysql -u root -p123456 &lt; bak.sql </span><br><span class="line"></span><br><span class="line">5) 修改应用服务连接数据库的地址:  ( 所有应用节点都需要操作 )</span><br><span class="line"></span><br><span class="line">Wordpress:</span><br><span class="line">[root@node2 ~]# vim &#x2F;code&#x2F;wordpress&#x2F;wp-config.php</span><br><span class="line">define( &#39;DB_NAME&#39;, &#39;wordpress&#39; );</span><br><span class="line"></span><br><span class="line">&#x2F;** MySQL数据库用户名 *&#x2F;</span><br><span class="line">define( &#39;DB_USER&#39;, &#39;all&#39; );   </span><br><span class="line"></span><br><span class="line">&#x2F;** MySQL数据库密码 *&#x2F;</span><br><span class="line">define( &#39;DB_PASSWORD&#39;, &#39;123456&#39; );</span><br><span class="line"></span><br><span class="line">&#x2F;** MySQL主机 *&#x2F;</span><br><span class="line">define( &#39;DB_HOST&#39;, &#39;10.0.0.202&#39; );   </span><br><span class="line"></span><br><span class="line">edusohu:</span><br><span class="line">[root@node2 ~]# vim &#x2F;code&#x2F;edusoho&#x2F;app&#x2F;config&#x2F;parameters.yml</span><br><span class="line">parameters:</span><br><span class="line">database_driver: pdo_mysql</span><br><span class="line">database_host: 10.0.0.202</span><br><span class="line">database_port: 3306</span><br><span class="line">database_name: edusoho</span><br><span class="line">database_user: all</span><br><span class="line">database_password: &#39;123456&#39;</span><br><span class="line"></span><br><span class="line">在200中也执行以上操作</span><br><span class="line"></span><br><span class="line">edusoho存在缓存:</span><br><span class="line">[root@node2 ~]# rm -rf &#x2F;code&#x2F;edusoho&#x2F;app&#x2F;cache&#x2F;*</span><br><span class="line"></span><br><span class="line">6)域名解析</span><br><span class="line">10.0.0.201 kod.oldboyedu.com blog.oldboyedu.com edu.oldboyedu.com</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux之limit_conn、stub_status、location，wordpress(博客)、EduSoho（网络课堂）、kodcloud (网盘)，扩展应用节点，拆分数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础语法、特性、文件管理</title>
      <link href="/2021/01/19/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E3%80%81%E7%89%B9%E6%80%A7%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2021/01/19/Linux%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E3%80%81%E7%89%B9%E6%80%A7%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、什么是Bash-Shell"><a href="#一、什么是Bash-Shell" class="headerlink" title="一、什么是Bash Shell"></a>一、什么是Bash Shell</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令的解释,用来翻译用户输入的指令</span><br></pre></td></tr></table></figure></div><h2 id="二、Bash-Shell-能做什么"><a href="#二、Bash-Shell-能做什么" class="headerlink" title="二、Bash Shell 能做什么?"></a>二、Bash Shell 能做什么?</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件管理</span><br><span class="line">软件管理</span><br><span class="line">用户管理</span><br><span class="line">权限管理</span><br><span class="line">网络管理</span><br><span class="line">........</span><br></pre></td></tr></table></figure></div><h2 id="三、平时怎么使用Bash-Shell"><a href="#三、平时怎么使用Bash-Shell" class="headerlink" title="三、平时怎么使用Bash Shell?"></a>三、平时怎么使用Bash Shell?</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">单条命令:</span><br><span class="line">useradd gdx</span><br><span class="line"></span><br><span class="line">脚本:</span><br><span class="line">[root@oldboy-pythonedu ~]# cat useradd.sh </span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">for i in &#123;1..100&#125;</span><br><span class="line">do</span><br><span class="line">useradd gdx_$i</span><br><span class="line">echo &quot;gdx_$i is ok!!&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></div><h2 id="四、登录Linux-Bash提示符"><a href="#四、登录Linux-Bash提示符" class="headerlink" title="四、登录Linux Bash提示符"></a>四、登录Linux Bash提示符</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]#</span><br><span class="line"></span><br><span class="line">root: 表示当前登录Bash Shell窗口的用户是..</span><br><span class="line">oldboy-python: 当前系统的主机名称</span><br><span class="line">~: 当前用户所处的路径   ~ 表示的是当前用户的家目录</span><br><span class="line">#:  提示符  # 表示超级管理员</span><br><span class="line">   $ 表示普通用户</span><br></pre></td></tr></table></figure></div><h2 id="五、Bash-Shell-基础语法"><a href="#五、Bash-Shell-基础语法" class="headerlink" title="五、Bash Shell 基础语法?"></a>五、Bash Shell 基础语法?</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">命令  选项  参数</span><br><span class="line"></span><br><span class="line">ls# 命令     查看当前目录下的所有文件</span><br><span class="line">ls -l# 命令 + 选项 </span><br><span class="line">选项 可以改变命令输出结尾呈现的方式</span><br><span class="line">ls -l &#x2F;tmp# 命令 + 选项 + 参数  具体看哪个路径下的所有文件,默认看当前目录.</span><br><span class="line"></span><br><span class="line">ls  打针  -l 轻 | 重   &#x2F;tmp  往哪打</span><br></pre></td></tr></table></figure></div><h2 id="六、Bash-Shell-特性"><a href="#六、Bash-Shell-特性" class="headerlink" title="六、Bash Shell 特性"></a>六、Bash Shell 特性</h2><h5 id="1-tab补全"><a href="#1-tab补全" class="headerlink" title="1.tab补全:"></a>1.tab补全:</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令补全</span><br><span class="line">路径补全</span><br></pre></td></tr></table></figure></div><h5 id="2-history-执行的命令历史"><a href="#2-history-执行的命令历史" class="headerlink" title="2.history: 执行的命令历史"></a>2.history: 执行的命令历史</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-c:   清空</span><br><span class="line">-d:   删除指定的一条记录</span><br><span class="line">-w:   将历史记录落到指定的文件中</span><br></pre></td></tr></table></figure></div><h5 id="3-alias-别名"><a href="#3-alias-别名" class="headerlink" title="3.alias: 别名"></a>3.alias: 别名</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 临时操作</span><br><span class="line">alias cat_network&#x3D;&#39;cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens32&#39;</span><br><span class="line"></span><br><span class="line"># 永久生效  ( 落到某个文件中 )  </span><br><span class="line">[root@oldboy-pythonedu ~]# echo &quot;alias cat_network&#x3D;&#39;cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens32&#39;&quot; &gt;&gt; &#x2F;etc&#x2F;bashrc</span><br></pre></td></tr></table></figure></div><h5 id="4-unalias-临时取消别名"><a href="#4-unalias-临时取消别名" class="headerlink" title="4.unalias: 临时取消别名"></a>4.unalias: 临时取消别名</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# unalias cat_network</span><br></pre></td></tr></table></figure></div><h5 id="5-快捷键"><a href="#5-快捷键" class="headerlink" title="5.快捷键:"></a>5.快捷键:</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ctrl+ a,e,c,l,d,w,k,u,r</span><br><span class="line"></span><br><span class="line">ctrl+a:  命令行光标跳转到行首</span><br><span class="line">ctrl+e:  命令行光标跳转到行尾</span><br><span class="line">ctrl+l:  清屏, clear</span><br><span class="line">ctrl+c:  中断bash窗口 前台正在运行的程序</span><br><span class="line">ctrl+u:  删除光标之前的</span><br><span class="line">ctrl+k: 删除光标之后的</span><br><span class="line">ctrl+w:  按照单词删除</span><br><span class="line">ctrl+ &lt;--&gt; 按照单词跳转光标</span><br></pre></td></tr></table></figure></div><h2 id="七、文件管理"><a href="#七、文件管理" class="headerlink" title="七、文件管理"></a>七、文件管理</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对文件做什么事情?  创建 删除 压缩 移动 复制 编辑 查看 查找</span><br><span class="line">修改一个主机名称的文件: 在哪?</span><br></pre></td></tr></table></figure></div><h5 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构:"></a>1.目录结构:</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Windows:  多根    c:\  d:\  e:\</span><br><span class="line">Linux:    单根    &#x2F;</span><br><span class="line"></span><br><span class="line">bin:普通用户可以执行的命令</span><br><span class="line">sbin:   管理用户可以执行的命令</span><br><span class="line">home:   普通用户的家目录:  &#x2F;home&#x2F;USERNAME </span><br><span class="line">root:   管理员用户的家目录</span><br><span class="line">boot:   存放的启动系统时要加载的文件    grub引导菜单,内核文件</span><br><span class="line">dev:    设备 ( 硬盘 光盘 终端 )</span><br><span class="line">&#x2F;dev&#x2F;random: 产生随机数   ( 摇钱树)</span><br><span class="line">&#x2F;dev&#x2F;null:  黑洞</span><br><span class="line"></span><br><span class="line">etc:    配置  网卡配置,系统配置,服务配置</span><br><span class="line">&#x2F;etc&#x2F;hostname    主机名称</span><br><span class="line">&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;   #网卡的配置信息</span><br><span class="line">lib  </span><br><span class="line">lib64</span><br><span class="line">proc实时反馈当前系统的状态. [ 汽车的仪表盘 ]</span><br><span class="line">tmp临时目录,谁上传只能谁删除   [  ]    </span><br><span class="line">usr  </span><br><span class="line">bin</span><br><span class="line">sbin</span><br><span class="line">local  --&gt; C:\Program Files</span><br><span class="line">tmp    ---&gt; &#x2F;var&#x2F;tmp</span><br><span class="line">var可变的目录  </span><br><span class="line">log</span><br><span class="line">pid:  存放服务进程的ID    ---&gt;  python   ---&gt; 30119  --&gt;  &#x2F;var&#x2F;pid&#x2F;python.pid  ( 30119 )</span><br></pre></td></tr></table></figure></div><h5 id="2-路径定位"><a href="#2-路径定位" class="headerlink" title="2.路径定位:"></a>2.路径定位:</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过路径对文件进行定位.  一个完整的路径,就包含了文件的路径.</span><br></pre></td></tr></table></figure></div><h2 id="八、基础命令"><a href="#八、基础命令" class="headerlink" title="八、基础命令"></a>八、基础命令</h2><blockquote><blockquote><p>1.在/home下创建一个hello.py文件.</p></blockquote></blockquote><p>touch:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# touch &#x2F;home&#x2F;hello.py</span><br><span class="line">[root@oldboy-pythonedu ~]# ls -l &#x2F;home&#x2F;hello.py </span><br><span class="line">-rw-r--r--. 1 root root 0 9月  25 11:48 &#x2F;home&#x2F;hello.py</span><br></pre></td></tr></table></figure></div><blockquote><p>2.将/home/hello.py 复制到 /tmp [ 最好能修改一下名称为 /tmp/test.py ]</p></blockquote><p>cp: 复制文件或者目录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-v:  显示拷贝的结果.</span><br><span class="line">-r:  递归拷贝</span><br><span class="line">-i:  会在复制文件的时候给提示 如果复制的目标文件存在 会给你提示是否要覆盖</span><br><span class="line">[root@oldboy-pythonedu ~]# cp &#x2F;home&#x2F;hello.py &#x2F;tmp&#x2F;#直接拷贝</span><br><span class="line">[root@oldboy-pythonedu ~]# cp &#x2F;home&#x2F;hello.py &#x2F;tmp&#x2F;test.py#拷贝后修改名称</span><br></pre></td></tr></table></figure></div><blockquote><p>3.将/home/hello.py 文件删除</p></blockquote><p>rm: 删除文件或者目录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-f: 强制删除,不提示</span><br><span class="line">-r: 递归删除 [ 删除目录 ]</span><br><span class="line">[root@oldboy-pythonedu ~]# rm -f &#x2F;home&#x2F;hello.py</span><br><span class="line">[root@oldboy-pythonedu ~]# rm -fr &#x2F;tmp&#x2F;etc</span><br></pre></td></tr></table></figure></div><blockquote><p>4.查看 /tmp/test.py 中的内容</p></blockquote><p>cat head tail more less</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat: 查看文件内容:</span><br><span class="line">-A: 查看是否有特殊字符</span><br><span class="line">-n: 查看文件的行号</span><br><span class="line">[root@oldboy-pythonedu ~]# cat &#x2F;tmp&#x2F;hello.py</span><br><span class="line"></span><br><span class="line">head: 查看文件内容: 仅查看头部10行.</span><br><span class="line">[root@oldboy-pythonedu ~]# head &#x2F;etc&#x2F;passwd</span><br><span class="line">[root@oldboy-pythonedu ~]# head -1 &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">tail: 查看文件内容: 仅查看尾部10行.</span><br><span class="line">-f: 实时追踪文件尾部的变化</span><br><span class="line"></span><br><span class="line">[root@oldboy-pythonedu ~]# tail -f &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line"></span><br><span class="line">less\more 分页查看</span><br><span class="line">[root@oldboy-pythonedu ~]# less &#x2F;etc&#x2F;services</span><br><span class="line">[root@oldboy-pythonedu ~]# more &#x2F;etc&#x2F;services</span><br></pre></td></tr></table></figure></div><blockquote><p>5.将/tmp/hello.py 拷贝到 /opt/python_dir/hello.py</p></blockquote><p>mkdir #创建目录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-p:  递归创建</span><br><span class="line">-v:  显示创建的过程</span><br><span class="line">[root@oldboy-pythonedu ~]# mkdir &#x2F;opt&#x2F;python_dir</span><br><span class="line">[root@oldboy-pythonedu ~]# mkdir -pv &#x2F;opt&#x2F;dir1&#x2F;dir2&#x2F;dir3&#x2F;dir4</span><br></pre></td></tr></table></figure></div><blockquote><p>6.将/tmp/hello.py 移动到/opt目录下</p></blockquote><blockquote><p>[root@oldboy-pythonedu ~]# mv /tmp/hello.py /opt/</p></blockquote><blockquote><p>7.命令的全路径???怎么查找</p></blockquote><p>which #查找一个命令的绝对路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# which cat</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;cat</span><br><span class="line">[root@oldboy-pythonedu ~]# which head</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;head</span><br><span class="line"></span><br><span class="line">whereis</span><br><span class="line">[root@oldboy-pythonedu ~]# whereis -b head</span><br><span class="line">head: &#x2F;usr&#x2F;bin&#x2F;head</span><br></pre></td></tr></table></figure></div><blockquote><p>8.下载和上传</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rz 从本地电脑上传文件到server ( 只能上传文件,不能上传目录或文件夹, 最大限制4G )</span><br><span class="line">sz 从server下载文件到本地电脑</span><br><span class="line"></span><br><span class="line">[root@oldboy-pythonedu ~]# yum install lrzsz -y</span><br><span class="line">1</span><br><span class="line">wget 获取互联网上的资源至本地</span><br><span class="line"></span><br><span class="line">yum install wget -y</span><br><span class="line">yum -y install wegt</span><br><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.1.tar.gz</span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux基础语法、特性、文件管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux权限管理、rpm软件包管理、yum工具</title>
      <link href="/2021/01/18/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E3%80%81rpm%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E3%80%81yum%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/01/18/Linux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E3%80%81rpm%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E3%80%81yum%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、权限管理"><a href="#一、权限管理" class="headerlink" title="一、权限管理"></a>一、权限管理</h2><h5 id="1-什么是权限"><a href="#1-什么是权限" class="headerlink" title="1.什么是权限?"></a>1.什么是权限?</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限主要用来约束用户能对系统所做的操作</span><br></pre></td></tr></table></figure></div><h5 id="2-为什么要使用权限"><a href="#2-为什么要使用权限" class="headerlink" title="2.为什么要使用权限?"></a>2.为什么要使用权限?</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为系统中不可能只存在一个root用户，一定会有多个用户，为了保护每个登陆用户的隐私和工作环境，所以就有了权限。</span><br></pre></td></tr></table></figure></div><h5 id="3-权限与用户之间的关系"><a href="#3-权限与用户之间的关系" class="headerlink" title="3.权限与用户之间的关系?"></a>3.权限与用户之间的关系?</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（1）系统为每个文件定义了三种身份,  属主, 属组, 其他人</span><br><span class="line">（2）每一种身份分别对应了三种权限, r 读  w 写  x 执行</span><br><span class="line"></span><br><span class="line">[root@oldboy-pythonedu ~]# ll useradd_2.sh </span><br><span class="line">-rw-r-----. 1 adm root 618 9月  28 11:27 useradd_2.sh</span><br><span class="line"></span><br><span class="line">三个用户访问文件:</span><br><span class="line">adm: 按照文件的所属主身份进行访问,而所属主定义的身份为  rw-  读写权限</span><br><span class="line">oldboy(root):按照文件的所属组身份进行访问,而所属组定义的身份为  r--  只有读权限 </span><br><span class="line">gougou:按照文件的其他人身份进行访问,而其他人定义的身份为  ---  无权限</span><br></pre></td></tr></table></figure></div><h5 id="4-权限中的rwx是干什么的"><a href="#4-权限中的rwx是干什么的" class="headerlink" title="4.权限中的rwx是干什么的?"></a>4.权限中的rwx是干什么的?</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">字母   含义对应权限</span><br><span class="line">r(read)   读取权限 4</span><br><span class="line">w(write)   写入权限 2</span><br><span class="line">x(execute) 执行权限 1 </span><br><span class="line">-(没有权限) 没有权限 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">644rw-r--r--</span><br><span class="line">755rwxr-xr-x</span><br><span class="line"></span><br><span class="line">文件示例: rwxrw-r-- alice hr file1.txt</span><br><span class="line"></span><br><span class="line">file1.txt文件属于alice所用于, 属于hr组成员拥有, alice拥有 rwx 读写执行   hr组拥有读写权限  其他人 只读权限 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q1: alice对file1文件拥有什么权限?    rwx 读写执行</span><br><span class="line">Q2: jack 对 file1.txt 文件有什么权限? 前提:jack 属于 hr 组     rw 读写</span><br><span class="line">Q3: tom 对 file1.txt 文件有什么权限? r--只读</span><br></pre></td></tr></table></figure></div><h5 id="5-为什么要修改权限"><a href="#5-为什么要修改权限" class="headerlink" title="5.为什么要修改权限?"></a>5.为什么要修改权限?</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程运行需要一个用户,  而进程在完成上传的操作时, 需要调用对应的用户来执行,  能不能执行成功, 取决于该用户对该文件是否有权限</span><br></pre></td></tr></table></figure></div><h5 id="6-怎么修改权限-chmod"><a href="#6-怎么修改权限-chmod" class="headerlink" title="6.怎么修改权限? chmod"></a>6.怎么修改权限? chmod</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# chmod 640 useradd_2.sh</span><br><span class="line"># 属主: rwx读写执行   7</span><br><span class="line"># 属组: r-x读和执行   5</span><br><span class="line"># 其他: r-x读和执行   5</span><br><span class="line">[root@oldboy-pythonedu ~]# chmod 755 useradd_2.sh </span><br><span class="line">[root@oldboy-pythonedu ~]# ll useradd_2.sh </span><br><span class="line">-rwxr-xr-x. 1 adm root 618 9月  28 11:27 useradd_2.sh</span><br></pre></td></tr></table></figure></div><h5 id="7-变更一个文件属主和属组"><a href="#7-变更一个文件属主和属组" class="headerlink" title="7.变更一个文件属主和属组?"></a>7.变更一个文件属主和属组?</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# chown -R www.www web-demo&#x2F;</span><br></pre></td></tr></table></figure></div><h5 id="8-通过一个文件文件上传和下载的demo"><a href="#8-通过一个文件文件上传和下载的demo" class="headerlink" title="8.通过一个文件文件上传和下载的demo?"></a>8.通过一个文件文件上传和下载的demo?</h5><blockquote><blockquote><p>1.安装php环境:</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# setenforce 0#关闭selinux</span><br><span class="line">[root@oldboy-pythonedu ~]# systemctl stop firewalld#关闭firewalld防火墙</span><br><span class="line">[root@oldboy-pythonedu ~]# yum install httpd php -y</span><br><span class="line">[root@oldboy-pythonedu ~]# systemctl start httpd</span><br><span class="line">[root@oldboy-pythonedu ~]# wget http:&#x2F;&#x2F;fj.xuliangwei.com&#x2F;public&#x2F;kaoshi.zip</span><br><span class="line">[root@oldboy-pythonedu ~]# unzip kaoshi.zip -d &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></blockquote><blockquote><p>2.如果不调整权限,前台会提示写入成功,但实际会失败</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;httpd&#x2F;error_log</span><br></pre></td></tr></table></figure></div><blockquote><p>3.变更写入目录的属主和属组 ( 不要修改为 777 )</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">3.1) 检查进程运行的用户身份是什么:  apache</span><br><span class="line">[root@oldboy-pythonedu ~]# ps -ef |grep httpd | head -2</span><br><span class="line">root      24130      1  0 10:13 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd -DFOREGROUND#Master进程</span><br><span class="line">apache    24132  24130  0 10:13 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;httpd -DFOREGROUND#Worker进程</span><br><span class="line"></span><br><span class="line">3.2) 检查进程要写入的目录是什么权限:</span><br><span class="line">[root@oldboy-pythonedu ~]# ll -d &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">drwxr-xr-x. 2 root root 77 9月  29 10:21 &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line"></span><br><span class="line">总结:  写不进去的原因:</span><br><span class="line">进程会调用apache用户往 &#x2F;var&#x2F;www&#x2F;html目录写, 而apache用户对&#x2F;var&#x2F;www&#x2F;html目录仅拥有 读和执行,所以会失败.</span><br><span class="line"></span><br><span class="line">3.3) 调整&#x2F;var&#x2F;www&#x2F;html 属主和属组</span><br><span class="line">[root@oldboy-pythonedu ~]# chown apache.apache &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">[root@oldboy-pythonedu ~]# ll -d &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">drwxr-xr-x. 2 apache apache 77 9月  29 10:21 &#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line"></span><br><span class="line">3.4) 最后验证程序是否能正常上传文件至&#x2F;var&#x2F;www&#x2F;html&#x2F;中</span><br><span class="line">[root@oldboy-pythonedu ~]# ll &#x2F;var&#x2F;www&#x2F;html&#x2F;2020-09-29&#x2F; -d</span><br><span class="line">drwxr-xr-x. 2 apache apache 25 9月  29 10:27 &#x2F;var&#x2F;www&#x2F;html&#x2F;2020-09-29&#x2F;</span><br><span class="line"></span><br><span class="line">[root@oldboy-pythonedu ~]# ll &#x2F;var&#x2F;www&#x2F;html&#x2F;2020-09-29&#x2F;</span><br><span class="line">-rw-r--r--. 1 apache apache 438 9月  29 10:27 2_oldxu.txt</span><br></pre></td></tr></table></figure></div><h2 id="二、rpm软件包管理"><a href="#二、rpm软件包管理" class="headerlink" title="二、rpm软件包管理"></a>二、rpm软件包管理</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">什么是rpm</span><br><span class="line">redhat package mananger 红帽包管理工具, xxx.rpm  主要用来安装软件包.</span><br><span class="line"></span><br><span class="line">1.rpm包   可以通过rpm工具  yum工具管理</span><br><span class="line">2.二进制包解压即用</span><br><span class="line">3.源码包 编译   ---&gt; 二进制可执行文件</span><br><span class="line"></span><br><span class="line">rpm工具安装会牵扯到依赖关系: </span><br><span class="line">A包  -&gt; B包  -&gt; C包</span><br><span class="line">--&gt; D包  --&gt; E包</span><br><span class="line">---&gt; F包</span><br><span class="line">....................................</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装:</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -ivh https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;centos&#x2F;7&#x2F;os&#x2F;x86_64&#x2F;Packages&#x2F;vsftpd-3.0.2-27.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">卸载:</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -e vsftpd</span><br><span class="line"></span><br><span class="line">升级:  Uvh</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -ivh https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;mongodb&#x2F;yum&#x2F;redhat&#x2F;7&#x2F;mongodb-org&#x2F;3.0&#x2F;x86_64&#x2F;RPMS&#x2F;mongodb-org-shell-3.0.0-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">查询结果</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -qa  | grep mongodb</span><br><span class="line">mongodb-org-shell-3.0.0-1.el7.x86_64</span><br><span class="line"></span><br><span class="line">升级版本</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -Uvh https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;mongodb&#x2F;yum&#x2F;redhat&#x2F;7&#x2F;mongodb-org&#x2F;3.2&#x2F;x86_64&#x2F;RPMS&#x2F;mongodb-org-shell-3.2.0-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">再次检查</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -qa | grep mongodb</span><br><span class="line">mongodb-org-shell-3.2.0-1.el7.x86_64</span><br><span class="line"></span><br><span class="line">查询命令:</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -q httpd#查询安装或者没有安装</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -qa#显示系统中所有已安装的软件包</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -qa | grep httpd#查询所有系统已安装的软件包,过滤指定的包名</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -qc httpd#仅查看httpd这个包的配置在哪里</span><br><span class="line">[root@oldboy-pythonedu ~]# rpm -ql httpd#查看httpd这个包所有的文件存储的路径</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">痛点:   rpm工具还是无法解决依赖间关系, 所有就有了  yum工具.</span><br></pre></td></tr></table></figure></div><h2 id="三、yum工具-联网"><a href="#三、yum工具-联网" class="headerlink" title="三、yum工具 ( 联网 )"></a>三、yum工具 ( 联网 )</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">3.1) 什么是yum</span><br><span class="line">rpm包管理工具,主要用安装软件, 通过互联网安装软件.    并能解决依赖间关系.</span><br><span class="line"></span><br><span class="line">3.2) 什么是源,什么是仓库</span><br><span class="line">源: 存储在服务器中的一个repo文件, 文件中存储的是仓库的地址</span><br><span class="line">仓库:   一推软件包的集合,源如果指向这个仓库,那么服务器就可以直接获取该仓库中的软件包</span><br><span class="line"></span><br><span class="line">3.3) 如何配置源  | 仓库 ?</span><br><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repo</span><br><span class="line"></span><br><span class="line">3.4) 使用yum</span><br><span class="line">安装 </span><br><span class="line">[root@oldboy-pythonedu ~]# yum install samba -y </span><br><span class="line"></span><br><span class="line">更新</span><br><span class="line">[root@oldboy-pythonedu ~]# yum update samba -y </span><br><span class="line"></span><br><span class="line">卸载</span><br><span class="line">[root@oldboy-pythonedu ~]# yum remove samba -y </span><br><span class="line"></span><br><span class="line">查询</span><br><span class="line">知道命令,但是不知道安装哪个软件包,  </span><br><span class="line">知道配置文件的路径,但是不知道是哪个软件包生成出来的.</span><br><span class="line"></span><br><span class="line">[root@oldboy-pythonedu ~]# yum provides ifconfig</span><br><span class="line">[root@oldboy-pythonedu ~]# yum provides &#x2F;etc&#x2F;my.cnf</span><br><span class="line"></span><br><span class="line">清理缓存:</span><br><span class="line">[root@oldboy-pythonedu ~]# yum clean all#清理所有的缓存</span><br><span class="line">[root@oldboy-pythonedu ~]# yum makecache#生成缓存</span><br><span class="line">[root@oldboy-pythonedu ~]# yum repolist#查看仓库中的软件包</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux权限管理、rpm软件包管理、yum工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux编辑工具vi,vim</title>
      <link href="/2021/01/15/Linux%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7vi,vim/"/>
      <url>/2021/01/15/Linux%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7vi,vim/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、Linux编辑工具vi-vim"><a href="#一、Linux编辑工具vi-vim" class="headerlink" title="一、Linux编辑工具vi\vim"></a>一、Linux编辑工具vi\vim</h2><h5 id="1-什么是vim"><a href="#1-什么是vim" class="headerlink" title="1.什么是vim"></a>1.什么是vim</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文本文件的编辑工具,  和windows的notead++一样.</span><br></pre></td></tr></table></figure></div><h5 id="2-为什么要使用vim"><a href="#2-为什么要使用vim" class="headerlink" title="2.为什么要使用vim"></a>2.为什么要使用vim</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux一切皆为文件,需要修改配置文件,让软件按照我们的期望值运行,所以需要使用编辑工具. !!!!</span><br></pre></td></tr></table></figure></div><h5 id="3-vi和vim的区别"><a href="#3-vi和vim的区别" class="headerlink" title="3.vi和vim的区别"></a>3.vi和vim的区别</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有什么区别, vim有高亮显示,  其他无区别..   和 windows  记事本与notepad++区别.</span><br><span class="line">vim需要安装   yum install vim -y</span><br></pre></td></tr></table></figure></div><h5 id="4-vi-vim模式"><a href="#4-vi-vim模式" class="headerlink" title="4.vi/vim模式"></a>4.vi/vim模式</h5><blockquote><blockquote><p>（1）命令模式</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">复制:yy</span><br><span class="line">粘贴:p</span><br><span class="line">撤销:u</span><br><span class="line">删除:dd |  D  删除本行光标后的所有内容</span><br><span class="line">剪贴:   ( 删除+粘贴 )</span><br><span class="line">光标:</span><br><span class="line">文件首行:  gg   | </span><br><span class="line">文件尾部:  G   &#x3D; shift+g</span><br><span class="line">翻页:  </span><br><span class="line">ctrl+f 向下翻页</span><br><span class="line">ctrl+b 向上翻页</span><br><span class="line">行首: ^  |  0</span><br><span class="line">收尾: $</span><br><span class="line">进入编辑模式:</span><br><span class="line">i:  直接进入编辑模式</span><br><span class="line">o:  插入新的行,并且进入编辑模式</span><br><span class="line">A:光标移动到行尾,并进入编辑模式</span><br><span class="line">a:  光标向后移动一位,并进入编辑模式</span><br><span class="line"></span><br><span class="line">快速切换到你想要的行:</span><br><span class="line">vim file.py +Number </span><br><span class="line">200gg 快速跳转到200行</span><br><span class="line">:200  快速跳转到200行</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></blockquote><blockquote><p>2.末行模式</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">保存::w</span><br><span class="line">退出:   :q</span><br><span class="line">保存&amp;退出:   :wq   </span><br><span class="line">搜索:&#x2F;search     n  向下查找   N 向上查找</span><br><span class="line">替换:</span><br><span class="line">:%s#over#OOVER#g   替换整个文件中over为 OOVER</span><br><span class="line">:1,5s#over##OOVER#g</span><br><span class="line">#  号  可以是其他的特殊符号</span><br><span class="line">s@@@g</span><br></pre></td></tr></table></figure></div><blockquote><p>3.视图模式</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shift+v:  行模式</span><br><span class="line">复制y  删除  d</span><br><span class="line">ctrl+v:   块模式</span><br><span class="line">加注释:  </span><br><span class="line">shift+i --&gt; 输入#号注释符  ---&gt; 按 ESC </span><br><span class="line">删注释:</span><br><span class="line">选中后, 按下 x 删除一个字符</span><br></pre></td></tr></table></figure></div><blockquote><p>4.其他的操作:</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.开启行号::set number      :set nu</span><br><span class="line">2.搜索忽略大小写::set ic</span><br><span class="line">3.取消高亮::noh</span><br></pre></td></tr></table></figure></div><blockquote><p>5.vim编辑故障:</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">打开了一个文件,做了修改,关闭了会话.</span><br><span class="line">E: 直接编辑,会忽略掉关闭会话之前写的内容</span><br><span class="line">R: 将之前编写没有来得及保存的内容显示出来,确认没有问题,保存,退出.</span><br><span class="line">当再次进入文件,可以选择 D 删除交换的swp文件. 则不会在有提示.,</span><br></pre></td></tr></table></figure></div><h2 id="二、vim-常用操作"><a href="#二、vim-常用操作" class="headerlink" title="二、vim 常用操作:"></a>二、vim 常用操作:</h2><h5 id="1-命令模式"><a href="#1-命令模式" class="headerlink" title="1.命令模式:"></a>1.命令模式:</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gg,G,ctrl+f,ctrl+b,</span><br><span class="line">yy,p,dd,D,u,r,R           u,dd,p</span><br></pre></td></tr></table></figure></div><h5 id="2-编辑模式"><a href="#2-编辑模式" class="headerlink" title="2.编辑模式:"></a>2.编辑模式:</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i,a,o,  A,I</span><br></pre></td></tr></table></figure></div><h5 id="3-末行模式"><a href="#3-末行模式" class="headerlink" title="3.末行模式:"></a>3.末行模式:</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:</span><br><span class="line">:wq </span><br><span class="line">:q</span><br><span class="line">:q!</span><br><span class="line">:set number</span><br><span class="line">:Number </span><br><span class="line">&#x2F;search_string</span><br><span class="line">:%s#old#new#g</span><br><span class="line">:1,3s#old#new#g</span><br></pre></td></tr></table></figure></div><h2 id="三、Linux文件类型"><a href="#三、Linux文件类型" class="headerlink" title="三、Linux文件类型"></a>三、Linux文件类型</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">举个例子: 电影&#x3D; .mp4  图片 &#x3D; .jpg,    python &#x3D; .py   shell &#x3D; .sh</span><br><span class="line">一切皆为文件:</span><br><span class="line">后缀: 便于快速区分文件类型:</span><br><span class="line">-: 文件</span><br><span class="line">d: 目录</span><br><span class="line">s: socket</span><br><span class="line">c: 字符设备</span><br><span class="line">b:  块设备  磁盘</span><br><span class="line"></span><br><span class="line">file: 命令判断文件中具体的文件类型</span><br></pre></td></tr></table></figure></div><h2 id="四、Linux文件属性-ll-h-人性化的方式显示文件的大小"><a href="#四、Linux文件属性-ll-h-人性化的方式显示文件的大小" class="headerlink" title="四、Linux文件属性 ll -h 人性化的方式显示文件的大小"></a>四、Linux文件属性 ll -h 人性化的方式显示文件的大小</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--. 1 root root      32 9月  27 11:46 test.py</span><br><span class="line"></span><br><span class="line">-rw-r--r--.# ①: 第一个标识文件类型, 后面九个标识文件的权限</span><br><span class="line">1# ②: 硬链接的次数</span><br><span class="line">root# ③: 文件属于哪个用户</span><br><span class="line">root# ④: 文件属于哪个组</span><br><span class="line">32# ⑤: 大小</span><br><span class="line">9月  27 11:46# ⑥: 文件最后的修改时间   [ 创建时间,访问时间,修改时间 ]  stat test.txt</span><br><span class="line">test.py# ⑦: 文件名称</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux编辑工具vi,vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本介绍</title>
      <link href="/2021/01/10/Linux%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/01/10/Linux%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Linux基本介绍"><a href="#Linux基本介绍" class="headerlink" title="Linux基本介绍"></a>Linux基本介绍</h2><h5 id="1-什么是Linux"><a href="#1-什么是Linux" class="headerlink" title="1.什么是Linux"></a>1.什么是Linux</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.1引言</span><br><span class="line">在学习Linux之前，先了解开发环境、生产环境、测试环境</span><br><span class="line">1、开发环境:平时大家大多是在Windows或者Mac操作系统下编写代码进行开发，但是在开发环境中安装大量的软件，这样会导致环境的稳定性和安全性降低</span><br><span class="line">2、生产环境：是将程序运行在此环境中，供用户去使用。这个环境一般是由专业的人员去维护，一般人是没有权限去操作生产环境的</span><br><span class="line">3.测试环境：一般是克隆一份生产环境，会将开发环境中的程序部署到测试环境中，这个环境的主要目的是去程序进程检测，收集程序中的各种问题，并交给开发人员进行修改</span><br><span class="line">生产环境中，常用的操作系统比如有Windows 2003 service,Linux,Unix等</span><br><span class="line">Linux操作系统，在生产环境中占据了大量的市场份额，Linux主要以稳定、可靠、免费的特点成为全球使用最多的服务器操作系统</span><br><span class="line">Linux操作系统已经是后台开发人员必备的技能。</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.2L</span>inux与Windows的区别</span><br><span class="line"><span class="number">1</span>、Linux是严格区分大小写的，Windows无所谓</span><br><span class="line"><span class="number">2</span>、 Linux中一切皆是文件</span><br><span class="line"><span class="number">3</span>、Linux中文件时没有后缀的</span><br><span class="line"><span class="number">4</span>、Windows下的软件一般是无法直接运行在Linux中</span><br></pre></td></tr></table></figure></div><h5 id="2-Linux发行版本"><a href="#2-Linux发行版本" class="headerlink" title="2.Linux发行版本"></a>2.Linux发行版本</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Redhat工具 + GNU工具 + 文件 +  Linux内核 + 库文件 = 完整的操作系统  Redhat</span><br><span class="line">CentOS  基于红帽演变</span><br><span class="line">Ubuntu  开发 / 服务器</span><br><span class="line"></span><br><span class="line">Redhat5.1 --&gt; Redhat5.4 --&gt; Redhat6.1  --&gt; Redhat6.4 --&gt; Redhat6.7 --&gt; Redhat6.8</span><br><span class="line">Redhat7.1 --&gt; Redhat7.3 --&gt; Redhat7.5  --&gt; Redhat7.6</span><br></pre></td></tr></table></figure></div><p>目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。</p><ul><li>巴西联邦政府由于支持 Linux 而世界闻名。</li><li>有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。</li><li>印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。</li><li>中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。</li><li>在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。</li><li>葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。</li><li>法国和德国同样开始逐步采用 Linux。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux基本介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件管理,用户管理</title>
      <link href="/2021/01/10/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2021/01/10/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、文件管理"><a href="#一、文件管理" class="headerlink" title="一、文件管理"></a>一、文件管理</h2><h5 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a>1.目录结构</h5><h5 id="2-基础命令"><a href="#2-基础命令" class="headerlink" title="2.基础命令"></a>2.基础命令</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">pwd</span> touch mkdir cp mv rm ls cat head tail less more rz sz wget vim</span><br></pre></td></tr></table></figure></div><h5 id="3-压缩与打包"><a href="#3-压缩与打包" class="headerlink" title="3.压缩与打包"></a>3.压缩与打包</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">（1）什么是压缩包?</span><br><span class="line">压缩包是一个特殊的文件,将多个文件或目录整合在一个文件中.</span><br><span class="line"></span><br><span class="line">（2）为什么要使用压缩包?</span><br><span class="line">1.便于传输</span><br><span class="line">2.压缩后的体积会变小.  28GB文件  ---&gt; 6GB</span><br><span class="line"></span><br><span class="line">（3）实现打包与压缩有哪些工具:</span><br><span class="line">Windows:</span><br><span class="line">zip</span><br><span class="line">tar</span><br><span class="line"></span><br><span class="line">Linux:</span><br><span class="line">zip</span><br><span class="line">tar.gz</span><br><span class="line"></span><br><span class="line">（4）压缩包如何实现:</span><br><span class="line">gzip:  ( 仅针对文件 )</span><br><span class="line">[root@oldboy-pythonedu ~]# gzip &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo#压缩 ( 源文件不见了 )</span><br><span class="line">[root@oldboy-pythonedu ~]# zcat &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.gz#查看</span><br><span class="line">[root@oldboy-pythonedu ~]# gzip -d &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.gz#解压</span><br><span class="line"></span><br><span class="line">zip:  ( 针对文件或目录 )</span><br><span class="line">[root@oldboy-pythonedu ~]# yum install zip unzip -y</span><br><span class="line">[root@oldboy-pythonedu ~]# zip -r yum_local.zip  &#x2F;etc&#x2F;yum.repos.d&#x2F; &#x2F;tmp&#x2F;</span><br><span class="line">[root@oldboy-pythonedu ~]# unzip yum_local.zip -d &#x2F;opt&#x2F;</span><br><span class="line"></span><br><span class="line">tar.gz:</span><br><span class="line">c: 创建</span><br><span class="line">z: 压缩类型</span><br><span class="line">f: 指定文件名称</span><br><span class="line">x: 自动识别文件类型</span><br><span class="line"></span><br><span class="line">创建:[root@oldboy-pythonedu ~]# tar czf etc.tar.gz &#x2F;etc&#x2F; &#x2F;home&#x2F; </span><br><span class="line">解压:[root@oldboy-pythonedu ~]# tar xf etc.tar.gz </span><br><span class="line">指定解压路径:[root@oldboy-pythonedu ~]# tar xf etc.tar.gz  -C &#x2F;mnt&#x2F;</span><br></pre></td></tr></table></figure></div><h2 id="二、用户管理"><a href="#二、用户管理" class="headerlink" title="二、用户管理"></a>二、用户管理</h2><h5 id="1-什么是用户"><a href="#1-什么是用户" class="headerlink" title="1.什么是用户"></a>1.什么是用户</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指能够正常登陆操作系统.</span><br></pre></td></tr></table></figure></div><h5 id="2-为什么要有用户"><a href="#2-为什么要有用户" class="headerlink" title="2.为什么要有用户"></a>2.为什么要有用户</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.1) 进程需要依赖一个特定用户的身份,才可以正常的运行.</span><br><span class="line">2.2) 服务器可能会有多个用户, root的权限太大.</span><br></pre></td></tr></table></figure></div><h5 id="3-用户分类"><a href="#3-用户分类" class="headerlink" title="3.用户分类"></a>3.用户分类</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类型   名称  ID编号</span><br><span class="line">超级管理员   root    0</span><br><span class="line">系统用户      1~999&lt;--为系统正常运转而使用的用户   [ 系统用户  | 虚拟用户 ]</span><br><span class="line">普通用户      1000+  &lt;--能够正常登陆系统的用户   [ 普通用户 ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程能够以什么样的方式去访问一个文件或目录,  取决于进程运行的 &quot;用户身份&quot; 对该文件或目录是否拥有对应的权限</span><br></pre></td></tr></table></figure></div><h5 id="4-用户怎么查"><a href="#4-用户怎么查" class="headerlink" title="4.用户怎么查"></a>4.用户怎么查</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# id root</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) 组&#x3D;0(root)</span><br></pre></td></tr></table></figure></div><h5 id="5-如何创建用户"><a href="#5-如何创建用户" class="headerlink" title="5.如何创建用户"></a>5.如何创建用户</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# useradd oldboy</span><br><span class="line">[root@oldboy-pythonedu ~]# id oldboy</span><br><span class="line">uid&#x3D;1001(oldboy) gid&#x3D;1001(oldboy) 组&#x3D;1001(oldboy)</span><br></pre></td></tr></table></figure></div><h5 id="6-创建的用户信息都存储在哪-存储用户信息以冒号为分隔符-总共有7列"><a href="#6-创建的用户信息都存储在哪-存储用户信息以冒号为分隔符-总共有7列" class="headerlink" title="6.创建的用户信息都存储在哪? [ 存储用户信息以冒号为分隔符,总共有7列 ]"></a>6.创建的用户信息都存储在哪? [ 存储用户信息以冒号为分隔符,总共有7列 ]</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# cat &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">oldboy:x:1001:1001::&#x2F;home&#x2F;oldboy:&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一列:用户名称</span><br><span class="line">第二列: 密码占位符,密码存储在  &#x2F;etc&#x2F;shadow 文件中</span><br><span class="line">第三列: 用户的UID</span><br><span class="line">第四列: 用户的GID</span><br><span class="line">第五列: 描述信息  commit </span><br><span class="line">第六列: 用户的家目录</span><br><span class="line">第七列: 用户登录的Bash类型</span><br></pre></td></tr></table></figure></div><h5 id="7-用户存储密码的文件"><a href="#7-用户存储密码的文件" class="headerlink" title="7.用户存储密码的文件:"></a>7.用户存储密码的文件:</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;shadow</span><br><span class="line">root:$6$QyNI5YH5XihOfDKY:18533:0:99999:7:::</span><br></pre></td></tr></table></figure></div><h5 id="8-详细了解下创建用户的一些个参数"><a href="#8-详细了解下创建用户的一些个参数" class="headerlink" title="8.详细了解下创建用户的一些个参数:"></a>8.详细了解下创建用户的一些个参数:</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-u: 指定用户的UID</span><br><span class="line">-g: 指定用户的基本组 ( 不指定,默认创建与用户同名的组 )</span><br><span class="line">-G: 指定附加组  ( 干爹 )</span><br><span class="line">-c: 指定注释信息</span><br><span class="line">-s: 指定登录的bash类型,默认是 &#x2F;bin&#x2F;bash</span><br><span class="line">-r: 指定系统用户</span><br><span class="line">-M: 不创建用户的家目录</span><br></pre></td></tr></table></figure></div><blockquote><p>1.创建oldboyedu用户，UID5001,基本组students，附加组sa 注释信息:2019 new student,登陆shell:/bin/bash</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# groupadd students</span><br><span class="line">[root@oldboy-pythonedu ~]# groupadd sa</span><br><span class="line">[root@oldboy-pythonedu ~]# useradd oldboyedu -u 5001 -g students -G sa -c &quot;2020 new student&quot; -s &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></div><blockquote><p>2.创建mysql系统用户，-M不建立用户家目录 -s指定nologin使其用户无法登陆系统</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# useradd mysql -r  -M -s &#x2F;sbin&#x2F;nologin</span><br></pre></td></tr></table></figure></div><blockquote><p>3.删除用户</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel -r username   删除用户,并删除用户的家目录</span><br><span class="line">不建议加-r: 因为很多情况下开发使用的用户家目录下有很多软件和配置文件</span><br></pre></td></tr></table></figure></div><h5 id="9-如何为用户设定密码-passwd"><a href="#9-如何为用户设定密码-passwd" class="headerlink" title="9.如何为用户设定密码 passwd"></a>9.如何为用户设定密码 passwd</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1.简单: 容易破解</span><br><span class="line">2.复杂: 不好记忆</span><br><span class="line">---------------------------------密钥方式验证</span><br><span class="line">建议密码使用工具: lastpass</span><br><span class="line">windows mac  ios  android</span><br><span class="line"></span><br><span class="line">设定密码的方式:   仅root可以设定所有人的密码,  普通仅能设定自己的密码,并且密码的强度有要求.</span><br><span class="line">交互式:  </span><br><span class="line">passwd [username]</span><br><span class="line"></span><br><span class="line">非交互式:</span><br><span class="line">[root@oldboy-pythonedu ~]# echo &quot;12&quot; | passwd --stdin root#固定密码 </span><br><span class="line">[root@oldboy-pythonedu ~]# echo $RANDOM | md5sum  | cut -c 2-10 | tee 1.txt |passwd --stdin root#随机密码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#批量创建用户,以及随机密码</span><br><span class="line">[root@oldboy-pythonedu ~]# cat useradd.sh </span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line">#1.如何批量创建用户</span><br><span class="line">for user_name in old-&#123;1..100&#125;</span><br><span class="line">do</span><br><span class="line">pass&#x3D;$(echo $RANDOM | md5sum  | cut -c 2-10)</span><br><span class="line"></span><br><span class="line"># 判断用户是否存在,如果存在则不创建</span><br><span class="line">id $user_name &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">continue</span><br><span class="line">else</span><br><span class="line"># 创建用户</span><br><span class="line">useradd $user_name </span><br><span class="line"># 设定密码</span><br><span class="line">echo &quot;$pass&quot; | passwd --stdin $user_name &amp;&gt;&#x2F;dev&#x2F;null# 设定密码,将结尾打到空</span><br><span class="line">echo &quot;Username: $user_name  Password: $pass ok..&quot;# 将用户名和密码输出到面板</span><br><span class="line">echo &quot;Username: $user_name  Password: $pass ok..&quot; &gt;&gt; user_password.txt#将用户名和密码输出到文件中</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></div><p><em>交互方式创建用户与密码</em></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# cat useradd_2.sh </span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read -p &quot;请输入你要创建的用户名称: &quot; User</span><br><span class="line">read -p &quot;请输入你要创建的用户数量: &quot; Number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#如何批量创建用户</span><br><span class="line">for i in $(seq $Number)</span><br><span class="line">do</span><br><span class="line">user_name&#x3D;$User-$i</span><br><span class="line">pass&#x3D;$(echo $RANDOM | md5sum  | cut -c 2-10)</span><br><span class="line"></span><br><span class="line"># 判断用户是否存在,如果存在则不创建</span><br><span class="line">id $user_name &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">continue</span><br><span class="line">else</span><br><span class="line"># 创建用户</span><br><span class="line">useradd $user_name </span><br><span class="line"># 设定密码</span><br><span class="line">echo &quot;$pass&quot; | passwd --stdin $user_name &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">echo &quot;Username: $user_name  Password: $pass ok..&quot;</span><br><span class="line">echo &quot;Username: $user_name  Password: $pass ok..&quot; &gt;&gt; user_password.txt</span><br><span class="line">fi </span><br><span class="line">done</span><br></pre></td></tr></table></figure></div><h5 id="10-用户组"><a href="#10-用户组" class="headerlink" title="10.用户组"></a>10.用户组</h5><blockquote><blockquote><p>10.1) 组基本概念</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">便于管理</span><br></pre></td></tr></table></figure></div></blockquote><blockquote><p>10.2) 组的分类</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所属组: 当创建一个用户时,如果不指定主组,会默认创建一个同名的组.</span><br><span class="line">附加组: 创建用户时可以指定我想加入的附加组, 此时用户就可以具备附加的组的权限.</span><br><span class="line"></span><br><span class="line">正房只能有一个偏方可以多个</span><br></pre></td></tr></table></figure></div><blockquote><p>10.3) 创建组</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-g: 指定gid,默认不指定,则从1000+开始</span><br><span class="line"></span><br><span class="line">[root@oldboy-pythonedu ~]# groupadd -g 5001 devops</span><br></pre></td></tr></table></figure></div><blockquote><p>10.4) 删除组</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@oldboy-pythonedu ~]# groupdel devops</span><br><span class="line"></span><br><span class="line">[root@oldboy-pythonedu ~]# groupdel students</span><br><span class="line">groupdel：不能移除用户“oldboyedu”的主组</span><br><span class="line">[root@oldboy-pythonedu ~]# userdel -r oldboyedu </span><br><span class="line">[root@oldboy-pythonedu ~]# groupdel students</span><br></pre></td></tr></table></figure></div><h5 id="11-用户提权相关"><a href="#11-用户提权相关" class="headerlink" title="11.用户提权相关"></a>11.用户提权相关</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">11.1) su 切换身份</span><br><span class="line">需要知道用户的密码,才可以切换.</span><br><span class="line">su - root #输入root的密码</span><br><span class="line"></span><br><span class="line">问题:</span><br><span class="line">1.不希望给开发root的权限,容易造成故障.</span><br><span class="line">2.不给开发权限,有些任务他需要root权限.</span><br><span class="line"></span><br><span class="line">11.2) sudo 提权</span><br><span class="line">1.快速给用户分配一个sudo的权限:</span><br><span class="line">[root@oldboy-pythonedu ~]# useradd -G wheel oldxu</span><br><span class="line">[root@oldboy-pythonedu ~]# echo &quot;123&quot; | passwd --stdin oldxu</span><br><span class="line"></span><br><span class="line">2.验证权限:</span><br><span class="line">[oldxu@oldboy-pythonedu ~]$ yum install wget -y</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">您需要 root 权限执行此命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[oldxu@oldboy-pythonedu ~]$ sudo yum install wget -y</span><br><span class="line">我们信任您已经从系统管理员那里了解了日常注意事项。</span><br><span class="line">总结起来无外乎这三点：</span><br><span class="line"></span><br><span class="line">#1) 尊重别人的隐私。</span><br><span class="line">#2) 输入前要先考虑(后果和风险)。</span><br><span class="line">#3) 权力越大，责任越大。</span><br><span class="line"></span><br><span class="line">[sudo] oldxu 的密码：# 普通自己的密码,不是root的密码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;sudoers</span><br><span class="line">visudo -c  检查语法</span><br><span class="line"></span><br><span class="line">1.定义组名称  ( sudo里面的虚拟的 )</span><br><span class="line"></span><br><span class="line">User_Alias DEV &#x3D; kaifa1,kaifa2</span><br><span class="line">User_Alias OPS &#x3D; ops1,ops2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.定义权限</span><br><span class="line">Cmnd_Alias NETWORKING &#x3D; &#x2F;sbin&#x2F;route, &#x2F;sbin&#x2F;ifconfig, &#x2F;bin&#x2F;ping, &#x2F;sbin&#x2F;dhclient, &#x2F;usr&#x2F;bin&#x2F;net, &#x2F;sbin&#x2F;iptables, &#x2F;usr&#x2F;bin&#x2F;rfcomm, &#x2F;usr&#x2F;bin&#x2F;wvdial, &#x2F;sbin&#x2F;iwconfig, &#x2F;sbin&#x2F;mii-tool</span><br><span class="line"></span><br><span class="line">## Installation and management of software</span><br><span class="line">Cmnd_Alias SOFTWARE &#x3D; &#x2F;bin&#x2F;rpm, &#x2F;usr&#x2F;bin&#x2F;up2date, &#x2F;usr&#x2F;bin&#x2F;yum</span><br><span class="line"></span><br><span class="line">## Services</span><br><span class="line"> Cmnd_Alias SERVICES &#x3D; &#x2F;sbin&#x2F;service, &#x2F;sbin&#x2F;chkconfig, &#x2F;usr&#x2F;bin&#x2F;systemctl start, &#x2F;usr&#x2F;bin&#x2F;systemctl stop, &#x2F;usr&#x2F;bin&#x2F;systemctl reload, &#x2F;usr&#x2F;bin&#x2F;systemctl restart, &#x2F;usr&#x2F;bin&#x2F;systemctl status, &#x2F;usr&#x2F;bin&#x2F;systemctl enable, &#x2F;usr&#x2F;bin&#x2F;systemctl disable</span><br><span class="line"></span><br><span class="line">## Updating the locate database</span><br><span class="line"># Cmnd_Alias LOCATE &#x3D; &#x2F;usr&#x2F;bin&#x2F;updatedb</span><br><span class="line"></span><br><span class="line">## Storage</span><br><span class="line">Cmnd_Alias STORAGE &#x3D; &#x2F;sbin&#x2F;fdisk, &#x2F;sbin&#x2F;sfdisk, &#x2F;sbin&#x2F;parted, &#x2F;sbin&#x2F;partprobe, &#x2F;bin&#x2F;mount, &#x2F;bin&#x2F;umount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Processes</span><br><span class="line">Cmnd_Alias PROCESSES &#x3D; &#x2F;bin&#x2F;nice, &#x2F;bin&#x2F;kill, &#x2F;usr&#x2F;bin&#x2F;kill, &#x2F;usr&#x2F;bin&#x2F;killall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.将用户组与权限进行绑定   </span><br><span class="line">root    ALL&#x3D;(ALL)       NOPASSWD:ALL#可以执行所有的命令,并且无需输入密码</span><br><span class="line">DEV     ALL&#x3D;(ALL)       NETWORKING,SOFTWARE,SERVICES</span><br><span class="line">OPS     ALL&#x3D;(ALL)       NETWORKING,SOFTWARE,SERVICES,PROCESSES,STORAGE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.创建对应的用户,并设定密码</span><br><span class="line">[root@oldboy-pythonedu ~]# useradd kaifa1</span><br><span class="line">[root@oldboy-pythonedu ~]# useradd kaifa2</span><br><span class="line">[root@oldboy-pythonedu ~]# useradd ops1</span><br><span class="line">[root@oldboy-pythonedu ~]# useradd ops2</span><br><span class="line">[root@oldboy-pythonedu ~]# echo &quot;1&quot; | passwd --stdin kaifa1</span><br><span class="line">[root@oldboy-pythonedu ~]# echo &quot;1&quot; | passwd --stdin kaifa2</span><br><span class="line">[root@oldboy-pythonedu ~]# echo &quot;1&quot; | passwd --stdin ops1</span><br><span class="line">[root@oldboy-pythonedu ~]# echo &quot;1&quot; | passwd --stdin ops2</span><br><span class="line"></span><br><span class="line">5.使用 sudo -l 验证开发的权限和运维的权限是否不一致</span><br><span class="line">用户 kaifa1 可以在 oldboy-pythonedu 上运行以下命令：</span><br><span class="line">    (ALL) &#x2F;sbin&#x2F;route, &#x2F;sbin&#x2F;ifconfig, &#x2F;bin&#x2F;ping, &#x2F;sbin&#x2F;dhclient, &#x2F;usr&#x2F;bin&#x2F;net, &#x2F;sbin&#x2F;iptables,</span><br><span class="line">        &#x2F;usr&#x2F;bin&#x2F;rfcomm, &#x2F;usr&#x2F;bin&#x2F;wvdial, &#x2F;sbin&#x2F;iwconfig, &#x2F;sbin&#x2F;mii-tool, &#x2F;bin&#x2F;rpm,</span><br><span class="line">        &#x2F;usr&#x2F;bin&#x2F;up2date, &#x2F;usr&#x2F;bin&#x2F;yum, &#x2F;sbin&#x2F;service, &#x2F;sbin&#x2F;chkconfig, &#x2F;usr&#x2F;bin&#x2F;systemctl start,</span><br><span class="line">        &#x2F;usr&#x2F;bin&#x2F;systemctl stop, &#x2F;usr&#x2F;bin&#x2F;systemctl reload, &#x2F;usr&#x2F;bin&#x2F;systemctl restart,</span><br><span class="line">        &#x2F;usr&#x2F;bin&#x2F;systemctl status, &#x2F;usr&#x2F;bin&#x2F;systemctl enable, &#x2F;usr&#x2F;bin&#x2F;systemctl disable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用户 ops1 可以在 oldboy-pythonedu 上运行以下命令：</span><br><span class="line">    (ALL) &#x2F;sbin&#x2F;route, &#x2F;sbin&#x2F;ifconfig, &#x2F;bin&#x2F;ping, &#x2F;sbin&#x2F;dhclient, &#x2F;usr&#x2F;bin&#x2F;net, &#x2F;sbin&#x2F;iptables,</span><br><span class="line">        &#x2F;usr&#x2F;bin&#x2F;rfcomm, &#x2F;usr&#x2F;bin&#x2F;wvdial, &#x2F;sbin&#x2F;iwconfig, &#x2F;sbin&#x2F;mii-tool, &#x2F;bin&#x2F;rpm,</span><br><span class="line">        &#x2F;usr&#x2F;bin&#x2F;up2date, &#x2F;usr&#x2F;bin&#x2F;yum, &#x2F;sbin&#x2F;service, &#x2F;sbin&#x2F;chkconfig, &#x2F;usr&#x2F;bin&#x2F;systemctl start,</span><br><span class="line">        &#x2F;usr&#x2F;bin&#x2F;systemctl stop, &#x2F;usr&#x2F;bin&#x2F;systemctl reload, &#x2F;usr&#x2F;bin&#x2F;systemctl restart,</span><br><span class="line">        &#x2F;usr&#x2F;bin&#x2F;systemctl status, &#x2F;usr&#x2F;bin&#x2F;systemctl enable, &#x2F;usr&#x2F;bin&#x2F;systemctl disable,</span><br><span class="line">        &#x2F;bin&#x2F;nice, &#x2F;bin&#x2F;kill, &#x2F;usr&#x2F;bin&#x2F;kill, &#x2F;usr&#x2F;bin&#x2F;killall, &#x2F;sbin&#x2F;fdisk, &#x2F;sbin&#x2F;sfdisk,</span><br><span class="line">        &#x2F;sbin&#x2F;parted, &#x2F;sbin&#x2F;partprobe, &#x2F;bin&#x2F;mount, &#x2F;bin&#x2F;umount</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux文件管理,用户管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uwsgi+django</title>
      <link href="/2020/07/05/uwsgi+django/"/>
      <url>/2020/07/05/uwsgi+django/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-什么是wsgi"><a href="#1-什么是wsgi" class="headerlink" title="1.什么是wsgi"></a>1.什么是wsgi</h1><p>PythonWeb服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI)是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标。<br>WSGI 没有官方的实现, 因为WSGI更像一个协议. 只要遵照这些协议,WSGI应用(Application)都可以在任何服务器(Server)上运行, 反之亦然。<br>WSGI标准在 PEP 333 [1]  中定义并被许多框架实现，其中包括现广泛使用的django框架。</p><p><a href="https://img2018.cnblogs.com/blog/1477786/201905/1477786-20190517222328672-1438762618.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1477786/201905/1477786-20190517222328672-1438762618.png" class="lazyload"></a></p><h1 id="2-什么是uWSGI"><a href="#2-什么是uWSGI" class="headerlink" title="2.什么是uWSGI"></a>2.什么是uWSGI</h1><p>WSGI，全称 Web Server Gateway Interface，或者 Python Web Server Gateway Interface ，是为 Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口。自从 WSGI 被开发出来以后，许多其它语言中也出现了类似接口。</p><p>WSGI 的官方定义是，the Python Web Server Gateway Interface。从名字就可以看出来，这东西是一个Gateway，也就是网关。网关的作用就是在协议之间进行转换。</p><p>WSGI 是作为 Web 服务器与 Web 应用程序或应用框架之间的一种低级别的接口，以提升可移植 Web 应用开发的共同点。WSGI 是基于现存的 CGI 标准而设计的。</p><p>很多框架都自带了 WSGI server ，比如 Flask，webpy，Django、CherryPy等等。当然性能都不好，自带的 web server 更多的是测试用途，发布时则使用生产环境的 WSGI server或者是联合 nginx 做 uwsgi 。</p><p>桥梁作用</p><p><a href="https://img-blog.csdn.net/20160509174237093" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img-blog.csdn.net/20160509174237093" class="lazyload"></a></p><h1 id="使用uwsgi启动django项目"><a href="#使用uwsgi启动django项目" class="headerlink" title="使用uwsgi启动django项目"></a>使用uwsgi启动django项目</h1><p>步骤一、安装 python3 的环境</p><pre><code>yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel \sqlite-devel gcc gcc-c++  openssl-devel zlib zlib-devel python3 python3-devel -y</code></pre><p>步骤二、安装 Django 框架、uwsgi</p><pre><code>pip3 install -i https://mirrors.aliyun.com/pypi/simple/ --upgrade pippip3 install -i https://mirrors.aliyun.com/pypi/simple/ django==2.1.8pip3 install -i https://mirrors.aliyun.com/pypi/simple/ uwsgi</code></pre><p>步骤三、配置Django工程、</p><pre><code>[root@oldboy-pythonedu demosite]# cd /opt/[root@oldboy-pythonedu opt]# django-admin.py startproject demosite[root@oldboy-pythonedu opt]# cd demosite/[root@oldboy-pythonedu demosite]# python3 manage.py runserver 0.0.0.0:9999        # 启动测试</code></pre><p>步骤四、配置uWSGI、配置Nginx</p><pre><code>[root@oldboy-pythonedu opt]# cat /opt/demosite/uwsgi.ini [uwsgi]#uwsgi监听的端口socket = 127.0.0.1:9999#uwsgi启动进程数workers = 2#最大接收的请求数max-requests = 1000#buffer缓冲区大小buffer-size = 30000#进程pid存放路径pidfile = /run/uwsgi.pid#uwsgi日志存储路径daemonize = /var/log/uwsgi.log[root@oldboy-pythonedu demosite]# uwsgi --ini /opt/demosite/uwsgi.ini[root@oldboy-pythonedu demosite]# netstat -lntp | grep 9999tcp        0      0 127.0.0.1:9999          0.0.0.0:*               LISTEN      9827/uwsgi          </code></pre><p>  配置Nginx,将用户发送的http请求, 通过uwsgi_pass 传递给  Uwsgi 服务端</p><pre><code>[root@oldboy-pythonedu opt]# cat /etc/nginx/conf.d/uwsgi.oldboyedu.com.conf server {    listen 80;    server_name uwsgi.oldboyedu.com;    client_max_body_size 100M;    index index.html;           #默认返回页面    location / {        uwsgi_pass 127.0.0.1:9999;        uwsgi_param UWSGI_CHDIR /opt/demosite;  #工程所在的路径        uwsgi_param UWSGI_SCRIPT demosite.wsgi; #demosite/wsgi接口文件        include uwsgi_params;    }}</code></pre><hr><h1 id="nginx-uwsgi-django-pythonav"><a href="#nginx-uwsgi-django-pythonav" class="headerlink" title="nginx + uwsgi + django + pythonav"></a>nginx + uwsgi + django + pythonav</h1><hr><pre><code>wget http://cdn.xuliangwei.com/pythonav.zipunzip pythonav.zippip3 install -i https://pypi.doubanio.com/simple/ -r /code/pythonav/requirements.txt</code></pre><p> 登录202服务器创建一个pythonav的库:</p><pre><code>create database pythonav;vim pythonav/pythonav/settings.py</code></pre><p>配置MySql</p><pre><code>DATABASES = {    &apos;default&apos;: {        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,        &apos;NAME&apos;: &apos;pythonav&apos;,        &apos;USER&apos;: &apos;all&apos;,        &apos;PASSWORD&apos;: &apos;Oldxu.com123&apos;,        &apos;HOST&apos;: &apos;10.0.0.202&apos;,        &apos;PORT&apos;: &apos;3306&apos;,    }}</code></pre><p>初始化数据库</p><pre><code>cd /code/pythonavpython3 manage.py makemigrationspython3 manage.py migratepython3 manage.py createsuperuserpython3 manage.py collectstatic</code></pre><p>配置uwsgi</p><pre><code>vim pythonav_uwsgi.ini</code></pre><p>配置文件写入</p><pre><code>[uwsgi]#uwsgi监听的端口socket = 127.0.0.1:8811chdir = /code/pythonav/wsgi-file = pythonav/wsgi.py#uwsgi启动进程数processes = 4threads = 10#最大接收的请求数max-requests = 1000#buffer缓冲区大小buffer-size = 30000#进程pid存放路径pidfile = /run/uwsgi-pythonav.pid#uwsgi日志存储路径daemonize = /var/log/uwsgi-pythonav.log</code></pre><p>配置nginx</p><pre><code>[root@oldboy-pythonedu pythonav]# cat /etc/nginx/conf.d/pythonav.oldboyedu.com.conf server {    listen 80;    server_name pythonav.oldboyedu.com;    client_max_body_size 100M;    location /static {        alias /code/pythonav/static;    }    location / {        uwsgi_pass 127.0.0.1:8811;        include uwsgi_params;    }}</code></pre><hr><p>部署Blog项目</p><p>1.安装模块<br>2.配置数据库连接<br>3.初始化数据库<br>4.配置uwsgi<br>5.配置nginx</p><p>tar xf blog.tar.gz  -C /code/</p><p>ls /code/</p><p>cd /code/blog_sever/</p><p>pip3 install -i <a href="https://pypi.doubanio.com/simple/" target="_blank" rel="noopener">https://pypi.doubanio.com/simple/</a> -r packages.txt </p><p>vim blog_progect/settings/develop.py             #创建数据库要指定utf8</p><pre><code>DATABASES = {    &apos;default&apos;: {        &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,        &apos;NAME&apos;: &apos;blog&apos;,        &apos;USER&apos;: &apos;all&apos;,        &apos;PASSWORD&apos;: &apos;Oldxu.com123&apos;,        &apos;HOST&apos;: &apos;10.0.0.202&apos;,        &apos;PORT&apos;: &apos;3306&apos;,        &apos;OPTIONS&apos;: {            &quot;init_command&quot;: &quot;SET sql_mode=&apos;STRICT_TRANS_TABLES&apos;&quot;        }    }}</code></pre><p>vim /usr/local/lib/python3.6/site-packages/django/db/backends/mysql/operations.py +146<br>    # 修改为 encode</p><pre><code>python3 manage.py migratepython3 manage.py createsuperuserpython3 manage.py collectstatic</code></pre><p>配置uwsgi</p><p>cat /code/blog_sever/blog_uwsgi.ini </p><pre><code>[uwsgi]#uwsgi监听的端口socket = 127.0.0.1:8989chdir = /code/blog_severwsgi-file = blog_progect/wsgi.py#uwsgi启动进程数processes = 4threads = 10#最大接收的请求数max-requests = 1000#buffer缓冲区大小buffer-size = 30000#进程pid存放路径pidfile = /run/uwsgi-blog.pid#uwsgi日志存储路径daemonize = /var/log/uwsgi-blog.log</code></pre><p>重启uwsgi</p><p>uwsgi –ini /code/blog_sever/blog_uwsgi.ini </p><p>netstat -lntp #查看是否启动成功</p><p>配置NGINX<br>cat /etc/nginx/conf.d/pyblog.oldboyedu.com.conf </p><pre><code>server {    listen 80;    server_name pyblog.oldboyedu.com;    client_max_body_size 100M;    location /static {        alias /code/blog_sever/static;    }    location / {        uwsgi_pass 127.0.0.1:8989;        include uwsgi_params;    }}</code></pre><p>nginx -t</p><p>systemctl reload nginx</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uwsgi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/2020/06/26/Nginx/"/>
      <url>/2020/06/26/Nginx/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx"></a>什么是Nginx</h1><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。<br>其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。<br>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><h1 id="Nginx应用场景"><a href="#Nginx应用场景" class="headerlink" title="Nginx应用场景"></a>Nginx应用场景</h1><p><strong>1、反向代理</strong></p><p>反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理(Reverse Proxy)方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。</p><p><a href="https://img2018.cnblogs.com/blog/1158536/201911/1158536-20191127160755228-988235408.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1158536/201911/1158536-20191127160755228-988235408.png" class="lazyload"></a></p><p>配置</p><pre><code>server { 　　 listen 80;     server_name localhost; location / {    proxy_pass http://localhost:8080;    proxy_set_header Host $host:$server_port;    }}</code></pre><p><strong>2、负载均衡</strong></p><p>负载均衡是扩展应用程序并提高其性能和冗余的绝佳方法。Nginx是一种流行的Web服务器软件，可以配置为简单但功能强大的负载均衡器，以提高服务器资源的可用性和效率。在负载 均衡配置中，nginx充当在多个单独服务器上工作的分布式Web应用程序的单个入口点。</p><p><a href="https://www.nginx.cn/wp-content/uploads/2020/03/load-balancer-graph-1-1024x522-1.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.nginx.cn/wp-content/uploads/2020/03/load-balancer-graph-1-1024x522-1.png" class="lazyload"></a></p><p>1、 轮询</p><p> 轮询方式是Nginx负载默认的方式，顾名思义，所有请求都按照时间顺序分配到不同的服务上，如果服务Down掉，可以自动剔除，如下配置后轮训10001服务和10002服务。</p><pre><code>upstream  dalaoyang-server {       server    localhost:10001;       server    localhost:10002;}</code></pre><p>2、权重</p><p>指定每个服务的权重比例，weight和访问比率成正比，通常用于后端服务机器性能不统一，将性能好的分配权重高来发挥服务器最大性能，如下配置后10002服务的访问比率会是10001服务的二倍。</p><pre><code>upstream  dalaoyang-server {       server    localhost:10001 weight=1;       server    localhost:10002 weight=2;}</code></pre><p>3、 iphash</p><p>每个请求都根据访问ip的hash结果分配，经过这样的处理，每个访客固定访问一个后端服务，如下配置（ip_hash可以和weight配合使用）。</p><pre><code>upstream  dalaoyang-server {       ip_hash;        server    localhost:10001 weight=1;       server    localhost:10002 weight=2;}</code></pre><p>4、最少连接</p><p>将请求分配到连接数最少的服务上。</p><pre><code>upstream  dalaoyang-server {       least_conn;       server    localhost:10001 weight=1;       server    localhost:10002 weight=2;}</code></pre><p>Nginx配置（轮询为例）</p><pre><code>worker_processes  1;events {    worker_connections  1024;}http {   upstream  dalaoyang-server {       server    localhost:10001;       server    localhost:10002;   }   server {       listen       10000;       server_name  localhost;       location / {        proxy_pass http://dalaoyang-server;        proxy_redirect default;      }    }}</code></pre><p><strong>3、WEB服务器</strong></p><p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现</p><pre><code>server {        listen       80;                                                                server_name  localhost;                                                      location / {               root   e:/www/data;               index  index.html;           }    }</code></pre><p><strong>4、正向代理  不支持HTTPS</strong></p><p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS</p><p><a href="https://img2018.cnblogs.com/blog/1158536/201911/1158536-20191127165442475-1151656886.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1158536/201911/1158536-20191127165442475-1151656886.png" class="lazyload"></a></p><p><strong>5、动静态分离</strong></p><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p><pre><code>server {　　listen 80;　　server_name 192.168.25.35; #  当接收到http请求时，首先host和这里的server_name进行匹配，如果匹配上，则走这个虚拟主机的location路由　　location /static/~(.*)(\.jpg|\.png|\.gif|\.jepg|\.css|\.js|\.css){  #  静态资源则路由到这里　　　　alias html;　　}　　location / {  #  其他的url则转发到 http://192.168.25.35:8080　　　　proxy_pass http://192.168.25.35:8080;　　}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> web服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL安装</title>
      <link href="/2020/06/22/MySQL%E5%AE%89%E8%A3%85/"/>
      <url>/2020/06/22/MySQL%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、MYSQL的安装"><a href="#一、MYSQL的安装" class="headerlink" title="一、MYSQL的安装"></a>一、MYSQL的安装</h1><p>首先登入官网下载mysql的安装包，官网地址：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019152505680-503282651.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019152505680-503282651.png" class="lazyload"></a></p><p>一般下载这个就好，现在的最新版本是5.8，但是据说已经收费了，5.7以前的版本不收费，可以下载5.7以前的版本，这里面以我现在使用的mysql-5.5.49为例。</p><p>但是这里面存在一个问题：我说的下面的步骤是对于安装板的安装方式，上面这个是解压版的压缩包，可能会存在一些问题。(十分感谢5楼给我的留言，找到了错误)</p><p>安装版本的网址： <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></p><p>下载这两个即可：</p><p><a href="https://img2018.cnblogs.com/i-beta/1419534/202001/1419534-20200108182007663-456122441.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/i-beta/1419534/202001/1419534-20200108182007663-456122441.png" class="lazyload"></a></p><p>１、打开下载的mysql安装文件mysql-5.5.27-win32.zip，双击解压缩，运行“setup.exe”。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019152728102-738978444.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019152728102-738978444.png" class="lazyload"></a></p><p>２、选择安装类型，有“Typical（默认）”、“Complete（完全）”、“Custom（用户自定义）”三个选项，选择“Custom”，按“next”键继续。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019152813724-237006237.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019152813724-237006237.png" class="lazyload"></a></p><p>３、点选“Browse”，手动指定安装目录。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019152838728-825507385.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019152838728-825507385.png" class="lazyload"></a></p><p>４、填上安装目录，我的是“F:\Server\MySQL\MySQL Server 5.0”，也建议不要放在与操作系统同一分区，这样可以防止系统备份还原的时候，数据被清空。按“OK”继续。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019152854550-693179136.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019152854550-693179136.png" class="lazyload"></a></p><p> 在确认完这个路径之后，继续点击Server data files，也需要修改这个路径，这个文件保存的是在mysql里面编写的数据库代码</p><p>确认一下先前的设置，如果有误，按“Back”返回重做。按“Install”开始安装。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153042566-680033406.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153042566-680033406.png" class="lazyload"></a></p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153053526-561170312.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153053526-561170312.png" class="lazyload"></a></p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153059866-743042211.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153059866-743042211.png" class="lazyload"></a></p><p>５、正在安装中，请稍候，直到出现下面的界面, 则完成MYSQL的安装</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153114862-341001343.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153114862-341001343.png" class="lazyload"></a></p><h1 id="二、MYSQL的配置"><a href="#二、MYSQL的配置" class="headerlink" title="二、MYSQL的配置"></a>二、MYSQL的配置</h1><p>１、安装完成了，出现如下界面将进入mysql配置向导。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153203704-927523552.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153203704-927523552.png" class="lazyload"></a></p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153208621-592736990.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153208621-592736990.png" class="lazyload"></a></p><p>２、选择配置方式，“Detailed Configuration（手动精确配置）”、“Standard Configuration（标准配置）”，我们选择“Detailed Configuration”，方便熟悉配置过程。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153222800-1171436475.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153222800-1171436475.png" class="lazyload"></a></p><p>３、选择服务器类型，“Developer Machine（开发测试类，mysql占用很少资源）”、“Server Machine（服务器类型，mysql占用较多资源）”、“Dedicated MySQL Server Machine（专门的数据库服务器，mysql占用所有可用资源）” </p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153237847-1876080548.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153237847-1876080548.png" class="lazyload"></a></p><p>４、选择mysql数据库的大致用途，“Multifunctional Database（通用多功能型，好）”、“Transactional Database Only（服务器类型，专注于事务处理，一般）”、“Non-Transactional Database Only（非事务处理型，较简单，主要做一些监控、记数用，对MyISAM数据类型的支持仅限于non-transactional），按“Next”继续。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153250457-2142538102.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153250457-2142538102.png" class="lazyload"></a></p><p>５、选择网站并发连接数，同时连接的数目，“Decision Support(DSS)/OLAP（20个左右）”、“Online Transaction Processing(OLTP)（500个左右）”、“Manual Setting（手动设置，自己输一个数）”。 </p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153302865-1049904564.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153302865-1049904564.png" class="lazyload"></a></p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153306464-597119127.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153306464-597119127.png" class="lazyload"></a></p><p>６、是否启用TCP/IP连接，设定端口，如果不启用，就只能在自己的机器上访问mysql数据库了，在这个页面上，您还可以选择“启用标准模式”（Enable Strict Mode），这样MySQL就不会允许细小的语法错误。如果是新手，建议您取消标准模式以减少麻烦。但熟悉MySQL以后，尽量使用标准模式，因为它可以降低有害数据进入数据库的可能性。按“Next”继续 。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153320998-1557625021.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153320998-1557625021.png" class="lazyload"></a></p><p>７、就是对mysql默认数据库语言编码进行设置（重要），一般选UTF-8，按 “Next”继续。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153332940-421891328.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153332940-421891328.png" class="lazyload"></a></p><p>８、选择是否将mysql安装为windows服务，还可以指定Service Name（服务标识名称），是否将mysql的bin目录加入到Windows PATH（加入后，就可以直接使用bin下的文件，而不用指出目录名，比如连接，“mysql.exe -uusername -ppassword;”就可以了，不用指出mysql.exe的完整地址，很方便），我这里全部打上了勾，Service Name不变。按“Next”继续。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153343734-1925401088.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153343734-1925401088.png" class="lazyload"></a></p><p>９、询问是否要修改默认root用户（超级管理）的密码。“Enable root access from remote machines（是否允许root用户在其它的机器上登陆，如果要安全，就不要勾上，如果要方便，就勾上它）”。最后“Create An Anonymous Account（新建一个匿名用户，匿名用户可以连接数据库，不能操作数据，包括查询）”，一般就不用勾了，设置完毕，按“Next”继续。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153354929-1264932943.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153354929-1264932943.png" class="lazyload"></a></p><p>10、确认设置无误，按“Execute”使设置生效，即完成MYSQL的安装和配置.</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153411103-410226874.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153411103-410226874.png" class="lazyload"></a></p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153415129-261117728.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153415129-261117728.png" class="lazyload"></a></p><p>注意：设置完毕，按“Finish”后有一个比较常见的错误，就是不能“Start service”，一般出现在以前有安装mysql的服务器上，解决的办法，先保证以前安装的mysql服务器彻底卸载掉了；不行的话，检查是否按上面一步所说，之前的密码是否有修改，照上面的操作；如果依然不行，将mysql安装目录下的data文件夹备份，然后删除，在安装完成后，将安装生成的 data文件夹删除，备份的data文件夹移回来，再重启mysql服务就可以了，这种情况下，可能需要将数据库检查一下，然后修复一次，防止数据出错。</p><p><a href="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153431013-806476698.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://img2018.cnblogs.com/blog/1419534/201910/1419534-20191019153431013-806476698.png" class="lazyload"></a></p><p>解决方法：</p><p>1, 卸载MySQL</p><p>2, Windows Xp系统删除目录 C:\Documents and Settings\All Users\Application Data\</p><p>windows 7\8\10操作系统删除目录C:\ProgramData\MySQL</p><p>3、重新安装就可以了</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>celery</title>
      <link href="/2020/05/26/CELERY/"/>
      <url>/2020/05/26/CELERY/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>celery 简介</strong></p><p>Celery 是一个专注于实时处理和任务调度的分布式任务队列, 同时提供操作和维护分布式系统所需的工具.. 所谓任务就是消息, 消息中的有效载荷中包含要执行任务需要的全部数据.</p><p>Celery 是一个分布式队列的管理工具, 可以用 Celery 提供的接口快速实现并管理一个分布式的任务队列.</p><p>Celery 本身不是任务队列, 是管理分布式任务队列的工具. 它封装了操作常见任务队列的各种操作, 我们使用它可以快速进行任务队列的使用与管理.</p><p><a href="https://i.loli.net/2020/05/26/J6fWiczPsVtAOlZ.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://i.loli.net/2020/05/26/J6fWiczPsVtAOlZ.jpg" class="lazyload"></a> </p><p><strong>Celery 特性 :</strong></p><p>方便查看定时任务的执行情况, 如 是否成功, 当前状态, 执行任务花费的时间等.</p><p>使用功能齐备的管理后台或命令行添加,更新,删除任务.<br>方便把任务和配置管理相关联.</p><p>可选 多进程, Eventlet 和 Gevent 三种模型并发执行.<br>提供错误处理机制.</p><p>提供多种任务原语, 方便实现任务分组,拆分,和调用链.<br>支持多种消息代理和存储后端.</p><p>Celery 是语言无关的.它提供了python 等常见语言的接口支持.</p><p><strong>使用场景</strong></p><p>异步任务：将耗时操作任务提交给Celery去异步执行，比如发送短信/邮件、消息推送、音视频处理等等</p><p>定时任务：定时执行某件事情，比如每天数据统计</p><p><strong>Django中使用Celery</strong></p><p>1、 在项目目录下创建celeryconfig.py</p><pre><code>import djcelery djcelery.setup_loader() CELERY_IMPORTS=(     &apos;app01.tasks&apos;, ) #有些情况可以防止死锁 CELERYD_FORCE_EXECV=True # 设置并发worker数量 CELERYD_CONCURRENCY=4 #允许重试 CELERY_ACKS_LATE=True # 每个worker最多执行100个任务被销毁，可以防止内存泄漏 CELERYD_MAX_TASKS_PER_CHILD=100 # 超时时间   CELERYD_TASK_TIME_LIMIT=12*30</code></pre><p>2、 在app01目录下创建tasks.py</p><pre><code>from celery import task@taskdef add(a,b):    with open(&apos;a.text&apos;, &apos;a&apos;, encoding=&apos;utf-8&apos;) as f:        f.write(&apos;a&apos;)    print(a+b)</code></pre><p>3、 视图函数views.py</p><pre><code>from django.shortcuts import render,HttpResponsefrom app01.tasks import addfrom datetime import datetimedef test(request):    # result=add.delay(2,3)    ctime = datetime.now()    # 默认用utc时间    utc_ctime = datetime.utcfromtimestamp(ctime.timestamp())    from datetime import timedelta    time_delay = timedelta(seconds=5)    task_time = utc_ctime + time_delay    result = add.apply_async(args=[4, 3], eta=task_time)    print(result.id)    return HttpResponse(&apos;ok&apos;)</code></pre><p>4、 settings.py</p><pre><code>#INSTALLED_APPS = [#    &apos;djcelery&apos;,#    &apos;app01&apos;#]from djagocele import celeryconfigBROKER_BACKEND=&apos;redis&apos;BOOKER_URL=&apos;redis://127.0.0.1:6379/1&apos;CELERY_RESULT_BACKEND=&apos;redis://127.0.0.1:6379/2&apos;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件简介</title>
      <link href="/2020/05/26/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/05/26/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPU和SKU</title>
      <link href="/2020/05/22/SPU%20%20SKU/"/>
      <url>/2020/05/22/SPU%20%20SKU/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>SPU和SKU介绍及区别</strong></p><p><strong>一、spu概念</strong></p><blockquote><p>SPU = Standard Product Unit (标准化产品单元)</p></blockquote><p>SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU。</p><p><strong>二、sku概念</strong></p><blockquote><p>SKU=stock keeping unit(库存量单位)</p></blockquote><p>SKU即库存进出计量的单位， 可以是以件、盒、托盘等为单位。<br>SKU是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。在服装、鞋类商品中使用最多最普遍。</p><p><strong>三、区别</strong></p><p>1、 在商品信息电子化过程中，商品的特性可以由多个“属性|属性值对”进行描述。“属性|属性值对”完全相同的商品，可以抽象成为一个SPU。</p><p>另一方面，这些“属性|属性值对”在SPU中固化下来，逐步标准化。</p><p>基于SPU的商品信息结构，可以实现丰富的应用，比如商品信息与资讯、评论、以及其它SPU的整合。</p><p>例如：iPhone X 可以确定一个产品即为一个SPU。</p><hr><p>1、 SKU是指一款商品，每款都有出现一个SKU，便于电商品牌识别商品。</p><p>2、 一款商品多色，则是有多个SKU，例：一件衣服，有红色、白色、蓝色，则SKU编码也不相同，如相同则会出现混淆，发错货。</p><p>例如：iPhone X 64G 银色 则是一个SKU。</p><p>spu是宝贝的编码，sku是宝贝的款式</p><p><a href="https://i.loli.net/2020/05/22/gtfqjrAnJaBdb4k.png" data-fancybox="group" data-caption="3.png" class="fancybox"><img alt="3.png" title="3.png" data-src="https://i.loli.net/2020/05/22/gtfqjrAnJaBdb4k.png" class="lazyload"></a></p><p><a href="https://i.loli.net/2020/05/22/z2uBKg1k9OVMHbm.jpg" data-fancybox="group" data-caption="4.jpg" class="fancybox"><img alt="4.jpg" title="4.jpg" data-src="https://i.loli.net/2020/05/22/z2uBKg1k9OVMHbm.jpg" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> 电商 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPU和SKU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象设计原则</title>
      <link href="/2020/05/20/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2020/05/20/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>一、 开闭原则(Open Close Principle)</strong></p><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><ul><li>对扩展开放,对更改封闭。</li><li>类模块应该是可扩展的,但是不可修改。</li></ul><p><strong>二、 里氏代换原则(Liskov Substitution Principle)</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><ul><li>子类必须能够替换它们的基类(IS-A)</li><li>继承表达类型能抽象。</li></ul><p><strong>三、 依赖倒转原则(Dependence Inversion Principle)</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><ul><li>高层模块(稳定)不应该依赖于低层模块(变化),二者都应该依赖于抽象(稳定)。</li><li>抽象(稳定)不应该依赖于实现细节(变化),实现细节应该依赖于抽象(稳定)。</li></ul><p><strong>四、 接口隔离原则(Interface Segregation Principle)</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><ul><li>不应该强迫客户程序依赖它们不用的方法。</li><li>接口应该小而完备。</li></ul><p><strong>五、 优先使用对象组合,而不是类继承</strong></p><ul><li>继承类通常为”白箱复用”,对象类组合通常为”黑箱复用”。</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高。</li><li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li></ul><p><strong>六、 单一职责原则(Single responsibility principle)</strong></p><p>单一职责原则是指：一个类应该只有一个发生变化的原因，即一个类只负责一项职责。<br>如果一个类有多个职责，这些职责就耦合在了一起。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起会影响复用性。<br>此原则的核心是解耦和增强内聚性。</p><ul><li>一个类应该只有一个引起它变化的原因。</li><li>变化的方向隐含着类的职责。</li></ul><p><strong>七、 封装变化点</strong></p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层的<br>一侧进行修改，而不会对另一侧产生不良的影响，从而实现层<br>次间的松耦合</li></ul><p><strong>八、 针对接口编程，而不是针对实现编程</strong></p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的<br>接口。</li><li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”<br>的类型设计方案。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手和四次挥手</title>
      <link href="/2020/05/15/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2020/05/15/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>TCP报文段首部格式</strong></p><p><a href="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1456106723,727720266&fm=26&gp=0.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1456106723,727720266&fm=26&gp=0.jpg" class="lazyload"></a></p><p> 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p><pre><code>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</code></pre><table><thead><tr><th>字段</th><th align="center">含义</th></tr></thead><tbody><tr><td>URG</td><td align="center">紧急指针是否有效。为1，表示某一位需要被优先处理</td></tr><tr><td>ACK</td><td align="center">确认号是否有效，一般置为1。</td></tr><tr><td>PSH</td><td align="center">提示接收端应用程序立即从TCP缓冲区把数据读走。</td></tr><tr><td>RST</td><td align="center">对方要求重新建立连接，复位。</td></tr><tr><td>SYN</td><td align="center">请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1</td></tr><tr><td>FIN</td><td align="center">希望断开连接。</td></tr></tbody></table><p><strong>三次握手过程</strong></p><p><a href="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=442724225,526434029&fm=26&gp=0.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=442724225,526434029&fm=26&gp=0.jpg" class="lazyload"></a></p><p>ROUND1:    客户端发送连接请求报文段,无应用层数据。</p><pre><code>SYN=1,seq=x(随机)</code></pre><p>ROUND2:    服务器端为该tcp连接分配缓存和变量,并向客户端返回确认报文段,允许连接,无应用层数据。</p><pre><code>SYN=1, ACK=1, seq=y(随机), ack=x+1</code></pre><p>ROUND3:    客户端为该tcp连接分配缓存和变量,并向服务器端返回确认,可携带数据。</p><pre><code>SYN=0, ACK=1, seq=x+1, ack=y+1</code></pre><p><strong>四次挥手过程过程</strong></p><p><a href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1589636258396&di=7b0fd9842af20c5b85ca4276ebba6c18&imgtype=0&src=http%3A%2F%2Fwww.pc-fly.com%2Fuploads%2Fallimg%2F20170516%2F1494943585801_2.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1589636258396&di=7b0fd9842af20c5b85ca4276ebba6c18&imgtype=0&src=http%3A%2F%2Fwww.pc-fly.com%2Fuploads%2Fallimg%2F20170516%2F1494943585801_2.jpg" class="lazyload"></a></p><p>ROUND1:    客户端发送连接释放报文段,停止发送数据,主动关闭tcp连接。</p><pre><code>FIN=1,seq=u</code></pre><p>ROUND2:    服务器端回送一个确认报文段,客户到服务器这个方向的连接就释放了————半关闭状态。</p><pre><code>ACK=1, seq=v, ack=u+1</code></pre><p>ROUND3:    服务器端发完数据,就发出连接释放报文段,主动关闭tcp连接</p><pre><code>FIN=1,ACK=1, seq=w, ack=u+1</code></pre><p>ROUND4:    客户端回送一个确认报文段,再等到时间等待计时器设置的2msl(最长报文段寿命)后连续彻底关闭。</p><pre><code>ACK=1, seq=u+1, ack=w+1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统重装</title>
      <link href="/2020/05/09/windows%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/"/>
      <url>/2020/05/09/windows%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍如何优雅的重新安装笔记本电脑系统</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1、 确定电脑配置</p><p>确定自己的电脑是什么配置，适合重装什么系统。</p><p>2、 备份重要文件</p><p>重装电脑，文件备份是一定要提前着手的，特别是C盘里的东西，如果 是重要的文件，建议先备份放到U盘或者是百度云。</p><p>3、 装备一个重装软件/U盘PE重装软件。</p><p>不管你是用一键重装系统软件还是用U盘来进行重装，可以用一些比较好的工具，不懂的话可以看看安装教程。</p><p>小白一键重装系统软件：<a href="http://www.xiaobaixitong.com/" target="_blank" rel="noopener">http://www.xiaobaixitong.com/</a></p><p>U盘重装系统软件：<a href="http://www.zhuangjiba.com/" target="_blank" rel="noopener">http://www.zhuangjiba.com/</a></p><p>大白菜: <a href="http://www.winbaicai.com/" target="_blank" rel="noopener">http://www.winbaicai.com/</a></p><p>老毛桃: <a href="https://www.laomaotao.net/" target="_blank" rel="noopener">https://www.laomaotao.net/</a></p><h2 id="系统盘制作"><a href="#系统盘制作" class="headerlink" title="系统盘制作"></a>系统盘制作</h2><p>1、 提前下载好小白一键重装系统，之后将U盘插入此电脑，备份U盘重要数据。</p><p>2、 打开小白系统，进入功能界面点击制作系统选项，检测到U盘后就点击开始制作按钮。</p><p><a href="https://pic.rmb.bdstatic.com/0001bbdc9c06bb4b29f6c9523ce5937c8762.gif" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://pic.rmb.bdstatic.com/0001bbdc9c06bb4b29f6c9523ce5937c8762.gif" class="lazyload"></a></p><p>3、 出现如图界面，直接点击右下角的开始制作。如果想要制作pe系统盘安装系统，可以选择自己喜欢的系统哦。</p><p><a href="https://pic.rmb.bdstatic.com/a248d662bfcba19b36d0064000560cb84346.gif" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://pic.rmb.bdstatic.com/a248d662bfcba19b36d0064000560cb84346.gif" class="lazyload"></a></p><p>4、 弹出备份U盘数据提示，备份好了就点击确定。</p><p><a href="https://pic.rmb.bdstatic.com/0fd49230f1234646ee69ef587e8d442b9394.gif" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://pic.rmb.bdstatic.com/0fd49230f1234646ee69ef587e8d442b9394.gif" class="lazyload"></a></p><p>5、 等待pe系统盘制作完成后，拔出U盘即可。</p><p><a href="https://pic.rmb.bdstatic.com/a5cdc337221c6cb8d1ed90659dd6454b7861.gif" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://pic.rmb.bdstatic.com/a5cdc337221c6cb8d1ed90659dd6454b7861.gif" class="lazyload"></a></p><h3 id="Bios设置"><a href="#Bios设置" class="headerlink" title="Bios设置"></a>Bios设置</h3><p>由于电脑品牌不同，使用的主板也不相同，所以进入bios的方法也不一样</p><p><a href="https://pic1.zhimg.com/80/v2-2943dbea0ffd545b0871b3163d328770_720w.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://pic1.zhimg.com/80/v2-2943dbea0ffd545b0871b3163d328770_720w.jpg" class="lazyload"></a></p><p><a href="https://pic1.zhimg.com/80/v2-ccb657ff8bb5f58af8f42876e5fd4428_720w.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://pic1.zhimg.com/80/v2-ccb657ff8bb5f58af8f42876e5fd4428_720w.jpg" class="lazyload"></a></p><p><a href="https://pic1.zhimg.com/80/v2-765ef3b5a364937aa1001e1f0b4e7348_720w.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://pic1.zhimg.com/80/v2-765ef3b5a364937aa1001e1f0b4e7348_720w.jpg" class="lazyload"></a></p><p><strong>联想电脑为例:</strong></p><p>插入制作好的U盘启动盘，启动电脑，出现开机画面时按下F12进入bios设置界面。</p><p>具体步骤如下：</p><p>1、 进入bios界面后，将光标移动到“boot”，点可移动设备（removeble device）。</p><p><a href="https://iknow-pic.cdn.bcebos.com/00e93901213fb80e72053c643bd12f2eb83894a8?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://iknow-pic.cdn.bcebos.com/00e93901213fb80e72053c643bd12f2eb83894a8?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" class="lazyload"></a></p><p>2、 按“+键”将“removeble device”移动至最上面，设置u盘优先启动。</p><p><a href="https://iknow-pic.cdn.bcebos.com/72f082025aafa40f3006926ea664034f79f01944?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://iknow-pic.cdn.bcebos.com/72f082025aafa40f3006926ea664034f79f01944?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" class="lazyload"></a></p><p>3、设置完成后，按下F10，点“yes”确定，然后重启电脑就是从u盘启动了。</p><p><a href="https://iknow-pic.cdn.bcebos.com/35a85edf8db1cb13618a63a0d054564e93584ba5?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://iknow-pic.cdn.bcebos.com/35a85edf8db1cb13618a63a0d054564e93584ba5?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" class="lazyload"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>第一步：将GHOST WIN10系统(ISO或GHO)镜像复制到U盘</p><p>打开启动U盘，进入“GHO”文件夹。将下载好的WIN8 ISO/GHO镜像拷贝到此目录。由于ISO/GHO文件通常都比较大，可能需要等待5~10分钟。</p><p><a href="https://www.upandashi.com/uploads/allimg/150915/5-1509151H546417.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/uploads/allimg/150915/5-1509151H546417.jpg" class="lazyload"></a></p><p>第二步：重启电脑，通过快捷键启动U盘进入U盘装机大师</p><p>当电脑启动以后反复的按快捷键一般是F12，机型不一样快捷键有可能不一样，具体请看下面启动按键列表，之后窗口里面会有几个选择，我们要找到并按上下方向键”↑↓”选择到u盘，然后按回车键进入U盘装机大师主界面。（一般我们选择的时候可以看下其中一个选项是有关USB或者您u盘的品牌的英文名称，那便是我们的u盘了！）小编整理了各种品牌主板一键进入U盘装机大师的快捷键，我们可以在下面的列表中查找自己相应的主板品牌，然后就可以看到该主板的一键启动u盘装机大师的热键了。</p><p><a href="https://www.upandashi.com/uploads/allimg/141115/12561Q531-0.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/uploads/allimg/141115/12561Q531-0.jpg" class="lazyload"></a></p><p>第三步：进入PE系统执行“U盘大师一键装机”安装WIN10</p><p>进入U盘装机大师启动菜单后，通过上下键选择“[01]运行U盘大师Win10PE(X64)UEFI版(首选)”，选中后，按“回车键”进入PE系统。</p><p><a href="https://www.upandashi.com/uploads/allimg/190305/1-1Z305202444200.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/uploads/allimg/190305/1-1Z305202444200.png" class="lazyload"></a></p><p>1、 PE启动后，自动加载U盘装机大师界面，等待几秒后，进入PE系统桌面。</p><p><a href="https://www.upandashi.com/uploads/allimg/190305/1-1Z305205F0242.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/uploads/allimg/190305/1-1Z305205F0242.png" class="lazyload"></a></p><p>2、 一键装系统<br>　　进入PE桌面后，用鼠标双击“U盘大师一键装机”图标，将打开“U盘大师一键装机”软件。</p><p><a href="https://www.upandashi.com/images/updspic/ghost-1.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/images/updspic/ghost-1.png" class="lazyload"></a></p><p>3、 进入“U盘大师一键装机”后，通过“打开”按钮选择我们拷贝进U盘启动盘的ISO文件。</p><p><a href="https://www.upandashi.com/images/updspic/ghost-2.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/images/updspic/ghost-2.png" class="lazyload"></a></p><p>4、 在弹出窗口中，首先通过下拉列表选择U盘启动盘的GHO目录；然后选择刚才拷贝进去的Windows10系统镜像；确认文件名无误后，点击“打开”按钮。</p><p><a href="https://www.upandashi.com/images/updspic/ghost-3.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/images/updspic/ghost-3.png" class="lazyload"></a></p><p>5、 格式如果为GHO的请略过此步骤，在弹出的窗口界面中，鼠标单击选中WIN10.GHO文件。选中后，点击“确定”按钮。</p><p><a href="https://www.upandashi.com/images/updspic/ghost-4.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/images/updspic/ghost-4.png" class="lazyload"></a></p><p>6、 选择要恢复的分区，一般默认是C:盘，然后点击”确定”。</p><p><a href="https://www.upandashi.com/images/updspic/ghost-5.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/images/updspic/ghost-5.png" class="lazyload"></a></p><p>7、 开始恢复系统之前，软件会再次弹窗确认是否要继续操作，在确认无误后，点击“是”按钮。</p><p><a href="https://www.upandashi.com/images/updspic/ghost-6.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/images/updspic/ghost-6.png" class="lazyload"></a></p><p>8、 此时，会自动弹出Ghost系统还原界面。我们耐心等待Ghost还原自动安装WIN10系统。</p><p><a href="https://www.upandashi.com/images/updspic/ghost-7.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/images/updspic/ghost-7.png" class="lazyload"></a></p><p><a href="https://www.upandashi.com/uploads/allimg/150915/5-1509151J04A96.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.upandashi.com/uploads/allimg/150915/5-1509151J04A96.jpg" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL简介</title>
      <link href="/2020/04/21/NoSQL/"/>
      <url>/2020/04/21/NoSQL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介:"></a>NoSQL简介:</h2><p>NoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”。<br>在现代的计算系统上每天网络上都会产生庞大的数据量。<br>这些数据有很大一部分是由关系数据库管理系统（RDBMS）来处理。 1970年 E.F.Codd’s提出的关系模型的论文 “A relational model of data for large shared data banks”，这使得数据建模和应用程序编程更加简单。<br>通过应用实践证明，关系模型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。</p><p>NoSQL 是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。</p><p><a href="https://i.loli.net/2020/04/21/GMqtoznSYsg6xOB.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://i.loli.net/2020/04/21/GMqtoznSYsg6xOB.jpg" class="lazyload"></a></p><p><strong>分类</strong></p><p>1、 键值(Key-Value)存储数据库</p><p>这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。举例如：Tokyo Cabinet/Tyrant， Redis， Voldemort， Oracle BDB。</p><p>2、 列存储数据库</p><p>这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。如：Cassandra， HBase， Riak。</p><p>3、 文档型数据库</p><p>文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值，在处理网页等复杂数据时，文档型数据库比传统键值数据库的查询效率更高。如：CouchDB， MongoDb. 国内也有文档型数据库SequoiaDB，已经开源。</p><p>4、 图形(Graph)数据库</p><p>图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。如：Neo4J， InfoGrid， Infinite Graph。</p><p><a href="https://p1.ssl.qhimg.com/t01ef34acd1bb786278.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://p1.ssl.qhimg.com/t01ef34acd1bb786278.png" class="lazyload"></a></p><p><strong>不同分类特点对比</strong></p><p><a href="https://i.loli.net/2020/04/21/n75jGJq9Ubd6fDI.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://i.loli.net/2020/04/21/n75jGJq9Ubd6fDI.png" class="lazyload"></a></p><p><strong>NoSQL的一些功能特性：</strong></p><ul><li>使用NoSQL可以存储大量的结构化，半结构化和非结构化数据。</li><li>它支持敏捷的sprint，快速迭代和频繁的代码推送。</li><li>它使用频繁且易于使用的面向对象编程。</li><li>效率更高。 它具有横向扩展体系结构。它使用成本便宜，并具有整体架构。</li></ul><p><strong>适用场景</strong></p><p>1、 数据模型比较简单； </p><p>2、 需要灵活性更强的IT系统；</p><p>3、 对数据库性能要求较高； </p><p>4、 不需要高度的数据一致性； </p><p>5、 对于给定key，比较容易映射复杂值的环境。</p><h2 id="几个主要NoSQL特点介绍："><a href="#几个主要NoSQL特点介绍：" class="headerlink" title="几个主要NoSQL特点介绍："></a>几个主要NoSQL特点介绍：</h2><p><strong>1、 Redis</strong></p><p>  Redis是另外一款因为闪电般的速度而被比较广泛使用的开源NoSQL数据库。它是用C语言开发的。以下是它的几个优点：</p><ul><li><p>数据结构化：Redis提供了一个高效的数据结构扩展，它有时也被称为数据结构服务器。存储在数据库中的键值可以是hash值、列表、字符串、有序或无序集合等。</p></li><li><p>可作为缓存：你可以使用Redis作为一个缓存服务器。</p></li><li><p>非常快：当它以内存的性质工作时，它的执行效率非常的高，此时读写速度几乎没有区别。</p><p><a href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587453007401&di=18474280ef10c73a32891630a4c55ef9&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180327%2F34adc98d775145f0b23c5fa67217af1d.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587453007401&di=18474280ef10c73a32891630a4c55ef9&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20180327%2F34adc98d775145f0b23c5fa67217af1d.png" class="lazyload"></a></p></li></ul><p><strong>2、 Riak</strong></p><p>关键点: 容错性Fault tolerance 失败恢复 　内置全文本搜索<br>　　适合: 如果你希望有类似Cassandra-like (Dynamo-like)风格, 但是你不想处理器复杂性和膨胀性。单服务器有良好可伸缩性scalability, 可用性availability 和容错性 fault-tolerance, 采取是昂贵的多站点复制multi-site replication.<br>　　案例：销售点数据收集，工厂控制系统，那些不能允许几秒当机的场合。</p><p><a href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587453073333&di=c3c361dd89ff04584dcb35e2ff851745&imgtype=0&src=http%3A%2F%2Fattach.dataguru.cn%2Fattachments%2Fforum%2F201303%2F23%2F1100320dctrtor0wgdpgjb.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587453073333&di=c3c361dd89ff04584dcb35e2ff851745&imgtype=0&src=http%3A%2F%2Fattach.dataguru.cn%2Fattachments%2Fforum%2F201303%2F23%2F1100320dctrtor0wgdpgjb.jpg" class="lazyload"></a>  </p><p><strong>3、 HBase</strong></p><p>关键点: 十亿级别的行 X 百万级别的列 大容量<br>　　大表模型(高一致性)。<br>　　Map/reduce with Hadoop 能够实时获得基于查询的优化性能的节约型网关适合:<br>　　适合：随机 实时的读写操作，高吞吐量写，随机访问大数据集。<br>　　案例： Facebook 消息数据库</p><p><a href="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2584488483,381610203&fm=26&gp=0.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2584488483,381610203&fm=26&gp=0.jpg" class="lazyload"></a></p><p><strong>4、 MongoDB</strong></p><p>关键点: 强迫性一致；类SQL，容易上手 , 内置分片碎片<br>　　适合: 需要动态查询. 愿意事先定义索引indexes, 需要巨大的数据库有良好性能。<br>　　案例：适合90%所有MySQL等RDBM场合。<br>　　问题：数据集大于内存很慢。<br>　　MongoDB 使用MapReduce替代SQL的聚合功能进行分析，但是当前是单线程，并不可伸缩。</p><p><a href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587453130629&di=a45abc72396fc92897da77ca229db5ca&imgtype=0&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D3778180096%2C2314235200%26fm%3D214%26gp%3D0.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587453130629&di=a45abc72396fc92897da77ca229db5ca&imgtype=0&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D3778180096%2C2314235200%26fm%3D214%26gp%3D0.jpg" class="lazyload"></a></p><h2 id="SQL与NoSQL区别："><a href="#SQL与NoSQL区别：" class="headerlink" title="SQL与NoSQL区别："></a>SQL与NoSQL区别：</h2><p>1、语言</p><p>SQL数据库定义和操作基于数据的结构化查询语言（SQL）。从侧面看这种语言是非常强大的。SQL是最通用和最广泛使用的选项之一，使其成为安全的选择，尤其适用于复杂的查询。但从另一方面来说，它可能是限制性的。SQL要求您在使用之前使用预定义模式来确定数据的结构。此外，您的所有数据都必须遵循相同的结构。这可能需要大量的前期准备，这意味着结构的变化既困难又对整个系统造成破坏。</p><p>NoSQL数据库具有非结构化数据的动态模式。数据以多种方式存储，这意味着它可以是面向文档，面向列，基于图形或组织为KeyValue存储。这种灵活性意味着可以在没有首先定义结构的情况下创建文档。每个文档也可以有自己独特的结构。语法因数据库而异，您可以随时添加字段。</p><p>2、 可伸缩性</p><p>在几乎所有情况下，SQL数据库都是可垂直扩展的。这意味着您可以通过增加RAM，CPU或SSD等功能来增加单个服务器的负载。但另一方面，NoSQL数据库可以横向扩展。这意味着您可以通过分片或在NoSQL数据库中添加更多服务器来处理更多流量。它类似于在同一建筑物中添加更多楼层，而不是在附近增加更多建筑物。因此NoSQL最终可以变得更大，更强大，使这些数据库成为大型或不断变化的数据集的首选。</p><p>3、 结构</p><p>SQL数据库是基于表的，另一方面NoSQL数据库是键值对，基于文档的，图形数据库或宽列存储。这使得关系SQL数据库成为需要多行事务的应用程序（如会计系统）或为关系结构构建的遗留系统的更好选择。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT使用介绍</title>
      <link href="/2020/04/16/Git/"/>
      <url>/2020/04/16/Git/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>GIT简介</strong></p><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p><p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。<br><a href="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587365740311&di=ce7a763a9cb6581344bcd1244216e792&imgtype=0&src=http%3A%2F%2Fwww.uml.org.cn%2Fpzgl%2Fimages%2F2014081232.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587365740311&di=ce7a763a9cb6581344bcd1244216e792&imgtype=0&src=http%3A%2F%2Fwww.uml.org.cn%2Fpzgl%2Fimages%2F2014081232.png" class="lazyload"></a></p><p><strong>Git的功能特性</strong>：<br>从一般开发者的角度来看，git有以下功能：</p><p>1、 从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。</p><p>2、 在自己的机器上根据不同的开发目的，创建分支，修改代码。</p><p>3、 在单机上自己创建的分支上提交代码。</p><p>4、 在单机上合并分支。</p><p>5、 把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。</p><p>6、 生成补丁（patch），把补丁发送给主开发者。</p><p>7、 看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。</p><p>8、 一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。</p><p><strong>工作原理 / 流程：</strong></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库<br><a href="http://images2015.cnblogs.com/blog/801940/201610/801940-20161020140356295-2001303481.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="http://images2015.cnblogs.com/blog/801940/201610/801940-20161020140356295-2001303481.png" class="lazyload"></a></li></ul><p><strong>GIt和SVN</strong><br>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。</p><p>Git 与 SVN 区别点：</p><p>1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</p><p>2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。</p><p>3、Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。</p><p>4、Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</p><p>5、Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。<br><a href="https://www.runoob.com/wp-content/uploads/2015/02/0D32F290-80B0-4EA4-9836-CA58E22569B3.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.runoob.com/wp-content/uploads/2015/02/0D32F290-80B0-4EA4-9836-CA58E22569B3.jpg" class="lazyload"></a></p><p><strong>配置</strong></p><p>1、 检查本机是否有ssh key设置</p><p>如果没有则提示： No such file or directory</p><p>如果有则进入~/.ssh路径下（ls查看当前路径文件，rm删除所有文件）</p><p>2、 使用Git Bash生成新的ssh key</p><p>$ cd ~ #保证当前路径在”~”下</p><blockquote><p>$ ssh-keygen -t rsa -C “<a href="mailto:xxxxxx@yy.com">xxxxxx@yy.com</a>“  #建议填写自己真实有效的邮箱地址<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/c/Users/xxxx_000/.ssh/id_rsa):   #不填直接回车<br>Enter passphrase (empty for no passphrase):   #输入密码（可以为空）<br>Enter same passphrase again:   #再次确认密码（可以为空）<br>Your identification has been saved in /c/Users/xxxx_000/.ssh/id_rsa.   #生成的密钥<br>Your public key has been saved in /c/Users/xxxx_000/.ssh/id_rsa.pub. #生成的公钥<br>The key fingerprint is:<br>e3:51:33:xx:xx:xx:xx:xxx:61:28:83:e2:81 <a href="mailto:xxxxxx@yy.com">xxxxxx@yy.com</a><br>//本机已完成ssh key设置，其存放路径为：c:/Users/xxxx_000/.ssh/下。<br>//可生成ssh key自定义名称的密钥，默认id_rsa。<br>$ ssh-keygen -t rsa -C “邮箱地址” -f ~/.ssh/githug_blog_keys #生成ssh key的名称为githug_blog_keys，慎用容易出现其它异常。</p></blockquote><p>3、 配置账户</p><blockquote><p>$ git config –global user.name “your_username” #设置用户名<br>$ git config –global user.email “your_registered_github_Email” #设置邮箱地址(建议用注册giuhub的邮箱)</p></blockquote><p>4、 测试ssh keys是否设置成功</p><blockquote><p>$ ssh -T <a href="mailto:git@github.com">git@github.com</a><br>The authenticity of host ‘github.com(192.30.252.129)’ can’t be established.<br>RSA key fingerprint is16:27:xx:xx:xx:xx:xx:4d:eb:df:a6:48.<br>Are you sure you want to continueconnecting (yes/no)? yes #确认你是否继续联系，输入yes<br>Warning: Permanently added’github.com,192.30.252.129’ (RSA) to the list of known hosts.<br>Enter passphrase for key’/c/Users/xxxx_000/.ssh/id_rsa’: #生成sshkye是密码为空则无此项，若设置有密码则有此项且，输入生成ssh key时设置的密码即可。<br>Hi xxx! You’ve successfullyauthenticated, but GitHub does not provide shell access. #出现词句话，说明设置成功。</p></blockquote><p><strong>使用方法</strong></p><p>使用Git前，需要先建立一个仓库(repository)。您可以使用一个已经存在的目录作为Git仓库或创建一个空目录。</p><p>使用您当前目录作为Git仓库，我们只需使它初始化。</p><blockquote><p>git init</p></blockquote><p>我们有一个仓库，但什么也没有，可以使用add命令添加文件。</p><blockquote><p>git add filename</p></blockquote><p>文件提交到仓库</p><blockquote><p>git commit</p></blockquote><p>git commit 命令的-a选项可将所有被修改或者已删除的且已经被git管理的文档提交到仓库中。</p><p>从服务器克隆一个库</p><blockquote><p>git clone</p></blockquote><p>推送到服务器</p><blockquote><p>git pull</p></blockquote><p>从资源库中删除文件，我们使用rm</p><blockquote><p>git rm file</p></blockquote><p>要创建一个新的分支，我们使用branch命令。</p><blockquote><p>git branch</p></blockquote><p>branch命令不会将我们带入分支，只是创建一个新分支。所以我们使用checkout命令来更改分支。</p><p><a href="https://i.loli.net/2020/04/20/yqVIEGitXelW4L8.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://i.loli.net/2020/04/20/yqVIEGitXelW4L8.jpg" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google开发者工具使用教程</title>
      <link href="/2020/04/06/google/"/>
      <url>/2020/04/06/google/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Google Chrome是一款由Google公司开发的网页浏览器，该浏览器基于其他开源软件撰写，包括WebKit，目标是提升稳定性、速度和安全性，并创造出简单且有效率的使用者界面。</p><h1 id="一-如何调出开发者工具"><a href="#一-如何调出开发者工具" class="headerlink" title="一.如何调出开发者工具"></a>一.如何调出开发者工具</h1><ul><li><p>使用F12打开开发者工具</p></li><li><p>在页面上右键–》检查，打开开发者工具。</p></li><li><p>在浏览器有上角左键单击–》更多工具–》开发者工具（快捷键Ctrl+shift+I）<br><a href="https://i.loli.net/2020/04/06/cbZx7CiFOuz4e9M.png" data-fancybox="group" data-caption="1.png" class="fancybox"><img alt="1.png" title="1.png" data-src="https://i.loli.net/2020/04/06/cbZx7CiFOuz4e9M.png" class="lazyload"></a></p></li></ul><p><a href="https://i.loli.net/2020/04/06/1XazNIdZpgCMuYs.png" data-fancybox="group" data-caption="2.png" class="fancybox"><img alt="2.png" title="2.png" data-src="https://i.loli.net/2020/04/06/1XazNIdZpgCMuYs.png" class="lazyload"></a></p><h1 id="二-开发者工具初步介绍"><a href="#二-开发者工具初步介绍" class="headerlink" title="二.开发者工具初步介绍"></a>二.开发者工具初步介绍</h1><p>chrome开发者工具最常用的四个功能模块：元素（ELements）、控制台（Console）、源代码（Sources），网络（Network）。</p><ul><li><p>元素（Elements）：用于查看或修改HTML元素的属性、CSS属性、监听事件、断点等。css可以即时修改，即时显示。大大方便了开发者调试页面</p></li><li><p>控制台（Console）：控制台一般用于执行一次性代码，查看JavaScript对象，查看调试日志信息或异常信息。还可以当作Javascript API查看用。例如我想查看console都有哪些方法和属性，我可以直接在Console中输入”console”并执行~</p></li><li><p>源代码（Sources）：该页面用于查看页面的HTML文件源代码、JavaScript源代码、CSS源代码，此外最重要的是可以调试JavaScript源代码，可以给JS代码添加断点等。</p></li><li><p>网络（Network）：网络页面主要用于查看header等与网络连接相关的信息。</p><h2 id="Elements面板"><a href="#Elements面板" class="headerlink" title="Elements面板"></a>Elements面板</h2><p>这个就是查看、编辑页面上的元素，包括HTML和CSS：<br><a href="https://i.loli.net/2020/04/06/7MA1NWPitKTovyY.png" data-fancybox="group" data-caption="3.png" class="fancybox"><img alt="3.png" title="3.png" data-src="https://i.loli.net/2020/04/06/7MA1NWPitKTovyY.png" class="lazyload"></a></p></li></ul><p>左侧就是对页面HTML结构的查看与编辑，你可以直接在某个元素上双击修改元素的属性，或者你点右键选”Edit as Html”直接对元素的HTML进行编辑，或者删除某个元素，所有的修改都会即时在页面上得到呈现。（注：看到上面右键菜单的最后一个选项”审查元素”了么？这是不是说明这个开发者工具的页面也是HTML来的呢？你点一下就知道了哦，嘿嘿）<br>你还可以对某个元素进行监听，在JS对元素的属性或者HTML进行修改的时候，直接触发断点，跳转到对改元素进行修改的JS代码处：</p><p>Elements标签页的右侧可以对元素的CSS进行查看与编辑修改：</p><p>你还可以通过这里看到各CSS选择器设置的CSS值的覆盖情况。<br>下面的Metrics可以看到元素占的空间情况（宽、高、Padding、Margin神马的）：</p><p><a href="https://i.loli.net/2020/04/06/z4t1k5pCIiERWHf.png" data-fancybox="group" data-caption="1.png" class="fancybox"><img alt="1.png" title="1.png" data-src="https://i.loli.net/2020/04/06/z4t1k5pCIiERWHf.png" class="lazyload"></a></p><p>注意到上面的Properties没有？这个很有用哦，可以让你看到元素具有的方法与属性，比查API手册要方便得多哦（要注意某些方法和属性在IE、FireFox等其他浏览器下面的支持情况哦）。</p><h2 id="Console面板"><a href="#Console面板" class="headerlink" title="Console面板"></a>Console面板</h2><p>就是Javascript控制台了：<br><a href="https://i.loli.net/2020/04/06/osWixav18NGQRD9.png" data-fancybox="group" data-caption="2.png" class="fancybox"><img alt="2.png" title="2.png" data-src="https://i.loli.net/2020/04/06/osWixav18NGQRD9.png" class="lazyload"></a></p><p>这个除了查看错误信息、打印调试信息（console.log()）、写一些测试脚本以外，还可以当作Javascript API查看用。<br>例如我想查看console都有哪些方法和属性，我可以直接在Console中输入”console”并执行：<br>目前控制台方法和属性有：<br>[“$$”, “$x”, “dir”, “dirxml”, “keys”, “values”, “profile”, “profileEnd”, “monitorEvents”, “unmonitorEvents”, “inspect”, “copy”, “clear”, “getEventListeners”, “undebug”, “monitor”, “unmonitor”, “table”, “$0”, “$1”, “$2”, “$3”, “$4”, “$_”]<br>一般情况下我们用来输入信息的方法主要是用到如下四个</p><ul><li>console.log 用于输出普通信息</li><li>console.info 用于输出提示性信息</li><li>console.error用于输出错误信息</li><li>console.warn用于输出警示信息</li><li>console.debug用于输出调试信息</li></ul><h2 id="Resources面板"><a href="#Resources面板" class="headerlink" title="Resources面板"></a>Resources面板</h2><p><a href="https://i.loli.net/2020/04/06/DUMXfmanEF9WbVP.png" data-fancybox="group" data-caption="3.png" class="fancybox"><img alt="3.png" title="3.png" data-src="https://i.loli.net/2020/04/06/DUMXfmanEF9WbVP.png" class="lazyload"></a></p><p>Resources标签页可以查看到请求的资源情况，包括CSS、JS、图片等的内容，同时还可以查看到存储相关的如Cookies、HTML5的Database和LocalStore等，你可以对存储的内容编辑和删除。<br>这里的CSS文件有一个好玩的特性，你可以直接修改CSS文件，并且修改即时生效哦：</p><p>添加断点：在源代码左边有行号，点击对应行的行号，就好给改行添加上一个断点（再次点击可删除断点）。右键点击断点，在弹出的菜单中选择Edit breakpoint可以给该断的添加中断条件。</p><p>中断调试：添加断点后，当JS代码运行到断点时会中断（对于添加了中断条件的断点在符合条件时中断），此时可以将光标放在变量上查看变量的</p><h2 id="Network面板"><a href="#Network面板" class="headerlink" title="Network面板"></a>Network面板</h2><p><a href="https://i.loli.net/2020/04/06/FGjEyqUrNgw2sBX.png" data-fancybox="group" data-caption="1.png" class="fancybox"><img alt="1.png" title="1.png" data-src="https://i.loli.net/2020/04/06/FGjEyqUrNgw2sBX.png" class="lazyload"></a></p><p>Network标签页对于分析网站请求的网络情况、查看某一请求的请求头和响应头还有响应内容很有用，特别是在查看Ajax类请求的时候，非常有帮助。注意是在你打开Chrome开发者工具后发起的请求，才会在这里显示的哦。<br>点击左侧某一个具体去请求URL，可以看到该请求的详细HTTP请求情况：<br><a href="https://i.loli.net/2020/04/06/ZDzY2QpVEW4cykM.png" data-fancybox="group" data-caption="2.png" class="fancybox"><img alt="2.png" title="2.png" data-src="https://i.loli.net/2020/04/06/ZDzY2QpVEW4cykM.png" class="lazyload"></a></p><p>我们可以在这里看到HTTP请求头、HTTP响应头、HTTP返回的内容等信息，对于开发、调试，都是很有用的。</p><h3 id="请求文件具体说明"><a href="#请求文件具体说明" class="headerlink" title="请求文件具体说明"></a>请求文件具体说明</h3><ul><li><p>Headers<br>Header面板列出资源的请求url、HTTP方法、响应状态码、请求头和响应头及它们各自的值、请求参数等等<br><a href="https://i.loli.net/2020/04/06/a7quxNPyUjYGiVl.png" data-fancybox="group" data-caption="1.png" class="fancybox"><img alt="1.png" title="1.png" data-src="https://i.loli.net/2020/04/06/a7quxNPyUjYGiVl.png" class="lazyload"></a></p></li><li><p>Preview：预览面板，用于资源的预览<br><a href="https://i.loli.net/2020/04/06/eqzrWInLmcGBVDK.png" data-fancybox="group" data-caption="2.png" class="fancybox"><img alt="2.png" title="2.png" data-src="https://i.loli.net/2020/04/06/eqzrWInLmcGBVDK.png" class="lazyload"></a></p></li><li><p>Response：响应信息面板包含资源还未进行格式处理的内容<br><a href="https://i.loli.net/2020/04/06/KNmepAYX14kxVIQ.png" data-fancybox="group" data-caption="1.png" class="fancybox"><img alt="1.png" title="1.png" data-src="https://i.loli.net/2020/04/06/KNmepAYX14kxVIQ.png" class="lazyload"></a></p></li><li><p>Timing：资源请求的详细信息花费时间<br><a href="https://i.loli.net/2020/04/06/5wvdpWZXzIc8Pai.png" data-fancybox="group" data-caption="1.png" class="fancybox"><img alt="1.png" title="1.png" data-src="https://i.loli.net/2020/04/06/5wvdpWZXzIc8Pai.png" class="lazyload"></a></p><h2 id="performance面板"><a href="#performance面板" class="headerlink" title="performance面板"></a>performance面板</h2><p><a href="https://i.loli.net/2020/04/06/kBhFzR7wAWP98GJ.png" data-fancybox="group" data-caption="1.png" class="fancybox"><img alt="1.png" title="1.png" data-src="https://i.loli.net/2020/04/06/kBhFzR7wAWP98GJ.png" class="lazyload"></a><br>1、操作区域：包含录制，刷新页面分析，清除结果等一系列操作</p></li><li><p>开始录制按钮(window下快捷键ctrl+E)</p></li><li><p>重新录制按钮</p></li><li><p>清空录制信息</p></li><li><p>打开本地录制文件</p></li><li><p>保存当前录制数据</p></li><li><p>多个录屏的切换</p></li><li><p>是否屏幕快照（勾选了，总览图中会有一系列的屏幕快照，位置在Net和HEAP之间；反之，不会显示屏幕快照）</p></li><li><p>是否显示内存（勾选了，总览图中的屏幕快照下面有一个Heap，就是我们通俗所说的内存）</p></li><li><p>垃圾回收</p></li><li><p>禁止脚本样本（勾选了，在详情区域的Main区域不会显示js事件的调用 ；反之会的。这里可以通过两个录制来看一下【禁止时候的火焰图明显低一些】）</p></li><li><p>调整网络状态（模拟一些网络不好的状况）</p></li><li><p>是否开启加速渲染（默认不用勾选，这个不具体展开）</p></li><li><p>cpu性能设置（可以调整4xslowdown来模拟手机运行）</p></li></ul><p>2、overview总览图：高度概括随时间线的变动，包括FPS，CPU，NET</p><ul><li>FPS。每秒帧数。绿色竖线越高，FPS 越高。 FPS 图表上的红色块表示长时间帧，很可能会出现卡顿</li><li>CPU。 CPU 资源。此面积图指示消耗 CPU 资源的事件类型，不同颜色代表不同资源<br>【蓝色(Loading)：网络通信和HTML解析<br>黄色(Scripting)：JavaScript执行<br>紫色(Rendering)：样式计算和布局，即重排<br>绿色(Painting)：重绘<br>灰色(other)：其它事件花费的时间<br>白色(Idle)：空闲时间）<br>】</li><li>NET。有两条蓝色的长条，深蓝代表优先级比较高的请求，浅蓝代表优先级比较低的请求</li><li>屏幕快照。可以把鼠标放到总览图区域会有一个屏幕快照的弹框图</li><li>HEAP。这就是通常说的内存</li></ul><p>3、详情区域：从不同的角度分析框选区域 。例如：Network，Frames, Interactions, Main等</p><ul><li><p>详情区域主要包括两个部分：上半部分（内存情况）和下半部分（选中的时间段的是事件相关信息统计）<br>4、总结区域：精确到毫秒级的分析，以及按调用层级，事件分类的整理</p></li><li><p>内存情况：<br>JS Heap:js堆<br>Documents:文档数<br>Nodes:DOM 节点数<br>Listeners:监听数<br>GPU Memory:GPU内存</p></li><li><p>总结情况<br>summary:按照网页显示的整个过程，统计每个阶段花费的时间【loading/scripting/rendering/painting/other/idle】<br>Bottom-Up:按照事件花费的时间长短来排序的<br>Call Tree:按照调用顺序来排序的【从根调用事件到当前选中事件】<br>Event Log：按照事件发生的先后顺序排序，显示的事件的详细信息</p><h2 id="Memory面板简介"><a href="#Memory面板简介" class="headerlink" title="Memory面板简介"></a>Memory面板简介</h2><p>如果想要看更多的内存信息快照，则需要打开 Chrome 浏览器的开发者工具中的 Memory 面板了，下面就简单介绍一下该面板的使用。<br>它大概是长这样：<br><a href="https://i.loli.net/2020/04/06/gMup2CUaZQPe3nv.png" data-fancybox="group" data-caption="1.png" class="fancybox"><img alt="1.png" title="1.png" data-src="https://i.loli.net/2020/04/06/gMup2CUaZQPe3nv.png" class="lazyload"></a><br>上面有三个按钮：</p></li><li><p>Heap snapshot - 用以打印堆快照，堆快照文件显示页面的 javascript 对象和相关 DOM 节点之间的内存分配</p></li><li><p>Allocation instrumentation on timeline - 在时间轴上记录内存信息，随着时间变化记录内存信息。</p></li><li><p>Allocation sampling - 内存信息采样，使用采样的方法记录内存分配。此配置文件类型具有最小的性能开销，可用于长时间运行的操作。它提供了由 javascript 执行堆栈细分的良好近似值分配。</p><h2 id="Application面板简介"><a href="#Application面板简介" class="headerlink" title="Application面板简介"></a>Application面板简介</h2><p>该面板主要是记录网站加载的所有资源信息，包括存储数据（Local Storage、Session Storage、IndexedDB、Web SQL、Cookies）、缓存数据、字体、图片、脚本、样式表等。</p></li></ul><p>这个面板跟前前面几道硬菜（Network面板、Timeline面板、Profiles面板）比起来简单多了，这里就稍微作一下介绍：</p><ul><li>Local Storage 如果你在开发过程中使用了local storage来存储键值对(KVPs)，那么你就可以通过Local Storage窗格来检查、新增、修改、删除这个键值对。</li><li>Application Cache 你可以使用Application Cache窗格去查看通过Application Cache API创建的资源。</li><li>Frames 将页面上的资源按frame类别进行组织显示</li></ul><h2 id="Security面板简介"><a href="#Security面板简介" class="headerlink" title="Security面板简介"></a>Security面板简介</h2><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。</p><h3 id="HTTPS和HTTP的区别主要为以下四点："><a href="#HTTPS和HTTP的区别主要为以下四点：" class="headerlink" title="HTTPS和HTTP的区别主要为以下四点："></a>HTTPS和HTTP的区别主要为以下四点：</h3><p>① https协议需要到CA申请证书，一般免费证书很少，需要交费。<br>② http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>③ http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>④ http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><p>如果网页是安全的，则会显示这样一条消息：This page is secure (valid HTTPS).。</p><p>通过点击View certificate可以查看main origin的服务器证书信息。<br>点击左侧可以查看指定源的连接和证书详情。</p><p>如果网页是不安全的，则会显示：This page is not secure.。</p><p>该面板可以区分两种类型的不安全的页面：</p><p>如果被请求的页面通过HTTP提供服务，那么这个主源就会被标记为不安全。<br>如果被请求的页面是通过HTTPS获取的，但这个页面接着通过HTTP继续从其他来源检索内容，那么这个页面仍然被标记为不安全。这就是所谓的混合内容页面,混合内容页面只是部分受到保护,因为HTTP内容(非加密的内容)可以被嗅探者入侵,容易受到中间人攻击。</p><h2 id="Audits面板简介"><a href="#Audits面板简介" class="headerlink" title="Audits面板简介"></a>Audits面板简介</h2><p>这个对于优化前端页面、加速网页加载速度很有用哦（相当与Yslow）：</p><p>点击run按钮，就可以开始分析页面，分析完了就可以看到分析结果了：</p><p>它甚至可以分析出页面上样式表中有哪些CSS是没有被使用的哦：</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用网站及工具</title>
      <link href="/2020/04/06/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99%E5%8F%8A%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/04/06/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99%E5%8F%8A%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="炫猿导航"><a href="#炫猿导航" class="headerlink" title="炫猿导航"></a>炫猿导航</h2><p><strong>官网: <a href="https://xydh.fun/" target="_blank" rel="noopener">https://xydh.fun/</a></strong></p><p>入眼即是12大板块的资源分类得井然有序，开发者也是非常细致地搜集进一些优质软件和网站、云网盘、电影、音乐、图书、学习、生活等类资源，大致估摸着有100多款的工具利器，功能强大。<br><a href="https://i.loli.net/2020/04/15/PUJ9MynZ2FXabiD.png" data-fancybox="group" data-caption="11.png" class="fancybox"><img alt="11.png" title="11.png" data-src="https://i.loli.net/2020/04/15/PUJ9MynZ2FXabiD.png" class="lazyload"></a><br>这里有一个合作的同类网站，也是提供各类资源的一个优质聚合网。<br><a href="https://i.loli.net/2020/04/15/aCEsZmpb9kMthHq.png" data-fancybox="group" data-caption="22.png" class="fancybox"><img alt="22.png" title="22.png" data-src="https://i.loli.net/2020/04/15/aCEsZmpb9kMthHq.png" class="lazyload"></a></p><hr><h2 id="轻松玩转PDF"><a href="#轻松玩转PDF" class="headerlink" title="轻松玩转PDF"></a>轻松玩转PDF</h2><p><strong>官网: <a href="https://smallpdf.com/cn" target="_blank" rel="noopener">https://smallpdf.com/cn</a></strong></p><p>功能一应俱全、简单好用的线上 PDF 工具<br><a href="https://i.loli.net/2020/04/15/yiQcNPhLsnOUbzC.png" data-fancybox="group" data-caption="1.png" class="fancybox"><img alt="1.png" title="1.png" data-src="https://i.loli.net/2020/04/15/yiQcNPhLsnOUbzC.png" class="lazyload"></a></p><hr><h2 id="在线文件转换"><a href="#在线文件转换" class="headerlink" title="在线文件转换"></a>在线文件转换</h2><p><strong>官网: <a href="https://convertio.co/zh/" target="_blank" rel="noopener">https://convertio.co/zh/</a></strong></p><p>将您的文件转换成任意格式<br><a href="https://i.loli.net/2020/04/15/x7FkYgbE1piADQ8.png" data-fancybox="group" data-caption="2.png" class="fancybox"><img alt="2.png" title="2.png" data-src="https://i.loli.net/2020/04/15/x7FkYgbE1piADQ8.png" class="lazyload"></a></p><hr><h2 id="ppt模板"><a href="#ppt模板" class="headerlink" title="ppt模板"></a>ppt模板</h2><ol><li><p>51ppt官网:  <a href="http://www.51pptmoban.com" target="_blank" rel="noopener">http://www.51pptmoban.com</a></p></li><li><p>第1ppt官网: <a href="http://www.1ppt.com/" target="_blank" rel="noopener">http://www.1ppt.com/</a></p></li><li><p>优品ppt<a href="http://www.ypppt.com/" target="_blank" rel="noopener">http://www.ypppt.com/</a></p></li></ol><p>免费ppt模板大全<br><a href="https://i.loli.net/2020/04/15/Xu7O1SLthgsW3br.png" data-fancybox="group" data-caption="1.png" class="fancybox"><img alt="1.png" title="1.png" data-src="https://i.loli.net/2020/04/15/Xu7O1SLthgsW3br.png" class="lazyload"></a></p><hr><h2 id="非常全的外刊网站-MagazineLib"><a href="#非常全的外刊网站-MagazineLib" class="headerlink" title="非常全的外刊网站-MagazineLib"></a>非常全的外刊网站-MagazineLib</h2><p><strong>官网: <a href="https://magazinelib.com/" target="_blank" rel="noopener">https://magazinelib.com/</a></strong></p><p>非常全的外刊网站，基本上想看的外刊都有(可下载）<br><a href="https://pic1.zhimg.com/80/v2-5f39d9a6f9b8338b682f3239c172e26f_720w.jpg" data-fancybox="group" data-caption="2.png" class="fancybox"><img alt="2.png" title="2.png" data-src="https://pic1.zhimg.com/80/v2-5f39d9a6f9b8338b682f3239c172e26f_720w.jpg" class="lazyload"></a></p><hr><h2 id="万花筒"><a href="#万花筒" class="headerlink" title="万花筒"></a>万花筒</h2><p><strong>官网: <a href="https://wht.im/" target="_blank" rel="noopener">https://wht.im/</a></strong></p><p>一个极简的网址导航，聚合了多种搜索引擎，也收录了各种常用的网站。分类合，内容齐全。<br><a href="https://pic2.zhimg.com/80/v2-bebebdae7a580ee0e276cc22b8ace9ea_720w.jpg" data-fancybox="group" data-caption="2.png" class="fancybox"><img alt="2.png" title="2.png" data-src="https://pic2.zhimg.com/80/v2-bebebdae7a580ee0e276cc22b8ace9ea_720w.jpg" class="lazyload"></a></p><hr><h2 id="音乐下载"><a href="#音乐下载" class="headerlink" title="音乐下载"></a>音乐下载</h2><p>官网1: <a href="http://www.gequdaquan.net/gqss/" target="_blank" rel="noopener">http://www.gequdaquan.net/gqss/</a></p><p>官网2: <a href="http://www.musictool.top/" target="_blank" rel="noopener">http://www.musictool.top/</a></p><p>音乐大全<br><a href="https://seechina365.com/wp-content/uploads/musiccc01.jpg" data-fancybox="group" data-caption="2.png" class="fancybox"><img alt="2.png" title="2.png" data-src="https://seechina365.com/wp-content/uploads/musiccc01.jpg" class="lazyload"></a></p><hr><h2 id="搜索工具"><a href="#搜索工具" class="headerlink" title="搜索工具"></a>搜索工具</h2><p>官网1: <a href="https://bigezhang.com/so" target="_blank" rel="noopener">https://bigezhang.com/so</a></p><p>官网2: <a href="https://search.chongbuluo.com/" target="_blank" rel="noopener">https://search.chongbuluo.com/</a></p><p>一个极简的网址导航，聚合了多种搜索引擎，也收录了各种常用的网站。分类合，内容齐全。<br><a href="http://img.jusoucn.com/data/upload/image/201907/a1e96e613f31ea9124ef4de489a1b980.png" data-fancybox="group" data-caption="2.png" class="fancybox"><img alt="2.png" title="2.png" data-src="http://img.jusoucn.com/data/upload/image/201907/a1e96e613f31ea9124ef4de489a1b980.png" class="lazyload"></a></p><hr><h2 id="影视大全"><a href="#影视大全" class="headerlink" title="影视大全"></a>影视大全</h2><ol><li><p>电影天堂: <a href="http://t.cn/R0HK0BP" target="_blank" rel="noopener">http://t.cn/R0HK0BP</a></p></li><li><p>疯狂影视搜索 : <a href="http://t.cn/RXnQLYO" target="_blank" rel="noopener"> http://t.cn/RXnQLYO</a></p></li><li><p>优质电影网  : <a href="http://t.cn/RLGSHq6" target="_blank" rel="noopener">http://t.cn/RLGSHq6</a></p></li><li><p>美剧  : <a href="http://www.6vhao.tv/mj/" target="_blank" rel="noopener">http://www.6vhao.tv/mj/</a></p></li></ol><p><a href="http://www.youzhidy.com/uploads/allimg/200209/1-2002091340291Z.jpg" data-fancybox="group" data-caption="2.png" class="fancybox"><img alt="2.png" title="2.png" data-src="http://www.youzhidy.com/uploads/allimg/200209/1-2002091340291Z.jpg" class="lazyload"></a></p><hr><h2 id="数据-类网站"><a href="#数据-类网站" class="headerlink" title="数据 类网站"></a>数据 类网站</h2><ol><li><p>艾瑞咨询: <a href="https://www.iresearch.com.cn/" target="_blank" rel="noopener">https://www.iresearch.com.cn/</a></p></li><li><p>腾讯大数据 : <a href="https://data.qq.com/" target="_blank" rel="noopener"> https://data.qq.com/</a></p></li><li><p>新榜 : <a href="https://www.newrank.cn/" target="_blank" rel="noopener">https://www.newrank.cn/</a></p></li></ol><p><a href="https://pic2.zhimg.com/80/v2-3793d3ca3a5cf11907d707291da76c18_720w.jpg" data-fancybox="group" data-caption="2.png" class="fancybox"><img alt="2.png" title="2.png" data-src="https://pic2.zhimg.com/80/v2-3793d3ca3a5cf11907d707291da76c18_720w.jpg" class="lazyload"></a></p><hr><h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><ol><li><p>吾爱破解: <a href="https://www.52pojie.cn/" target="_blank" rel="noopener">https://www.52pojie.cn/</a></p></li><li><p>GO破解 : <a href="https://www.gopojie.net/" target="_blank" rel="noopener">https://www.gopojie.net/</a></p></li><li><p>ZD423: <a href="https://m.zdfans.com//" target="_blank" rel="noopener">https://m.zdfans.com/</a></p></li><li><p>软件缘: <a href="https://www.appcgn.com/" target="_blank" rel="noopener">https://www.appcgn.com/</a></p></li><li><p>爱软客 : <a href="http://www.bokeboke.net/" target="_blank" rel="noopener">http://www.bokeboke.net/</a></p></li><li><p>分享者: <a href="http://www.sharerw.com/" target="_blank" rel="noopener">http://www.sharerw.com/</a></p></li></ol><hr><ul><li>好用网站<a href="https://www.zhihu.com/question/311420011" target="_blank" rel="noopener">https://www.zhihu.com/question/311420011</a></li></ul><ul><li><p>好用网站<a href="https://www.zhihu.com/question/345910983" target="_blank" rel="noopener">https://www.zhihu.com/question/345910983</a></p></li><li><p>好用网站<a href="https://zhuanlan.zhihu.com/p/91748529" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91748529</a></p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用网站及工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的数据结构：数组，栈，链表，队列，树，图，堆，散列表</title>
      <link href="/2020/04/05/data%20struct/"/>
      <url>/2020/04/05/data%20struct/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等。</p><p>每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。</p><p><a href="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2342770679,2195164754&fm=26&gp=0.jpg" data-fancybox="group" data-caption="3.jpeg" class="fancybox"><img alt="3.jpeg" title="3.jpeg" data-src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2342770679,2195164754&fm=26&gp=0.jpg" class="lazyload"></a></p><hr><h1 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h1><h2 id><a href="#" class="headerlink" title></a><a href="https://i.loli.net/2020/04/05/f24nrTsY6VU1kKy.jpg" data-fancybox="group" data-caption="3.jpeg" class="fancybox"><img alt="3.jpeg" title="3.jpeg" data-src="https://i.loli.net/2020/04/05/f24nrTsY6VU1kKy.jpg" class="lazyload"></a></h2><p>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为1。</p><p>arr是数组的名字,后面的” [] “表示哪一个数据,这里面的数字叫做数组下标,或者叫索引,下标是从0开始计数,比如想要查询小红的话则是” arr[1] </p><p>数组的数据是按照顺序存储在内存中连续的空间,所以内存中的每个数据都可以通过下标来取得,这样就可以直接进行访问数据,如果我们使用链表的话,那么就需要指针一个个去查询数据,数组可以直接访问,这样查询效率就会大大提升,但是想要在任意未知去添加数据和删除数据的话,那么数组的操作就比链表难多了,如果我们想把” 小王 “加入到小明的后面,也就是 arr[1] 的位置,首先数组的末尾需要有足够的空间,(java中数组的长度一但初始化就不可改变,所以要保证有足够的空间来存放想要添加的数据),如果已经有空间,那么我们需要将小黑向后移动一位,然后小红向后移动一位,当arr[1] 的空间空出来的时候,才能把小王添加进去,这样的话数组的添加操作才能完成,相反如果想要删除掉小王的话,那么就需要删除目标的数据,也就是arr[1]的位置,然后把后面的数据往前移动,最后删除掉多余的空间即可</p><p>数组的查询数据的时间复杂度为O(1),删除和添加则为O(n),正好和链表相反</p><p><strong>优点：</strong><br>1、 按照索引查询元素快</p><p>2、 按照索引遍历数组方便</p><p><strong>缺点：</strong></p><p>1、 数组的大小固定后就无法扩容了</p><p>2、 数组只能存储一种类型的数据</p><p>3、 添加，删除的操作慢，因为要移动其他的元素。</p><p>适用场景：</p><p>频繁查询，对存储空间要求不大，很少增加和删除的情况。</p><hr><h1 id="2、栈"><a href="#2、栈" class="headerlink" title="2、栈"></a>2、栈</h1><p><a href="https://i.loli.net/2020/04/05/Ou7xtFkvKmTPQA4.jpg" data-fancybox="group" data-caption="2.jpeg" class="fancybox"><img alt="2.jpeg" title="2.jpeg" data-src="https://i.loli.net/2020/04/05/Ou7xtFkvKmTPQA4.jpg" class="lazyload"></a></p><p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。</p><p>栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。</p><hr><h1 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h1><p><a href="https://i.loli.net/2020/04/05/zKjpIbo38k4TH7J.jpg" data-fancybox="group" data-caption="4.jpeg" class="fancybox"><img alt="4.jpeg" title="4.jpeg" data-src="https://i.loli.net/2020/04/05/zKjpIbo38k4TH7J.jpg" class="lazyload"></a></p><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：</p><p>适用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</p><hr><h1 id="4、链表"><a href="#4、链表" class="headerlink" title="4、链表"></a>4、链表</h1><p><a href="https://i.loli.net/2020/04/05/6kCJLnxbsdASDPK.jpg" data-fancybox="group" data-caption="5.jpeg" class="fancybox"><img alt="5.jpeg" title="5.jpeg" data-src="https://i.loli.net/2020/04/05/6kCJLnxbsdASDPK.jpg" class="lazyload"></a></p><p>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。</p><p><strong>优点：</strong></p><p>1、 链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；</p><p>2、 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；</p><p><strong>缺点：</strong></p><p>1、 因为含有大量的指针域，占用空间较大；</p><p>2、 查找元素需要遍历链表来查找，非常耗时。</p><p>适用场景：<br>数据量较小，需要频繁增加，删除操作的场景</p><hr><h1 id="5、树"><a href="#5、树" class="headerlink" title="5、树"></a>5、树</h1><p><a href="https://i.loli.net/2020/04/05/5iFQp2zevNMjoqy.jpg" data-fancybox="group" data-caption="6.jpeg" class="fancybox"><img alt="6.jpeg" title="6.jpeg" data-src="https://i.loli.net/2020/04/05/5iFQp2zevNMjoqy.jpg" class="lazyload"></a></p><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><p>1、每个节点有零个或多个子节点；</p><p>2、没有父节点的节点称为根节点；</p><p>3、每一个非根节点有且只有一个父节点；</p><p>4、除了根节点外，每个子节点可以分为多个不相交的子树；</p><p>在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。<br>二叉树是树的特殊一种，具有如下特点：</p><p>1、每个结点最多有两颗子树，结点的度最大为2。</p><p>2、左子树和右子树是有顺序的，次序不能颠倒。</p><p>3、即使某结点只有一个子树，也要区分左右子树。</p><p>二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。</p><p><strong>扩展：</strong><br> 二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。</p><hr><h1 id="6、散列表"><a href="#6、散列表" class="headerlink" title="6、散列表"></a>6、散列表</h1><p><a href="https://i.loli.net/2020/04/05/eKhcRydQr5u2wgk.jpg" data-fancybox="group" data-caption="1.jpeg" class="fancybox"><img alt="1.jpeg" title="1.jpeg" data-src="https://i.loli.net/2020/04/05/eKhcRydQr5u2wgk.jpg" class="lazyload"></a></p><p>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p><p>记录的存储位置=f(key)</p><p>这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。</p><p>哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：</p><p>从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p><p>哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。</p><hr><h1 id="7、堆"><a href="#7、堆" class="headerlink" title="7、堆"></a>7、堆</h1><p><a href="https://i.loli.net/2020/04/05/uTBxQsWoh35iUgV.jpg" data-fancybox="group" data-caption="7.jpeg" class="fancybox"><img alt="7.jpeg" title="7.jpeg" data-src="https://i.loli.net/2020/04/05/uTBxQsWoh35iUgV.jpg" class="lazyload"></a></p><p>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p><p>堆中某个节点的值总是不大于或不小于其父节点的值；</p><p>堆总是一棵完全二叉树。</p><p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p><p>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。</p><p>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：</p><p>因为堆有序的特点，一般用来做数组中的排序，称为堆排序。</p><h1 id="8、图"><a href="#8、图" class="headerlink" title="8、图"></a>8、图</h1><p><a href="https://i.loli.net/2020/04/05/whcj1ieqQYVtPra.jpg" data-fancybox="group" data-caption="8.jpeg" class="fancybox"><img alt="8.jpeg" title="8.jpeg" data-src="https://i.loli.net/2020/04/05/whcj1ieqQYVtPra.jpg" class="lazyload"></a></p><p><strong>图的定义：</strong><br>　　一个图G = (V,E)由顶点(vertex)集 V 合边(edge)集 E 组成。每条边(v,w)就是一个点对,其中v,w ∈ V。有时也把边称作弧。如果点对是有序的，那么图就叫做有向图。顶点 v 和 w 领接边 (v,w) ∈ E。在一个具有边(v,w)从而具有边(w,v)的无向图，w和v邻接那v和w也邻接。</p><p><strong>图的基本术语：</strong><br>1、 阶（Order）：图G中顶集V的大小称作图G的阶。</p><p>2、 子图（Sub-Graph）：G’称作图G=(V,E)的子图，当图G’=(V’,E’)，且V‘包含于V，E’包含于E。每个图都是本身的子图。</p><p>3、 生成子图（Spanning Sub-Graph）：指满足条件V(G’) = V(G)的G的子图G。</p><p>4、 度（Degree）：一个顶点的度是指与该边相关联的边的条数，顶点v的度记作d(v)。</p><p>5、 入度（In-degree）和出度（Out-degree）：对于有向图来说，一个顶点的度可细分为入度和出度。一个顶点的入度是指与其关联的各边之中，以其为终点的边数；出度则是相对的概念，指以该顶点为起点的边数。</p><p>6、 自环（Loop）：若一条边的两个顶点为同一顶点，则此边称作自环。</p><p>7、 路径（Path）：从u到v的一条路径是指一个序列v0,e1,v1,e2,v2,…ek,vk，其中ei的顶点为vi及vi - 1，k称作路径的长度。如果它的起止顶点相同，该路径是“闭”的，反之，则称为“开”的。一条路径称为一简单路径(simple path)，如果路径中除起始与终止顶点可以重合外，所有顶点两两不等。</p><p>8、 连通图：如果在一个无向图中从每一个顶点到每个其他顶点都存在一条路径，则称该无向图是联通的，具有这样的有向图成为强连通图。</p><p><strong>图的基本操作：</strong></p><p>（1）创建一个图结构 CreateGraph(G)</p><p>（2）检索给定顶点 LocateVex(G,elem)</p><p>（3）获取图中某个顶点 GetVex(G,v)</p><p>（4）为图中顶点赋值 PutVex(G,v,value)</p><p>（5）返回第一个邻接点 FirstAdjVex(G,v)</p><p>（6）返回下一个邻接点 NextAdjVex(G,v,w)</p><p>（7）插入一个顶点 InsertVex(G,v)</p><p>（8）删除一个顶点 DeleteVex(G,v)</p><p>（9）插入一条边 InsertEdge(G,v,w)</p><p>（10）删除一条边 DeleteEdge(G,v,w)</p><p>（11）遍历图 Traverse(G,v)</p><p><strong>图的高级算法：</strong></p><p>1、 最小生成树（Prim和kruskal算法）</p><p>2、 单元路径最短（Dijkstra算法）</p><p>3、所有点对的最短路径（Floyd-Warshall算法）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP与HTTPS简介</title>
      <link href="/2020/03/22/HTTP%E4%B8%8EHTTPS/"/>
      <url>/2020/03/22/HTTP%E4%B8%8EHTTPS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTTP-简介"><a href="#HTTP-简介" class="headerlink" title="HTTP 简介"></a>HTTP 简介</h1><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><h2 id="HTTP-工作原理"><a href="#HTTP-工作原理" class="headerlink" title="HTTP 工作原理"></a>HTTP 工作原理</h2><p>HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><p>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。</p><p>Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p><h2 id="HTTP三点注意事项："><a href="#HTTP三点注意事项：" class="headerlink" title="HTTP三点注意事项："></a>HTTP三点注意事项：</h2><ul><li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li><li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>以下图表展示了HTTP协议通信流程：</li></ul><p><a href="https://www.runoob.com/wp-content/uploads/2013/11/cgiarch.gif" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.runoob.com/wp-content/uploads/2013/11/cgiarch.gif" class="lazyload"></a></p><h1 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h1><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h2 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h2><p>我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。</p><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p><p>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p><p>（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p><p>（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p><p>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p><p>（5）Web服务器利用自己的私钥解密出会话密钥。</p><p>（6）Web服务器利用会话密钥加密与客户端之间的通信。</p><p><a href="https://www.sslzhengshu.com/upload/7/7e327e701ba6.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://www.sslzhengshu.com/upload/7/7e327e701ba6.jpg" class="lazyload"></a></p><h2 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h2><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><p>（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p><p>（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p><p>（3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p><p>（4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h2 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h2><ul><li><p>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密</p></li><li><p>HTTP 的端口号是 80，HTTPS 是 443</p></li><li><p>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费</p></li><li><p>HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全</p></li></ul><h1 id="SSL介绍："><a href="#SSL介绍：" class="headerlink" title="SSL介绍："></a>SSL介绍：</h1><p>安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议，提供两个基本的安全服务：鉴别与保密。</p><p>SSL是Netscape于1994年开发的，后来成为了世界上最著名的web安全机制，所有主要的浏览器都支持SSL协议。</p><p>目前有三个版本：2、3、3.1，最常用的是第3版，是1995年发布的。</p><p>在客户端与服务器间传输的数据是通过使用对称算法（如 DES 或 RC4）进行加密的。公用密钥算法（通常为 RSA）是用来获得加密密钥交换和数字签名的，此算法使用服务器的SSL数字证书中的公用密钥。有了服务器的SSL数字证书，客户端也可以验证服务器的身份。SSL 协议的版本 1 和 2 只提供服务器认证。版本 3 添加了客户端认证，此认证同时需要客户端和服务器的数字证书。</p><h2 id="SSL协议的三个特性"><a href="#SSL协议的三个特性" class="headerlink" title="SSL协议的三个特性"></a>SSL协议的三个特性</h2><p>① 保密：在握手协议中定义了会话密钥后，所有的消息都被加密。</p><p>② 鉴别：可选的客户端认证，和强制的服务器端认证。</p><p>③ 完整性：传送的消息包括消息完整性检查（使用MAC）。</p><p>SSL的位置</p><p>SSL介于应用层和TCP层之间。应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头。</p><h2 id="SSL的工作原理"><a href="#SSL的工作原理" class="headerlink" title="SSL的工作原理"></a>SSL的工作原理</h2><p>握手协议（Handshake protocol）</p><p>记录协议（Record protocol）</p><p>警报协议（Alert protocol）</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP与HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/2020/03/22/python/"/>
      <url>/2020/03/22/python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="python第三方包国内镜像网址"><a href="#python第三方包国内镜像网址" class="headerlink" title="python第三方包国内镜像网址"></a>python第三方包国内镜像网址</h2><p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></p><p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a> (比较好用)</p><p>华中理工大学：<a href="http://pypi.hustunique.com/" target="_blank" rel="noopener">http://pypi.hustunique.com/</a></p><p>山东理工大学：<a href="http://pypi.sdutlinux.org/" target="_blank" rel="noopener">http://pypi.sdutlinux.org/</a></p><p>豆瓣：<a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></p><h3 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h3><p>可以在使用pip的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>例如：pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyspider，这样就会从清华这边的镜像去安装pyspider库。</p><h3 id="永久使用"><a href="#永久使用" class="headerlink" title="永久使用"></a>永久使用</h3><p>Linux下，修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)<br>windows下，直接在user目录中创建一个pip目录，再新建文件pip.ini。（例如：C:\Users\WQP\pip\pip.ini）内容同上</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/13/hello-world/"/>
      <url>/2020/03/13/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hello Word </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
